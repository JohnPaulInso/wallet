<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Smart Wallet</title>
    <meta name="application-name" content="Smart Wallet">
    <meta name="description" content="Smart Wallet ‚Äî Your personal finance tracker. Track expenses, sync bank transactions from Gmail, set budgets, and visualize your spending.">
    <link rel="icon" type="image/png" href="applogo.png?v=4">
    <link rel="apple-touch-icon" href="applogo.png?v=4">
    
    <!-- Material UI CSS & Premium Fonts -->
    <link href="https://cdn.muicss.com/mui-0.10.3/css/mui.min.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700;800&family=Lexend:wght@700;800;900&display=swap">
    <link href="https://fonts.cdnfonts.com/css/lemon-milk" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <link rel="manifest" href="manifest.json?v=2">
    <meta name="theme-color" content="#000000">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <!-- AUTH PERFORMANCE OPTIMIZATION (PRELOADS) -->
    <link rel="modulepreload" href="https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js">
    <link rel="modulepreload" href="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js">
    <link rel="modulepreload" href="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js">
    
    <!-- SPEED UP FIREBASE AUTH POPUP -->
    <link rel="preconnect" href="https://accounts.google.com">
    <link rel="preconnect" href="https://atome-wallet.firebaseapp.com">
    <link rel="dns-prefetch" href="https://accounts.google.com">
    <link rel="dns-prefetch" href="https://atome-wallet.firebaseapp.com">
    
    <!-- GOOGLE IDENTITY SERVICES (EAGER LOAD) -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('SW registered:', reg.scope))
                    .catch(err => console.warn('SW registration failed:', err));
            });
        }
    </script>

<link rel="stylesheet" href="index.css">

   
<style>

</style>





</head>
<body>
    <!-- PRIVACY LOCK OVERLAY (NEW) -->
    <div id="privacy-lock" class="privacy-lock-overlay" style="display: none;">
        <div style="font-size: 22px; font-weight: 900; color: #1e293b; margin-bottom: 8px; letter-spacing: -0.5px;">Security Lock</div>
        <div style="font-size: 13px; color: #94a3b8; font-weight: 700; margin-bottom: 40px; text-transform: uppercase; letter-spacing: 0.5px;">Enter PIN to unlock Wallet</div>
        <div class="pin-dots" id="pin-dots">
            <div class="pin-dot"></div>
            <div class="pin-dot"></div>
            <div class="pin-dot"></div>
            <div class="pin-dot"></div>
        </div>
        <div class="pin-grid">
            <button class="pin-btn" onclick="handlePinInput('1')">1</button>
            <button class="pin-btn" onclick="handlePinInput('2')">2</button>
            <button class="pin-btn" onclick="handlePinInput('3')">3</button>
            <button class="pin-btn" onclick="handlePinInput('4')">4</button>
            <button class="pin-btn" onclick="handlePinInput('5')">5</button>
            <button class="pin-btn" onclick="handlePinInput('6')">6</button>
            <button class="pin-btn" onclick="handlePinInput('7')">7</button>
            <button class="pin-btn" onclick="handlePinInput('8')">8</button>
            <button class="pin-btn" onclick="handlePinInput('9')">9</button>
            <div></div>
            <button class="pin-btn" onclick="handlePinInput('0')">0</button>
            <button class="pin-btn" onclick="handlePinInput('back')"><i class="material-icons">backspace</i></button>
        </div>
        <button class="mui-btn mui-btn--flat" onclick="tryBiometricUnlock()" id="bio-btn" style="margin-top: 60px; color: #3b82f6; font-size: 11px; font-weight: 800; display: none; text-transform: uppercase;">
            <i class="material-icons" style="margin-right: 8px; font-size: 20px;">fingerprint</i>
            Use Biometrics
        </button>
    </div>

    <!-- CHART TOOLTIP -->
    <div id="chart-tooltip"></div>

    <!-- BLUR OVERLAY FOR LONG-PRESS MENU -->
    <div id="blur-overlay" class="blur-overlay" onclick="closeIOSMenu()"></div>
    
    <!-- IOS-STYLE ACTION MENU -->
    <div id="ios-menu" class="ios-action-menu"></div>

    <!-- BIOMETRIC LOCK SCREEN -->
    <div class="biometric-overlay" id="biometricOverlay">
        <div class="biometric-icon">
            <i class="material-icons" id="biometricIconType">fingerprint</i>
        </div>
        <div class="biometric-title" id="biometricTitle">Unlock SmartWallet</div>
        <div class="biometric-subtitle" id="biometricSubtitle">Use your fingerprint or Face ID to access your wallet</div>
        <div class="biometric-error" id="biometricError">Authentication failed. Please try again.</div>
        <button class="biometric-btn" id="biometricBtn" onclick="triggerBiometricAuth()">
            <i class="material-icons" style="vertical-align: middle; margin-right: 8px;">fingerprint</i>
            Authenticate
        </button>
        <div class="biometric-skip" id="biometricSkip" onclick="skipBiometric()">Skip for now</div>
    </div>

    <div class="mobile-wrapper">
        <script>
            // Safety shim: Ensure handleAuthClick exists immediately
            if (!window.handleAuthClick) {
                window.handleAuthClick = () => {
                   console.log('‚è≥ Auth module loading... please wait.');
                   // Optional: show a small toast or spinner
                };
            }
        </script>
         <!-- GUEST LOGIN GATE (hidden by default, shown only for confirmed guests) -->
         <div id="guestGate" class="guest-gate-overlay" style="display:none">
             <div class="guest-gate-card">
                 <img src="applogo.png" alt="Smart Wallet" style="width: 64px; height: 64px; border-radius: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.08);">
                 <div>
                     <h1 style="font-size: 22px; font-weight: 900; color: #121212; margin: 0 0 6px 0;">Smart Wallet</h1>
                     <p style="font-size: 13px; color: #64748b; margin: 0; line-height: 1.6;">Your personal finance tracker. Track expenses, sync bank transactions from Gmail, set budgets, and visualize your spending ‚Äî all in one app.</p>
                 </div>
                 <button class="guest-gate-btn" onclick="handleAuthClick()">
                     <svg viewBox="0 0 48 48" width="20px" xmlns="http://www.w3.org/2000/svg"><path d="M44.5 20H24v8.5h11.8C34.7 33.9 30.1 37 24 37c-7.2 0-13-5.8-13-13s5.8-13 13-13c3.1 0 5.9 1.1 8.1 2.9l6.4-6.4C34.6 4.1 29.6 2 24 2 11.8 2 2 11.8 2 24s9.8 22 22 22c11 0 21-8 21-22 0-1.3-.2-2.7-.5-4z" fill="#FFF"/></svg>
                     Continue with Google
                 </button>
                 <div style="display: flex; align-items: center; gap: 6px; margin-top: 8px;">
                     <a href="privacy.html" style="font-size: 9px; font-weight: 600; color: #b0b8c4; text-decoration: none; letter-spacing: 0.3px;">Privacy</a>
                     <span style="font-size: 9px; color: #cbd5e1;">¬∑</span>
                     <a href="terms.html" style="font-size: 9px; font-weight: 600; color: #b0b8c4; text-decoration: none; letter-spacing: 0.3px;">Terms</a>
                 </div>
             </div>
         </div>

         <script>
             // EARLY GATE CHECK: Show immediately for guests, hide for returning Google users
             if (localStorage.getItem('wallet_auth_type') !== 'google') {
                 document.getElementById('guestGate').style.display = 'flex';
             }
         </script>

        <div id="header">
            <div class="header-logo-box" style="display: flex; align-items: center; gap: 12px;">
                <!-- Dynamic Card Icon -->
                <svg id="header-card-icon" class="header-logo" viewBox="0 0 48 30" xmlns="http://www.w3.org/2000/svg">
                    <!-- Card Background -->
                    <rect width="48" height="30" rx="4" fill="#1a1a1a" id="card-bg"/>
                    
                    <!-- Mastercard Logo (bottom right) -->
                    <g transform="translate(32, 20)">
                        <circle cx="4" cy="4" r="3.5" fill="#eb001b" opacity="0.9"/>
                        <circle cx="8" cy="4" r="3.5" fill="#f79e1b" opacity="0.9"/>
                    </g>
                    
                    <!-- Card Chip (optional detail) -->
                    <rect x="6" y="8" width="8" height="6" rx="1" fill="#d4af37" opacity="0.3"/>
                </svg>
                
                <div class="greeting-section">
                    <div class="greeting-text">Hello,</div>
                    <div class="user-name" id="user-display-name">Guest</div>
                </div>
            </div>
            <div class="profile-container">
            <div id="profile-badge" onclick="toggleProfileDropdown(event)">
                <i class="material-icons">person</i>
                <img id="user-pic" src="" alt="Profile" referrerpolicy="no-referrer">
            </div>
            <div id="profile-dropdown" class="profile-dropdown">
                 <div class="dropdown-item" onclick="handleAuthClick()">
                    <i class="material-icons">sync</i>
                    <span>Google Sync</span>
                </div>
                <div class="dropdown-item" onclick="toggleDarkMode()">
                    <i class="material-icons" id="dark-mode-icon">dark_mode</i>
                    <span id="dark-mode-text">Dark Mode</span>
                </div>
                <div class="dropdown-item" onclick="promptSetPin()">
                    <i class="material-icons">lock</i>
                    <span>Privacy PIN</span>
                </div>
                <div class="dropdown-item" id="biometric-menu-item" onclick="toggleBiometricSetting()">
                    <i class="material-icons">fingerprint</i>
                    <span>Biometric Login</span>
                    <div class="biometric-status-dot" id="biometric-status-dot"></div>
                </div>
                <div class="dropdown-item logout" onclick="handleSignout()">
                    <i class="material-icons">logout</i>
                    <span>Log Out</span>
                </div>
            </div>
        </div>
        </div>

        <!-- HEADER SPACER - Prevents content from hiding behind fixed header -->
        <div class="header-spacer"></div>
        
        <!-- MODERN PULL-TO-REFRESH SPINNER -->
        <div class="ptr-container" id="ptrContainer">
            <div class="ptr-spinner" id="ptrSpinner">
                <svg viewBox="0 0 24 24">
                    <circle class="ptr-circle" cx="12" cy="12" r="10" />
                </svg>
            </div>
        </div>

        <!-- SWIPEABLE CARD VIEWPORT -->
        <div class="card-viewport" id="cardViewport">
            <div class="card-carousel-scroll" id="cardCarouselScroll">
                <!-- DYNAMICALLY RENDERED CARDS -->
                <div id="dynamic-balance-cards" style="display: contents;">
                    <!-- Default Wallet Card (Static Placeholder) -->
                    <div class="balance-card active" id="default_walletCard" data-account="default_wallet" style="background: #121212;">
                        <div class="card-header-row">
                            <div style="display: flex; align-items: baseline; gap: 6px;">
                                <div class="card-label" style="text-transform: uppercase;">My Wallet</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                             <div class="balance-amount">PHP 0.00</div>
                        </div>
                        <div class="card-footer" style="margin-top: 20px;">
                            <div class="card-number-box">
                                <div class="card-number-label" style="text-transform: uppercase;">Account Number</div>
                                <div class="card-number" style="letter-spacing: 2px;">‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 0000</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <button class="sync-icon-btn">
                                    <i class="material-icons">sync</i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="add-card-placeholder" onclick="window.location.href='account_setup.html'">
                    <i class="material-icons">add_circle_outline</i>
                    <span>Add New<br>Card</span>
                </div>
            </div>
        </div>

        <!-- SHARED SYNC BAR REMOVED AND MOVED INTO CARDS -->



        <!-- CHART TOOLTIP -->
        <div id="chart-tooltip" style="position: fixed; background: rgba(15, 23, 42, 0.95); color: #fff; padding: 10px 14px; border-radius: 10px; font-size: 12px; font-weight: 700; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 9999; box-shadow: 0 10px 25px rgba(0,0,0,0.3); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); line-height: 1.4; white-space: nowrap;"></div>

        <div class="mui-container">
            <!-- Buttons integrated into card sync bar -->
            
            <!-- RELOCATED ANALYTICS SECTION -->
            


            <!-- SUBSCRIPTION CARD (MOVED BELOW HISTORY) -->

            <!-- SAFE TO SPEND WIDGET (BPI ONLY) -->
            <div id="safe-spend-widget" class="safe-spend-card">
                <div class="safe-spend-header-v2">
                    <h3 style="margin: 0; font-size: 1.1rem; font-weight: 800; color: var(--text-primary); letter-spacing: -0.5px;">Safe To Spend</h3>
                    <button class="obligation-btn" onclick="promptSetObligations()">
                        <i class="material-icons" style="font-size: 14px;">add</i> ADD
                    </button>
                </div>
                
                <div id="safe-spend-val" class="safe-spend-amount-v2 privacy-mask">PHP 0.00</div>
                <div class="safe-spend-subtitle-v2">Safe budget until <span id="budget-until-date">Jan 30</span> (Wallet + Salary)</div>

                <div class="breakdown-list" id="safe-spend-breakdown">
                    <!-- Maintaining Balance -->
                    <div class="breakdown-item" id="item-maintaining" onclick="toggleMaintainingBalance()" style="cursor: pointer; transition: all 0.3s ease;">
                        <div class="breakdown-icon breakdown-red" id="icon-maintaining">
                            <i class="material-icons" id="maintaining-check">account_balance</i>
                        </div>
                        <div class="breakdown-info">
                            <div class="breakdown-name">MAINTAINING BALANCE</div>
                            <div class="breakdown-meta" id="maintaining-meta">BPI Required</div>
                        </div>
                        <div id="breakdown-maintaining" class="breakdown-val breakdown-red-text privacy-mask">‚Ç±3,000.00</div>
                    </div>

                    <!-- Credit Card Payment -->
                    <div class="breakdown-item" id="item-credit">
                        <div class="breakdown-left" onclick="toggleAtome()" style="display: flex; align-items: center; gap: 10px; flex: 1; cursor: pointer;">
                            <div class="breakdown-icon breakdown-yellow" id="icon-credit">
                                <i class="material-icons" id="credit-check">credit_card</i>
                            </div>
                            <div class="breakdown-info">
                                <div class="breakdown-name">CREDIT CARD PAYMENT</div>
                                <div class="breakdown-meta" id="credit-meta">Atome Wallet Link</div>
                            </div>
                        </div>
                        <div id="breakdown-credit" class="breakdown-val breakdown-yellow-text privacy-mask">‚Ç±0.00</div>
                    </div>

                    <!-- Savings -->
                    <div class="breakdown-item" id="item-savings">
                        <div class="breakdown-left" onclick="toggleSavings()" style="display: flex; align-items: center; gap: 10px; flex: 1; cursor: pointer;">
                            <div class="breakdown-icon breakdown-green" id="icon-savings">
                                <i class="material-icons" id="savings-check">savings</i>
                            </div>
                            <div class="breakdown-info">
                                <div class="breakdown-name">SAVINGS</div>
                                <div class="breakdown-meta" id="savings-meta">Monthly Target</div>
                            </div>
                        </div>
                        <div id="breakdown-savings" class="breakdown-val breakdown-green-text privacy-mask" onclick="promptSetSavings()" style="cursor: pointer; padding: 4px 8px; border-radius: 6px; transition: background 0.2s;">‚Ç±3,000.00</div>
                    </div>

                    <!-- Upcoming Salary -->
                    <div class="breakdown-item" id="item-salary">
                        <div class="breakdown-left" onclick="toggleSalary()" style="display: flex; align-items: center; gap: 10px; flex: 1; cursor: pointer;">
                            <div class="breakdown-icon breakdown-green" id="icon-salary">
                                <i class="material-icons" id="salary-check">payments</i>
                            </div>
                            <div class="breakdown-info">
                                <div class="breakdown-name">UPCOMING SALARY</div>
                                <div class="breakdown-meta" id="salary-meta">Included in safe budget</div>
                            </div>
                        </div>
                        <div id="breakdown-salary" class="breakdown-val breakdown-green-text privacy-mask" onclick="promptSetSalary()" style="cursor: pointer; padding: 4px 8px; border-radius: 6px; transition: background 0.2s;">‚Ç±8,800.00</div>
                    </div>

                    <!-- DYNAMIC OBLIGATIONS WILL BE INJECTED HERE -->
                    <div id="dynamic-obligations-container"></div>
                </div>

                <div class="footer-strip" onclick="promptSetCashIn()" style="cursor: pointer;">
                    <div class="footer-item">
                        <div class="footer-label">NEXT EXPECTED SALARY <span id="footer-cash-in-badge" class="footer-badge privacy-mask" style="display: none;">‚Ç±8,800</span></div>
                        <div id="footer-paycheck-date" class="footer-val">Jan 30</div>
                    </div>
                    <div class="footer-item" style="text-align: right;">
                        <div class="footer-label">WAIT TIME</div>
                        <div id="footer-countdown" class="footer-val alt">0 Days</div>
                    </div>
                </div>
            </div>

            <!-- DAILY AVERAGE + TOP CATEGORY INSIGHT ROW -->
            <div class="insight-row">
                <div class="insight-card">
                    <div class="insight-label">Daily Average</div>
                    <div class="insight-value privacy-mask" id="daily-avg-val">‚Ç±0</div>
                    <div class="insight-sub" id="daily-avg-sub">this month</div>
                </div>
                <div class="insight-card">
                    <div class="insight-label">Biggest Expense</div>
                    <div class="insight-value privacy-mask" id="biggest-txn-val">‚Ç±0</div>
                    <div class="insight-sub" id="biggest-txn-sub">‚Äî</div>
                </div>
            </div>

            <!-- MONTHLY SUMMARY (Collapsible) -->
            <div class="monthly-summary-card">
                <div class="monthly-summary-header" onclick="toggleMonthlySummary()">
                    <h3>Monthly Summary</h3>
                    <div class="monthly-summary-toggle" id="summary-toggle">
                        <i class="material-icons" style="font-size: 16px; color: var(--text-muted);">expand_more</i>
                    </div>
                </div>
                <div class="monthly-summary-body" id="summary-body">
                    <div class="summary-grid">
                        <div class="summary-item">
                            <span class="s-label">Total Spent</span>
                            <span class="s-value privacy-mask" id="summary-total">‚Ç±0</span>
                        </div>
                        <div class="summary-item">
                            <span class="s-label">vs Last Month</span>
                            <span class="s-value" id="summary-change">‚Äî</span>
                        </div>
                        <div class="summary-item">
                            <span class="s-label">Top Category</span>
                            <span class="s-value" id="summary-top-cat">‚Äî</span>
                        </div>
                        <div class="summary-item">
                            <span class="s-label">Transactions</span>
                            <span class="s-value" id="summary-txn-count">0</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- OFFLINE QUEUE CARD -->
            <div id="offline-queue-card" class="offline-queue-card">
                <div class="offline-queue-row">
                    <div class="offline-queue-icon">
                        <i class="material-icons" id="offline-queue-icon-i">cloud_off</i>
                    </div>
                    <div class="offline-queue-info">
                        <div class="offline-queue-title" id="offline-queue-title">Waiting for connection</div>
                        <div class="offline-queue-sub" id="offline-queue-sub">Changes saved locally</div>
                    </div>
                    <div class="offline-queue-count" id="offline-queue-count">0</div>
                </div>
                <div id="offline-queue-list" class="offline-queue-list"></div>
                <div class="offline-progress-bar">
                    <div class="offline-progress-fill"></div>
                </div>
            </div>

            <!-- EXPENSES STRUCTURE (WEB3 MODERN) -->
            <div id="chart-section" class="chart-card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                    <h3 class="dash-section-title" style="margin: 0; text-decoration: none;">Expenses structure</h3>
                    <select id="chart-filter" onchange="filterChart()" class="mui-btn mui-btn--flat dash-filter-select">
                        <option value="this_month" selected>This Month</option>
                        <option value="today">Today</option>
                        <option value="this_week">This Week</option>
                        <option value="last_week">Last Week</option>
                        <option value="last_7_days">Last 7 Days</option>
                        <option value="first_15">First 15 of Month</option>
                        <option value="last_15">Last 15 of Month</option>
                        <!-- Dynamic previous 3 months will be inserted here -->
                        <option value="last_6_months">Last 6 Months</option>
                        <option value="this_year">This Year</option>
                        <option value="all_time">All Time</option>
                    </select>
                </div>

                <div style="display: flex; margin-bottom: 20px;">
                    <div style="flex: 1;">
                        <div style="font-size: 11px; color: var(--text-primary); font-weight: 800; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; opacity: 0.9;">Total Expenses</div>
                        <div style="font-size: 22px; font-weight: 800; letter-spacing: -0.5px; color: var(--text-primary);" id="expenses-total-summary" class="dash-total-val">PHP 0.00</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 11px; color: var(--text-primary); font-weight: 800; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; opacity: 0.8;">vs past period</div>
                        <div id="mom-growth-box" style="font-size: 22px; font-weight: 800; letter-spacing: -0.5px; color: var(--text-primary);"><span id="mom-growth"></span></div>
                    </div>
                </div>

                <div class="chart-container" id="chart-anim-container">
                    <svg id="pieChart" width="220" height="220" viewBox="0 0 240 240">
                        <g id="pieContent"></g>
                    </svg>
                    <div class="chart-center">
                        <div class="chart-center-label" id="chart-total-label">TOTAL</div>
                        <div class="chart-center-value" id="chart-total-val">0</div>
                        <div class="chart-center-pct" id="chart-total-pct"></div>
                    </div>
                </div>
                <div id="chart-legend" class="legend">
                    <!-- Dynamic segments will go here -->
                </div>
            </div>

            <!-- TREND SECTION -->
            <div class="trend-card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h3 style="margin: 0; font-size: 1.1rem; font-weight: 800; color: var(--text-primary); text-decoration: none;">Spending Trends</h3>
                    <select id="trend-filter" onchange="refreshTrendChart()" class="mui-btn mui-btn--flat dash-filter-select">
                        <option value="this_month" selected>This Month</option>
                        <option value="this_vs_prev">This vs Prev Month</option>
                        <option value="this_week">This Week</option>
                        <option value="last_3_months">Past 3 Months</option>
                        <option value="last_6_months">Past 6 Months</option>
                    </select>
                </div>
                <div id="trend-month-label" style="text-align: left; font-size: 10px; color: var(--text-secondary); font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">January 2026</div>
                <div style="position: relative; margin-bottom: 24px;">
                    <svg id="trendChart" width="100%" height="140" viewBox="0 0 400 140" preserveAspectRatio="none" style="display: block;">
                        <defs>
                            <linearGradient id="trendGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:var(--nav-active); stop-opacity:0.2" />
                                <stop offset="100%" style="stop-color:var(--nav-active); stop-opacity:0" />
                            </linearGradient>
                            <linearGradient id="trendGradientCompare" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:var(--text-secondary); stop-opacity:0.1" />
                                <stop offset="100%" style="stop-color:var(--text-secondary); stop-opacity:0" />
                            </linearGradient>
                        </defs>
                        <path id="trendAreaCompare" d="" fill="url(#trendGradientCompare)"></path>
                        <path id="trendPathCompare" d="" fill="none" stroke="var(--text-secondary)" stroke-width="2" stroke-dasharray="4,4" opacity="0.5"></path>
                        <path id="trendArea" d="" fill="url(#trendGradient)"></path>
                        <path id="trendPath" class="trend-path" d="" fill="none" stroke="var(--nav-active)" stroke-width="4" stroke-linecap="round"></path>
                        <g id="trendDots"></g>
                        <g id="trendDotsCompare"></g>
                    </svg>
                    <div id="trend-labels" style="display: flex; justify-content: space-between; margin-top: 12px; padding: 0 5px;">
                        <span class="trend-label">Week 1</span>
                        <span class="trend-label">Week 2</span>
                        <span class="trend-label">Week 3</span>
                        <span class="trend-label">Week 4</span>
                    </div>
                </div>
                <!-- Legend for Comparison -->
                <div id="trend-legend" style="display: none; justify-content: center; gap: 20px; margin: 0 0 20px; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;">
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <div style="width: 12px; height: 3px; background: #3b82f6; border-radius: 2px;"></div>
                        <span style="color: var(--text-muted);">Current</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <div style="width: 12px; height: 0; border-top: 2px dashed var(--text-secondary);"></div>
                        <span style="color: var(--text-secondary);">Previous</span>
                    </div>
                </div>

                <div style="border-top: 1px dashed var(--border-color); padding-top: 16px; display: flex; justify-content: space-between; align-items: center;">
                    <span style="font-size: 13px; color: var(--text-primary); font-weight: 600;">Period Total</span>
                    <span style="font-size: 1.1rem; font-weight: 800; color: #10b981;" id="trend-period-total">PHP 0.00</span>
                </div>
            </div>


            <div class="recent-header">
                <h3>Recent Transactions</h3>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div class="logo-toggle-wrapper" title="Toggle Brand Logos" onclick="toggleLogos()" style="background: var(--bg-secondary); padding: 4px 8px; border-radius: 8px; cursor: pointer; display: flex; align-items: center; gap: 4px; border: .5px solid #e0e0e0">
                        <i class="material-icons" id="logo-toggle-icon" style="font-size: 16px; color: var(--nav-active);">visibility</i>
                        
                    </div>
                    <select id="txn-cat-filter" onchange="filterTxnList()" style="font-size: 10px; font-weight: 700; color: var(--text-secondary); background: var(--bg-secondary); padding: 6px 8px; border-radius: 8px; border: 1px solid #e0e0e0; outline: none; cursor: pointer;">
                        <option value="all">All Items</option>
                    </select>
                </div>
            </div>

            <div class="search-container">
                <div class="search-wrapper" style="border: 1px solid #e0e0e0;">
                    <i class="material-icons">search</i>
                    <input type="text" id="txn-search" placeholder="Search merchant, note, or price..." oninput="handleSearchInput()">
                    <i class="material-icons search-clear" id="search-clear-btn" onclick="clearSearch()">cancel</i>
                </div>
            </div>

            <div id="loading-spinner" class="loading-overlay">
                <i class="material-icons spin" style="font-size: 48px; color: #1e293b;">sync</i>
            </div>

            <div id="history-container"></div>

            <div style="margin: 24px 0 16px; height: 1px; background: rgba(0,0,0,0.05); width: 100%;"></div>

            <!-- CATEGORY BUDGET LIMITER WIDGET -->
            <div id="cat-budget-widget" class="cat-budget-card" style="display: none;">
                <div class="cat-budget-header">
                    <h3 class="cat-budget-title">Category Limits</h3>
                    <button class="cat-budget-add-btn" onclick="promptAddCategoryBudget()">
                        <i class="material-icons" style="font-size: 16px;">add</i> ADD
                    </button>
                </div>
                <div id="cat-budget-list">
                    <!-- Dynamic categories will be injected here -->
                </div>
            </div>

            <!-- VISIBLE DIVIDER ABOVE ANALYTICS -->
            <div style="margin: 20px 0px 10px; height: 1px; background: #f1f5f9; width: 100%;"></div>

            <!-- ANALYTICS CARD (MOVED FROM TOP) -->
            <div class="analytics-card" id="analytics-section" style="margin: 20px 16px 10px; padding: 15px; border-radius: 16px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3 class="dash-section-title" style="margin:0; font-size: 0.95rem;">Cash Flow</h3>
                    <div class="savings-chip">Savings Rate: <span id="savings-rate-val">0%</span></div>
                </div>
                <div style="font-size: 11px; color: #94a3b8; font-weight: 600; margin-bottom: 15px;">Income vs Expenses (Last 6 Months)</div>
                <div class="bar-chart-wrap" id="cashflow-bars">
                    <!-- Bars generated via JS -->
                </div>
                <div style="display: flex; gap: 15px; margin-top: 15px; border-top: 1px dashed #f1f5f9; padding-top: 10px;">
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <div style="width: 8px; height: 8px; border-radius: 2px; background: #10b981;"></div>
                        <span style="font-size: 9px; font-weight: 700; color: #64748b; text-transform: uppercase;">Income</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <div style="width: 8px; height: 8px; border-radius: 2px; background: #ef4444;"></div>
                        <span style="font-size: 9px; font-weight: 700; color: #64748b; text-transform: uppercase;">Expense</span>
                    </div>
                </div>
            </div>

            <!-- RECURRING ITEMS SUBSCRIPTION SECTION -->
            <div class="analytics-card" id="subscription-section" style="display: none; margin: 10px 16px 20px; padding: 15px; border-radius: 16px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <h3 class="dash-section-title" style="margin:0; font-size: 0.95rem;">Recurring Items</h3>
                        <span id="sub-count-badge" style="background:#f1f5f9; color:#64748b; font-size:9px; font-weight:800; padding:2px 6px; border-radius:10px;">0</span>
                    </div>
                    <div style="text-align: right;">
                        <div id="sub-limit-label" class="privacy-mask" onclick="promptSetSubLimit()" style="font-size: 9px; color: #94a3b8; font-weight: 700; text-transform: uppercase; cursor: pointer;">Limit: ‚Ç±0</div>
                        <div id="sub-total-label" class="privacy-mask" style="font-size: 11px; font-weight: 800; color: #1e293b;">‚Ç±0.00 / mo</div>
                    </div>
                </div>
                <div class="sub-limit-bar">
                    <div id="sub-limit-fill" class="sub-limit-fill" style="width: 0%;"></div>
                </div>
                <div id="subscription-list" style="margin-top: 5px;">
                    <!-- JS injected -->
                </div>
            </div>
            
            <!-- DATA MANAGEMENT SECTION (PREMIUM DESIGN) -->
            <div class="data-mgmt-card" style="margin: 30px 16px 20px; padding: 12px 16px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.02);">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                    <div class="mgmt-icon-box">
                        <i class="material-icons" style="font-size: 16px;">storage</i>
                    </div>
                    <div style="text-align: left;">
                        <div style="font-size: 11px; font-weight: 800; letter-spacing: -0.2px;" class="cat-budget-title">Account Backup</div>
                        <div style="font-size: 9px; color: #64748b; font-weight: 600;">Secure your data locally</div>
                    </div>
                </div>

                <div style="display: flex; gap: 8px;">
                    <button class="mui-btn mui-btn--flat" style="flex: 1; height: 34px; border-radius: 8px; text-transform: none; font-weight: 800; background: #000; color: #fff; font-size: 11px; display: flex; align-items: center; justify-content: center; gap: 6px; box-shadow: 0 4px 12px rgba(29, 78, 216, 0.15);" onclick="exportData()">
                        <i class="material-icons" style="font-size: 14px;">download</i> Export
                    </button>
                    <button class="mui-btn mui-btn--flat" style="flex: 1; height: 34px; border-radius: 8px; text-transform: none; font-weight: 800; background: #fff; color: #1e293b; border: 1px solid #e2e8f0; font-size: 11px; display: flex; align-items: center; justify-content: center; gap: 6px;" id="import-btn" onclick="document.getElementById('import-file').click()">
                        <i class="material-icons" style="font-size: 14px;">upload</i> Import
                    </button>
                </div>
                <input type="file" id="import-file" accept=".json" style="display: none;" onchange="importData(event)">
            </div>

            <!-- TROUBLESHOOTING SECTION -->
            <div class="data-mgmt-card troubleshoot-card" style="margin: 0 16px 20px; padding: 12px 16px; border: 1px dashed #cbd5e1; border-radius: 12px;">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div style="font-size: 11px; font-weight: 700; color: #64748b;" class="troubleshoot-text">Having sync issues?</div>
                    <button onclick="window.hardRefresh()" class="hard-refresh-btn">
                        <i class="material-icons" style="font-size: 14px;">refresh</i> HARD REFRESH
                    </button>
                </div>
            </div>

            <!-- ADMIN CONTROLS (SECRETS) -->
            <div id="admin-controls" style="display: none; padding: 20px 16px;">
                <div class="status-labels" style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-bottom: 10px;">
                    <div id="gis-status" class="status-chip" style="height: auto; padding: 8px 12px; line-height: 1.4;">GIS:<br>READY</div>
                    <div id="mode-status" class="status-chip status-ready" style="height: auto; padding: 8px 12px; line-height: 1.4; text-align: left;">
                        MODE: CLOUD<br>
                        <span id="admin-email-display" style="font-size: 9px; opacity: 0.8;">(LOADING...)</span>
                    </div>
                </div>
            </div>

            <div id="log-container" style="display: none; margin-bottom: 80px; padding-bottom: 40px;"></div>
            
            <div class="footer-credits" style="text-align: center; padding: 20px 20px 40px; color: #cbd5e1; font-size: 10px; font-weight: 500; letter-spacing: 0.5px; opacity: 0.8;">
                <div onclick="toggleAdminMode()" style="cursor: default; -webkit-tap-highlight-color: transparent;">Developed by John Paul Inso | v1.3.6</div>
            </div>
        </div>

    </div>

    <button class="fab" onclick="openManualTxnModal()">
        <i class="material-icons">add</i>
    </button>

    <!-- BOTTOM NAV -->
    <div class="bottom-nav">
        <a href="#" class="nav-item active" onclick="return false;" oncontextmenu="return false;" draggable="false">
            <i class="material-icons">account_balance_wallet</i>
            <span>Wallet</span>
        </a>
        <a href="javascript:void(0)" class="nav-item" onclick="window.location.href='calendar.html'; return false;" oncontextmenu="return false;" draggable="false">
            <i class="material-icons">calendar_today</i>
            <span>Calendar</span>
        </a>
        <a href="javascript:void(0)" class="nav-item" onclick="window.location.href='accounts.html'; return false;" oncontextmenu="return false;" draggable="false">
            <i class="material-icons">account_balance</i>
            <span>Accounts</span>
        </a>
        <a href="javascript:void(0)" class="nav-item" onclick="window.location.href='goals.html'; return false;" oncontextmenu="return false;" draggable="false">
            <i class="material-icons">track_changes</i>
            <span>Goals</span>
        </a>
    </div>

    <!-- iOS-STYLE BLUR OVERLAY (NOW AT BODY LEVEL) -->
    <div class="blur-overlay" id="blur-overlay" onclick="closeIOSMenu()"></div>
    <div class="ios-action-menu" id="ios-menu"></div>

    <!-- CATEGORY BUDGET MODAL (TOP LEVEL) -->
    <div id="cat-budget-modal" class="modal-overlay" onclick="closeModals()">
        <div class="custom-modal" onclick="event.stopPropagation()" style="max-width: 380px; border-radius: 20px; padding: 24px;">
            <div class="modal-header" style="text-align: left; margin-bottom: 20px;">
                <h3 id="cat-budget-modal-title" style="margin: 0; font-size: 1.1rem; font-weight: 800; color: #1e293b; letter-spacing: -0.5px;">Category Limit</h3>
            </div>
            
            <div class="modal-body">
                <div id="cat-budget-selection-area" style="margin-bottom: 20px;">
                    <div style="font-size: 10px; font-weight: 800; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 12px;">Select Category</div>
                    <div class="cat-grid" id="budget-cat-grid" style="grid-template-columns: repeat(3, 1fr); gap: 8px; max-height: 240px; overflow-y: auto; padding: 2px;">
                        <!-- Categories injected via JS -->
                    </div>
                </div>
                
                <div style="margin-bottom: 10px;">
                    <div style="font-size: 10px; font-weight: 800; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">Budget Amount (PHP)</div>
                    <div style="position: relative;">
                        <span style="position: absolute; left: 16px; top: 12px; font-weight: 800; color: #0f172a; font-size: 16px;">‚Ç±</span>
                        <input type="number" id="budget-cat-amount" placeholder="0.00" step="100" style="width: 100%; border: 2px solid #f1f5f9; border-radius: 12px; padding: 10px 12px 10px 32px; font-size: 18px; font-weight: 800; color: #0f172a; outline: none; transition: border-color 0.2s;">
                    </div>
                </div>
            </div>
            
            <div class="modal-actions" style="margin-top: 24px;">
                <button id="save-cat-budget-btn" class="mui-btn mui-btn--raised" style="width: 100%; background: #1e293b; color: #fff; border-radius: 12px; height: 48px; font-weight: 800; text-transform: none; font-size: 14px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">Save Limit</button>
            </div>
        </div>
    </div>

    <script>
        // Global bridge for GIS callback to avoid module race condition
        window.gisLoaded = function() {
            if (window.initGISModule) window.initGISModule();
            else window.gisReadyPending = true;
        };
    </script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously, GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, addDoc, collection, serverTimestamp, getDocs, onSnapshot, query, orderBy, updateDoc, deleteDoc, deleteField, enableIndexedDbPersistence, writeBatch } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // HELPER: Format date to YYYY-MM-DD based on LOCAL time
        window.formatLocalDate = (date) => {
            const d = new Date(date);
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };

        // FIREBASE CONFIG
        const firebaseConfig = {
            apiKey: "AIzaSyBHDN0xLi98qjYYjUf2RDCn5gJK0dzTk_M",
            authDomain: "atome-wallet.firebaseapp.com",
            projectId: "atome-wallet",
            storageBucket: "atome-wallet.firebasestorage.app",
            messagingSenderId: "64186651619",
            appId: "1:64186651619:web:cd7d426cfb663aab6606d6",
            measurementId: "G-2SHWJ6S3Z3"
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Pre-set persistence to avoid delay in click handler
        setPersistence(auth, browserLocalPersistence).catch(e => console.error("Persistence error", e));

        // GOOGLE AUTH CONSTANTS
        const CLIENT_ID = '64186651619-3eb9ki680f4c8q2g2mese3c8hhfur23b.apps.googleusercontent.com';
        const SCOPES = 'https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/userinfo.profile';
        let tokenClient;
        let accessToken = localStorage.getItem('g_access_token');
        let expiry = localStorage.getItem('g_token_expiry');

        // TOKEN REFRESH LOCK: Prevent multiple simultaneous popup/refresh attempts
        let tokenRefreshInProgress = false;
        let lastTokenRefreshAttempt = 0;
        const TOKEN_REFRESH_COOLDOWN = 30000; // 30 seconds minimum between refresh attempts
        let switchSyncTimer = null; // Debounce timer for account-switch syncs
        let lastObserverLoadTime = 0; // Debounce guard for observer loadData calls
        const OBSERVER_LOAD_DEBOUNCE = 500; // ms between observer-triggered loadData calls

        // --- CORE AUTH HANDLERS (Moved early for reliability) ---
        
        // Identity Services Initialization
        function initGIS() {
            try {
                log('Initializing Google Identity Services...');
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CLIENT_ID,
                    scope: SCOPES,
                    callback: async (resp) => {
                        window.isSyncing = false;
                        tokenRefreshInProgress = false; // Release the lock
                        const wasSilent = window.isSilentRefresh;
                        window.isSilentRefresh = false;
                        if (resp.error) {
                            if (resp.error === 'immediate_failed') {
                                // NEVER escalate to visible popup ‚Äî just fail silently
                                console.log('üîá Silent refresh failed. Will retry on next manual sync or auto-refresh cycle.');
                            } else {
                                log('Google Auth failed: ' + resp.error, 'error');
                            }
                            window.pendingSyncLimit = null;
                            window.pendingSyncManual = false;
                            return;
                        }

                        accessToken = resp.access_token;
                        const ONE_HOUR_MS = 60 * 60 * 1000;
                        const expMs = Date.now() + ONE_HOUR_MS;
                        localStorage.setItem('g_access_token', accessToken);
                        localStorage.setItem('g_token_expiry', expMs.toString());
                        localStorage.setItem('g_token_issued_at', Date.now().toString());
                        
                        // Mark this session as having a valid token ‚Äî prevents re-popup on navigation
                        sessionStorage.setItem('gis_session_refreshed', Date.now().toString());
                        
                        fetchUserProfile(accessToken);
                        log('Google Session Secured (Token Refresh Success)');
                        
                        // PREPARE SYNC LIMITS (Adaptive Sync Logic - Reduced for instant feel)
                        const lastDeep = localStorage.getItem(`last_deep_sync_${window.currentAccount}`);
                        const now = Date.now();
                        const dayInMs = 24 * 60 * 60 * 1000;
                        let syncLimit = 25; // Default Quick Sync
                        
                        if (!lastDeep || (now - parseInt(lastDeep)) > dayInMs) {
                            syncLimit = 50; // Moderate sync on auto-login (reduced from 400)
                            log(`Moderate sync planned for ${window.currentAccount}...`);
                        }

                        // FIX 3: If refresh was triggered by a 401 during handleScan,
                        // DON'T re-trigger handleScan ‚Äî breaks the resync loop
                        if (window.refreshTriggeredBy401) {
                            console.log('üîá Token refreshed after 401. Skipping auto-sync to prevent loop.');
                            window.refreshTriggeredBy401 = false;
                            window.pendingSyncLimit = null;
                            window.pendingSyncManual = false;
                        } else if (window.pendingSyncLimit) {
                            const limit = Math.max(window.pendingSyncLimit, syncLimit);
                            window.pendingSyncLimit = null;
                            window.pendingSyncManual = false;
                            handleScan(limit, true);
                        } else {
                            handleScan(syncLimit);
                        }
                    },
                });
                const gisBadge = document.getElementById('gis-status');
                if (gisBadge) {
                    gisBadge.innerText = 'GIS: Ready';
                    gisBadge.classList.add('status-ready');
                }
            } catch (e) { log('GIS Init Error: ' + e.message, 'error'); }
        }
        window.initGISModule = initGIS;

        async function fetchUserProfile(token) {
            try {
                const res = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await res.json();
                if (data.name) {
                    const firstName = data.given_name || data.name.split(',')[0].split(' ').slice(0, 2).join(' ');
                    document.getElementById('user-display-name').innerText = firstName;
                    
                    const badge = document.getElementById('profile-badge');
                    const picEl = document.getElementById('user-pic');
                    picEl.src = data.picture;
                    badge.classList.add('has-pic');
                    
                    localStorage.setItem('user_name', firstName);
                    localStorage.setItem('user_pic', data.picture);
                    if (data.email) localStorage.setItem('user_email', data.email);
                }
            } catch (e) { log('Profile refresh fail: ' + e.message, 'error'); }
        }

         window.handleAuthClick = async () => {
            log('Starting Google Sign-In Flow...');
            // Zero-latency UI feedback
            const btn = event?.currentTarget || document.activeElement;
            if (btn && btn.classList) btn.style.opacity = '0.5';

            try {
                const provider = new GoogleAuthProvider();
                provider.addScope('https://www.googleapis.com/auth/gmail.readonly');
                
                // Mark that we just logged in ‚Äî suppress automatic GIS popup after login
                window.justLoggedIn = true;
                
                try {
                    const result = await signInWithPopup(auth, provider);
                    log('signInWithPopup success!');
                    handleAuthResult(result);
                } catch (popupError) {
                    if (popupError.code === 'auth/popup-blocked' || popupError.code === 'auth/cancelled-popup-request') {
                        log('Popup blocked. Falling back to redirect...');
                        localStorage.setItem('auth_redirect_pending', 'true');
                        await signInWithRedirect(auth, provider);
                    } else {
                        throw popupError;
                    }
                }
            } catch (e) {
                window.justLoggedIn = false;
                log('Google Sign-In Error: ' + e.message, 'error');
                showToast('Login failed. Please try again.');
            } finally {
                if (btn && btn.classList) btn.style.opacity = '1';
            }
        };

        // Helper to handle authentication result (shared between popup and redirect)
        function handleAuthResult(result) {
            log('Auth success! User: ' + result.user.email);
            localStorage.setItem('wallet_auth_type', 'google'); // Mark as Google user
            
            // IMMEDIATELY hide guest gate on login success
            const gate = document.getElementById('guestGate');
            if (gate) gate.style.display = 'none';
            
            const credential = GoogleAuthProvider.credentialFromResult(result);
            
            // ALWAYS mark session as refreshed on login ‚Äî prevents GIS popup on navigation
            sessionStorage.setItem('gis_session_refreshed', Date.now().toString());
            
            if (credential) {
        accessToken = credential.accessToken;
        const ONE_HOUR_MS = 3600 * 1000;
        localStorage.setItem('g_access_token', accessToken);
        localStorage.setItem('g_token_expiry', (Date.now() + ONE_HOUR_MS).toString());
        localStorage.setItem('g_token_issued_at', Date.now().toString());
    }

            if (result.user.displayName) {
                const parts = result.user.displayName.split(' ');
                const firstName = parts.length > 1 ? parts.slice(0, 2).join(' ') : parts[0];
                document.getElementById('user-display-name').innerText = firstName;
                localStorage.setItem('user_name', firstName);
            }
            
            if (result.user.photoURL) {
                const picEl = document.getElementById('user-pic');
                let photoUrl = result.user.photoURL;
                if (photoUrl.includes('googleusercontent.com') && !photoUrl.includes('s96-c')) {
                    photoUrl = photoUrl.split('=')[0] + '=s96-c';
                }
                picEl.src = photoUrl;
                document.getElementById('profile-badge').classList.add('has-pic');
                localStorage.setItem('user_pic', photoUrl);
            }

            log('Loading user data...');
            loadData();
            
            // Show login modal INSTANTLY with user info from auth result
            setTimeout(() => {
                const userName = result.user.displayName ? result.user.displayName.split(' ')[0] : 'there';
                const userPic = result.user.photoURL;
                const modal = document.getElementById('login-modal');
                const titleEl = modal?.querySelector('.login-modal-title');
                const avatarEl = document.getElementById('login-modal-avatar');
                
                if (titleEl) titleEl.textContent = `Welcome, ${userName}!`;
                if (typeof showLoginModal === 'function') showLoginModal();
            }, 300);
        }

        // HANDLE REDIRECT RESULT (For Mobile)
        getRedirectResult(auth).then((result) => {
            // Always clear the pending flag when result (or lack thereof) settles
            localStorage.removeItem('auth_redirect_pending');
            
            if (result) {
                handleAuthResult(result);
            }
        }).catch((error) => {
            localStorage.removeItem('auth_redirect_pending');
            if (error.code !== 'auth/web-storage-unsupported') {
                log('Redirect Auth Error: ' + error.message, 'error');
            }
        });


        // UNIFIED PROMISE-BASED DIALOG SYSTEM
        window.showAppDialog = ({ title = 'Alert', message = '', input = false, value = '', confirm = false, customActions = null, callback = null }) => {
            return new Promise((resolve) => {
                const overlay = document.getElementById('app-dialog');
                const titleEl = document.getElementById('dialog-title');
                const msgEl = document.getElementById('dialog-msg');
                const inputCont = document.getElementById('dialog-input-container');
                const inputEl = document.getElementById('dialog-input');
                const actionsCont = overlay.querySelector('.dialog-actions');
                const cancelBtn = document.getElementById('dialog-cancel-btn');
                const okBtn = document.getElementById('dialog-ok-btn');
                
                if (customActions) {
                    okBtn.style.display = 'none';
                    cancelBtn.style.display = 'none';
                    overlay.querySelectorAll('.custom-dialog-btn').forEach(b => b.remove());
                    
                    customActions.forEach(action => {
                        const btn = document.createElement('button');
                        btn.className = `dialog-btn custom-dialog-btn ${action.class || 'dialog-btn--primary'}`;
                        btn.innerText = action.label;
                        btn.onclick = () => close(action.value);
                        actionsCont.appendChild(btn);
                    });
                } else {
                    okBtn.style.display = 'block';
                    cancelBtn.style.display = (confirm || input) ? 'block' : 'none';
                    overlay.querySelectorAll('.custom-dialog-btn').forEach(b => b.remove());
                }

                titleEl.innerText = title;
                msgEl.innerText = message;
                
                if (input) {
                    inputCont.style.display = 'block';
                    inputEl.value = value;
                    setTimeout(() => inputEl.focus(), 300);
                } else {
                    inputCont.style.display = 'none';
                }

                okBtn.innerText = (confirm || input) ? 'CONFIRM' : 'OK';

                const close = (res) => {
                    if (window.NavState) window.NavState.popModalState('app-dialog');
                    overlay.classList.remove('show');
                    okBtn.onclick = null;
                    cancelBtn.onclick = null;
                    overlay.onclick = null;
                    overlay.querySelectorAll('.custom-dialog-btn').forEach(b => b.remove());
                    
                    if (callback) callback(res);
                    resolve(res);
                };

                okBtn.onclick = () => close(input ? inputEl.value : true);
                cancelBtn.onclick = () => close(null);
                
                // Close on backdrop click (outside the card)
                overlay.onclick = (e) => {
                    if (e.target === overlay) close(null);
                };

                overlay.classList.add('show');
                if (window.NavState) window.NavState.pushModalState('app-dialog', () => overlay.classList.remove('show'));
            });
        };



        // ENABLE OFFLINE PERSISTENCE (Synchronous - Required for popup auth)
        // Must be called before any auth operations
        enableIndexedDbPersistence(db).catch((err) => {
            if (err.code == 'failed-precondition') {
                log('Persistence failed: Multiple tabs open');
            } else if (err.code == 'unimplemented') {
                log('Persistence not supported');
            }
        });


        // REGISTER SERVICE WORKER
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(() => console.log('Service Worker Registered'))
                .catch(err => console.log('SW Registration Failed', err));
        }

        // GMAIL API LOGIC (Constants moved early)

        if (window.location.search.includes('logout=true')) {
            // Force a deep reset on the first load after logout
            log('üßπ Session purge complete. User isolated.', 'info');
        }

        if (window.location.search.includes('logout=true')) {
            // Force a deep reset on the first load after logout
            log('üßπ Session purge complete. User isolated.', 'info');
        }

        window.addEventListener('DOMContentLoaded', async () => {
            log('-------------------------', 'warn');

            // Load profile data early
            if (window.NavState) {
                window.NavState.loadProfile();
            }

            // POPULATE DYNAMIC PREVIOUS 3 MONTHS IN EXPENSES DROPDOWN
            const chartFilter = document.getElementById('chart-filter');
            if (chartFilter) {
                const now = new Date();
                const last15Option = chartFilter.querySelector('option[value="last_15"]');
                
                // Generate previous 3 months (reverse order so they appear chronologically)
                for (let i = 3; i >= 1; i--) {
                    const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
                    const monthName = date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                    const monthValue = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    
                    const option = document.createElement('option');
                    option.value = monthValue;
                    option.textContent = monthName;
                    
                    // Insert after "Last 15 of Month"
                    last15Option.insertAdjacentElement('afterend', option);
                }
            }

            // FAST PATH: Early rendering from cache to achieve "instant" load
            const lastUid = localStorage.getItem('wallet_last_uid');
            const cachedAccounts = localStorage.getItem('wallet_accounts');
            const cachedCurrent = localStorage.getItem('wallet_current_account');
            const cachedBalances = localStorage.getItem('wallet_cached_balances');
            
            if (lastUid && cachedAccounts && cachedCurrent) {
                console.log('‚ö° Fast Path: Rendering from cache...');
                try {
                    const accounts = JSON.parse(cachedAccounts);
                    
                    // RESTORE CACHED BALANCES: Apply saved balances to accounts
                    if (cachedBalances) {
                        try {
                            const balances = JSON.parse(cachedBalances);
                            accounts.forEach(acc => {
                                if (balances[acc.id] !== undefined) {
                                    acc.balance = balances[acc.id];
                                }
                            });
                            console.log('üí∞ Restored cached balances:', balances);
                        } catch(e) { console.warn('Balance cache error', e); }
                    }
                    
                    window.walletAccounts = accounts;
                    window.currentAccount = cachedCurrent;
                    
                    // Sync UI from cache
                    updateAccountSwitcherUI(accounts);
                    updateBalanceCardsUI(accounts);
                    applyAccountTheme(cachedCurrent, accounts);
                    
                    // Trigger data load using stored UID
                    // (loadData will use localStorage cache first internally)
                    window.fastPathTriggered = true;
                    loadData(lastUid); 
                } catch(e) { console.warn('Fast path failed', e); }
            }

            // FETCH ACCOUNTS & SYNC THEME (Master Observer)
            let authWaitStarted = false;
            onAuthStateChanged(auth, async (user) => {
                const isRedirectPending = localStorage.getItem('auth_redirect_pending') === 'true';
                const lastAuthType = localStorage.getItem('wallet_auth_type');

                if (!user) {
                    if (isRedirectPending) {
                        log('Redirect pending detected. Holding anonymous fallback...');
                        return; // Wait for getRedirectResult to finish
                    }

                    // PERSISTENCE FIX: If we previously had a google session, wait before falling back to guest
                    if (lastAuthType === 'google' && !authWaitStarted) {
                        authWaitStarted = true;
                        log('Waiting for persistent Google session...');
                        // Give it 12 seconds to restore (increased from 10s for maximum stickiness)
                        setTimeout(() => {
                            if (!auth.currentUser) {
                                log('Google session not found after timeout. Using local fallback.');
                                signInAnonymously(auth).catch(e => log('Local session error: ' + e.message, 'error'));
                            }
                        }, 12000);
                        return;
                    }

                    log('Establishing secure local session...');
                    signInAnonymously(auth).catch(e => log('Local session error: ' + e.message, 'error'));
                    // Show guest gate after 2s delay ‚Äî gives Firebase time to restore session
                    setTimeout(() => {
                        if ((!auth.currentUser || auth.currentUser.isAnonymous) && !window.justLoggedIn) {
                            const gate = document.getElementById('guestGate');
                            if (gate) gate.style.display = 'flex';
                        }
                    }, 2000);
                    return;
                }

                // If logged in as Google, update flag and IMMEDIATELY hide gate
                if (!user.isAnonymous) {
                    localStorage.setItem('wallet_auth_type', 'google');
                    const gate = document.getElementById('guestGate');
                    if (gate) gate.style.display = 'none';
                }

                // Save UID for future instant loads
                localStorage.setItem('wallet_last_uid', user.uid);

                // UI Mode Status
                const dbBadge = document.getElementById('mode-status');
                const emailDisplay = document.getElementById('admin-email-display');
                if (dbBadge) {
                   dbBadge.className = 'status-chip ' + (user.isAnonymous ? 'status-local' : 'status-ready');
                   if (emailDisplay) emailDisplay.innerText = user.isAnonymous ? '(UNSYNCED)' : `(${user.email.toUpperCase()})`;
                }
                
                log('Auth Detected: ' + (user.isAnonymous ? 'Guest' : user.email) + ' [UID: ' + user.uid + ']');

                // Login modal is now triggered from handleAuthResult, not here

                // Update UI with full first name
                const fullName = user.displayName || (user.isAnonymous ? 'Guest' : 'User');
                const parts = fullName.trim().split(/\s+/);
                const displayName = parts.length >= 2 ? `${parts[0]} ${parts[1]}` : parts[0];
                const picUrl = user.photoURL || '';
                
                const nameEl = document.getElementById('user-display-name');
                if (nameEl) nameEl.textContent = displayName;
                
                const badge = document.getElementById('profile-badge');
                const picEl = document.getElementById('user-pic');
                if (picEl && picUrl) {
                    picEl.src = picUrl;
                    picEl.style.display = 'block';
                    if (badge) badge.classList.add('has-pic');
                }

                // Save to NavState for other pages
                if (window.NavState && !user.isAnonymous) {
                    window.NavState.saveProfile(fullName, picUrl, user.email);
                }

                // DYNAMIC ACCOUNT HUB
                if (!user.isAnonymous) {
                    // Safe to Spend Config Listener
                    const safeSpendRef = doc(db, "users", user.uid, "config", "safe_to_spend");
                    onSnapshot(safeSpendRef, (docSnap) => {
                        let data = docSnap.exists() ? docSnap.data() : {
                            savingsAmount: 3000,
                            obligations: []
                        };
                        
                        // Migration path for older single-obligation data
                        if (data.obligationsAmount !== undefined && !data.obligations) {
                            data.obligations = [{ 
                                id: Date.now().toString(),
                                title: data.obligationsTitle || 'Upcoming Bills',
                                amount: data.obligationsAmount 
                            }];
                        } else if (!data.obligations) {
                            data.obligations = [];
                        }
                        
                        window.safeToSpendConfig = data;
                        updateSafeSpendUI();
                    });

                    const configRef = doc(db, "users", user.uid, "config", "accounts");
                    onSnapshot(configRef, (docSnap) => {
                        const accounts = docSnap.exists() ? (docSnap.data().list || []) : [];
                        const isAdmin = user.email === 'johnpaulinso123@gmail.com';
                        
                        // Scenario Check: Admin must have all 3 specific cards
                        const hasAtome = accounts.find(a => a.id === 'atome');
                        const hasBPI = accounts.find(a => a.id === 'bpi');
                        const hasWallet = accounts.find(a => a.id === 'default_wallet');
                        
                        if (accounts.length === 0 || (isAdmin && (!hasAtome || !hasBPI || !hasWallet))) {
                            // INITIALIZE DEFAULT WALLETS
                            let list = [];
                            if (isAdmin) {
                                log('Provisioning Admin Scenario (Atome + BPI + Wallet)...');
                                list = [
                                    { id: 'atome', name: 'Atome Card', balance: 0, last4: '7312', color: '#121212', type: 'credit', isDefault: true, isBuiltIn: true, createdAt: 1700000000000 },
                                    { id: 'bpi', name: 'BPI Card', balance: 0, last4: '6727', color: '#931B1B', type: 'debit', isDefault: false, isBuiltIn: true, createdAt: 1700000000100 },
                                    { id: 'default_wallet', name: 'My Wallet', balance: 0, last4: '0000', color: '#121212', type: 'wallet', isDefault: false, isBuiltIn: true, createdAt: 1700000000200 }
                                ];
                            } else {
                                list = [
                                    { id: 'default_wallet', name: 'My Wallet', balance: 0, last4: '0000', color: '#121212', type: 'wallet', isDefault: true, isBuiltIn: true, createdAt: Date.now() }
                                ];
                            }
                            setDoc(configRef, { list });
                            return;
                        }

                        window.walletAccounts = accounts;
                        // Use the manual order from Firestore
                        updateAccountSwitcherUI(accounts);
                        updateBalanceCardsUI(accounts);
                        
                        // Default logic - ensure persistence
                        let current = localStorage.getItem('wallet_current_account');
                        const def = accounts.find(a => a.isDefault);
                        if (!current || !accounts.find(a => a.id === current)) {
                            current = def ? def.id : accounts[0].id;
                        }
                        
                        // CRITICAL: Set both window and localStorage BEFORE any other operations
                        window.currentAccount = current;
                        localStorage.setItem('wallet_current_account', current);
                        
                        applyAccountTheme(window.currentAccount, accounts);
                        
                        // Only load data if Fast Path didn't already trigger for this UID
                        if (!window.fastPathTriggered || window.currentAccount !== localStorage.getItem('wallet_current_account')) {
                            loadData(); 
                        }
                        window.fastPathTriggered = false; // Reset for future changes
                        
                        // AUTO-LOGIN GMAIL: Check token validity for admin users
                        if (isAdmin) {
                            const gmailToken = localStorage.getItem('g_access_token');
                            const gmailExpiry = localStorage.getItem('g_token_expiry');
                            
                            if (!gmailToken || !gmailExpiry || Date.now() >= parseInt(gmailExpiry)) {
                                console.log('‚ö†Ô∏è Gmail token missing or expired. Please use the sync button to authenticate.');
                            } else {
                                const daysUntilExpiry = Math.floor((parseInt(gmailExpiry) - Date.now()) / (1000 * 60 * 60 * 24));
                                console.log(`‚úÖ Gmail token valid for ${daysUntilExpiry} more days`);
                            }

                            // AUTO-REFRESH GMAIL TOKEN: Proactively refresh every 45 minutes
                            // Google OAuth access tokens expire in ~60 min; this prevents expiry
                            if (gmailToken && tokenClient) {
                                if (window.gmailRefreshInterval) clearInterval(window.gmailRefreshInterval);
                                window.gmailRefreshInterval = setInterval(() => {
                                    const now = Date.now();
                                    if (tokenRefreshInProgress || (now - lastTokenRefreshAttempt) < TOKEN_REFRESH_COOLDOWN) {
                                        console.log('üîá 45-min refresh skipped: lock active or cooldown.');
                                        return;
                                    }
                                    console.log('üîÑ Proactive Gmail token refresh (45-min timer)...');
                                    try {
                                        tokenRefreshInProgress = true;
                                        lastTokenRefreshAttempt = now;
                                        window.isSilentRefresh = true;
                                        tokenClient.requestAccessToken({ prompt: 'none' });
                                    } catch (e) {
                                        tokenRefreshInProgress = false;
                                        console.warn('Proactive refresh failed:', e.message);
                                    }
                                }, 20 * 60 * 1000); // 20 minutes
                                console.log('‚è±Ô∏è Gmail auto-refresh timer started (every 20 min)');
                            }
                        }
                        
                        // WAKE-UP TOKEN REFRESH: When user returns to app after sleeping/inactivity
                        // The 45-min timer doesn't run while the tab is inactive, so this catches
                        // the case where the user opens the app after 8+ hours
                        document.addEventListener('visibilitychange', () => {
                            if (document.visibilityState !== 'visible') return;
                            if (!tokenClient) return;
                            
                            const lastIssued = localStorage.getItem('g_token_issued_at');
                            const now = Date.now();
                            const tokenAge = lastIssued ? (now - parseInt(lastIssued)) : Infinity;
                            
                            // Only refresh if token is older than 50 minutes
                            if (tokenAge > 50 * 60 * 1000) {
                                if (!tokenRefreshInProgress && (now - lastTokenRefreshAttempt) >= TOKEN_REFRESH_COOLDOWN) {
                                    console.log('‚òÄÔ∏è App woke up ‚Äî token stale. Silent refresh...');
                                    tokenRefreshInProgress = true;
                                    lastTokenRefreshAttempt = now;
                                    window.isSilentRefresh = true;
                                    tokenClient.requestAccessToken({ prompt: 'none' });
                                }
                            }
                        });

                        // Adaptive Sync Trigger
                        triggerAdaptiveSync();
                        
                        // Ensure active card is visible with initial loading guard
                        window.isInitialLoading = true;
                        setTimeout(() => {
                            scrollToActiveCard(window.currentAccount);
                            setTimeout(() => { window.isInitialLoading = false; }, 800);
                        }, 500);

                        // START BACKGROUND ATOME WATCHER (Keep Safe To Spend accurate)
                        if (isAdmin) {
                            window.watchAtomeBalance();
                        }
                    });
                } else {
                    window.currentAccount = 'default_wallet';
                    loadData();
                }

                // Update Profile UI
                updateProfileUI(user);
                
                // Local Mode Nudge
                handleLocalModeNudge(user);
                
                applyUserView(user);

                // SILENT TOKEN REFRESH ON LOAD (If Google user)
                // Skip if we just logged in ‚Äî handleAuthResult already saved the token
                // Skip if we already refreshed this session (prevents popup on page navigation)
                const sessionRefreshed = sessionStorage.getItem('gis_session_refreshed');
                const hasValidSessionToken = sessionRefreshed && localStorage.getItem('g_access_token');
                
                if (!user.isAnonymous && tokenClient && !window.justLoggedIn && !hasValidSessionToken) {
                    const lastIssued = localStorage.getItem('g_token_issued_at');
                    const now = Date.now();
                    const filterAge = 50 * 60 * 1000; // 50 minutes
                    
                    if (!lastIssued || (now - parseInt(lastIssued)) > filterAge) {
                        // Respect the global refresh lock
                        if (!tokenRefreshInProgress && (now - lastTokenRefreshAttempt) >= TOKEN_REFRESH_COOLDOWN) {
                            log('üîÑ Session identified: Attempting silent token refresh...');
                            tokenRefreshInProgress = true;
                            lastTokenRefreshAttempt = now;
                            window.isSilentRefresh = true;
                            tokenClient.requestAccessToken({ prompt: 'none' });
                        } else {
                            console.log('üîá Token refresh on cooldown. Skipping load-time refresh.');
                        }
                    }
                } else if (hasValidSessionToken) {
                    console.log('‚úÖ Token already refreshed this session. Skipping GIS popup.');
                }
                // Clear the flag after auth processing ‚Äî with delay to cover multiple onAuthStateChanged fires
                setTimeout(() => { window.justLoggedIn = false; }, 5000);
            });
        });

        function updateProfileUI(user) {
            const dropdown = document.getElementById('profile-dropdown');
            if (user.isAnonymous) {
                dropdown.innerHTML = `
                    <div class="dropdown-header">Guest Session</div>
                    <div class="dropdown-item" onclick="toggleDarkMode()">
                        <i class="material-icons" id="theme-icon">dark_mode</i>
                        <span id="theme-text">Dark Mode</span>
                    </div>
                    <div class="dropdown-item" onclick="handleAuthClick()">
                        <i class="material-icons">cloud_upload</i>
                        <span>Sign in with Google</span>
                    </div>
                `;
                document.getElementById('user-display-name').innerText = 'Guest';
                document.getElementById('profile-badge').classList.remove('has-pic');
            } else {
                dropdown.innerHTML = `
                    <div class="dropdown-header">${user.email}</div>
                    <div class="dropdown-item" onclick="toggleDarkMode()">
                        <i class="material-icons" id="theme-icon">dark_mode</i>
                        <span id="theme-text">Dark Mode</span>
                    </div>
                    <div class="dropdown-item" onclick="handleAuthClick()">
                        <i class="material-icons">swap_horiz</i>
                        <span>Switch Account</span>
                    </div>
                    <div class="dropdown-item" id="biometric-menu-item" onclick="toggleBiometricSetting()">
                        <i class="material-icons">fingerprint</i>
                        <span>Biometric Login</span>
                        <div class="biometric-status-dot" id="biometric-status-dot"></div>
                    </div>
                    <div class="dropdown-item" onclick="promptSetPin()">
                        <i class="material-icons">lock</i>
                        <span>Privacy PIN</span>
                    </div>
                    <div class="dropdown-item logout" onclick="handleSignout()">
                        <i class="material-icons">logout</i>
                        <span>Log Out</span>
                    </div>
                `;
                 
                 // Initial status update
                 setTimeout(() => { if (typeof window.updateBiometricStatus === 'function') window.updateBiometricStatus(); }, 10);
                 
                 const parts = user.displayName?.split(' ') || [];
                 const firstName = parts.length > 1 ? parts.slice(0, 2).join(' ') : (parts[0] || 'User');
                 document.getElementById('user-display-name').innerText = firstName;
                 localStorage.setItem('user_name', firstName);
                 
                 if (user.photoURL) {
                     const picEl = document.getElementById('user-pic');
                     let photoUrl = user.photoURL;
                     if (photoUrl.includes('googleusercontent.com') && !photoUrl.includes('s96-c')) {
                         photoUrl = photoUrl.split('=')[0] + '=s96-c';
                     }
                     picEl.src = photoUrl;
                     document.getElementById('profile-badge').classList.add('has-pic');
                     localStorage.setItem('user_pic', photoUrl);
                 }
            }
        }

        function handleLocalModeNudge(user) {
            if (user.isAnonymous) {
                 const profileBadge = document.getElementById('profile-badge');
                 profileBadge.style.border = '2px solid #f59e0b';
                 profileBadge.classList.add('local-nudge');
                 
                 let banner = document.getElementById('local-banner');
                 if (!banner) {
                     banner = document.createElement('div');
                     banner.id = 'local-banner';
                     banner.innerHTML = `
                        <div style="display:flex; align-items:center; gap:10px;">
                            <i class="material-icons" style="color:#f59e0b; font-size:20px;">cloud_off</i>
                            <span style="font-size:12px; font-weight:800; color:#1e293b; letter-spacing:0.2px;">SYNC YOUR DATA</span>
                        </div>
                        <button onclick="handleAuthClick()" class="banner-pill-btn">SIGN IN</button>
                     `;
                     banner.className = 'sticky-banner';
                     const viewport = document.getElementById('cardViewport');
                     if (viewport) viewport.after(banner);
                     else document.body.prepend(banner);
                 }
                 banner.style.display = 'flex';
            } else {
                 document.getElementById('profile-badge').style.border = 'none';
                 document.getElementById('profile-badge').classList.remove('local-nudge');
                 const banner = document.getElementById('local-banner');
                 if (banner) banner.style.display = 'none';
            }
        }

        function triggerAdaptiveSync() {
            const isAdmin = auth.currentUser && auth.currentUser.email === 'johnpaulinso123@gmail.com';
            if (!isAdmin || window.isSyncing) return;
            
            // Don't auto-sync right after login ‚Äî let the session settle first
            if (window.justLoggedIn) {
                console.log('‚è≠Ô∏è Skipping auto-sync: just logged in.');
                return;
            }

            const id = window.currentAccount;
            if (id !== 'atome' && id !== 'bpi') return;

            const token = localStorage.getItem('g_access_token');

            if (token) {
                console.log(`üîÑ Auto-syncing ${id} on load (10 emails)...`);
                setTimeout(() => handleScan(10, false), 1500);
            } else {
                console.log(`‚è≠Ô∏è No Gmail token found for ${id}. Use manual Sync to authenticate.`);
            }
        }

        function updateAccountSwitcherUI(accounts) {
            const switcher = document.getElementById('account-switcher');
            if (!switcher) return;
            
            switcher.innerHTML = accounts.map(acc => `
                <div class="sw-slide" data-id="${acc.id}" onclick="switchAccount('${acc.id}')">
                    <div class="sw-card" style="background: ${acc.color};">
                        <div class="sw-card-label">${acc.type.toUpperCase()}</div>
                        <div class="sw-card-name">${acc.name}</div>
                    </div>
                </div>
            `).join('');
        }

        function updateBalanceCardsUI(accounts) {
            const container = document.getElementById('dynamic-balance-cards');
            if (!container) return;

            const isHidden = localStorage.getItem('balance_hidden') === 'true';

            container.innerHTML = accounts.map(acc => {
                const isAtome = acc.id === 'atome';
                const isBPI = acc.id === 'bpi';
                const cardClass = `balance-card ${acc.id === window.currentAccount ? 'active' : ''} ${isAtome ? 'atome-card' : ''} ${isBPI ? 'bpi-card' : ''}`;
                
                return `
                <div class="${cardClass}" id="${acc.id}Card" data-account="${acc.id}" style="${!isBPI ? 'background: ' + acc.color + ';' : ''}">
                    ${isAtome ? '<div class="card-brand-logo atome-brand-logo">A</div>' : ''}
                    ${isBPI ? '<div class="bpi-rays"></div>' : ''}
                    
                    <div class="card-header-row">
                        <div style="display: flex; align-items: baseline; gap: 6px;">
                            <div class="card-label" style="text-transform: uppercase;">${acc.name}</div>
                            ${isBPI ? '<div class="card-type-label" style="text-transform: lowercase; opacity: 0.5;">debit</div>' : ''}
                        </div>
                        ${acc.id !== 'default_wallet' ? `
                        <div class="card-sync-status-chip">
                            <div class="dot syncDot"></div>
                            <span class="status-text syncStatusText">Ready</span>
                        </div>
                        ` : ''}
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 8px;">
                         <div class="balance-amount privacy-mask" data-raw="PHP ${acc.balance.toLocaleString(undefined, {minimumFractionDigits:2})}">${isHidden ? '******' : 'PHP ' + acc.balance.toLocaleString(undefined, {minimumFractionDigits:2})}</div>
                         <button onclick="toggleBalanceVisibility(event)" class="visibility-btn" style="background:none; border:none; color:rgba(255,255,255,0.5); cursor:pointer; padding:4px; display:flex; align-items:center;">
                            <i class="material-icons" style="font-size:16px;">visibility</i>
                         </button>
                    </div>

                    ${isBPI ? `<div id="bpi-remaining-insight" class="privacy-mask" style="font-size: 11px; color: rgba(255,255,255,0.5); margin-top: -8px; margin-bottom: 20px; font-weight: 700; opacity: 1; transition: opacity 0.3s; position: relative; z-index: 2; letter-spacing: 0.3px;">${isHidden ? '******' : 'PHP 0.00 (0.00)'}</div>` : ''}
                    
                    <div class="card-footer">
                        <div class="card-number-box">
                            <div class="card-number-label" style="text-transform: uppercase;">Account Number</div>
                            <div class="card-number" style="letter-spacing: ${isBPI ? '4px' : '2px'}; font-size: ${isBPI ? '14.5px' : '13.5px'};">${isBPI ? '0099 096727' : '‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ ' + acc.last4}</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            ${(isAtome || isBPI) ? `
                            <button class="sync-icon-btn scan-btn" onclick="handleScan(100, true)" title="Sync Account">
                                <i class="material-icons">sync</i>
                            </button>
                            ` : ''}
                            ${acc.id !== 'default_wallet' ? `
                            <div class="mastercard-circles">
                                <div class="circle circle-1" style="${!isBPI && acc.color !== '#121212' ? 'background: #fff; opacity:0.8;' : ''}"></div>
                                <div class="circle circle-2" style="${!isBPI && acc.color !== '#121212' ? 'background: #fff; opacity:0.4;' : ''}"></div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
                `;
            }).join('');
            
            setupAccountSwitcher(); // Re-bind observer to new cards
        }

        function scrollToActiveCard(accId) {
            const card = document.querySelector(`.balance-card[data-account="${accId}"]`);
            if (card) {
                // Proactively set active class to prevent "graying out" before observer settles
                document.querySelectorAll('.balance-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                
                card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            }
        }

        function applyAccountTheme(accId, accounts) {
            const acc = accounts.find(a => a.id === accId);
            if (!acc) return;
            
            // Sync overall UI theme (FAB, Nav, Charts)
            applyTheme(accId);

            const cardBg = document.getElementById('card-bg');
            if (cardBg) cardBg.setAttribute('fill', acc.color);
            
            // Update balance display label if exists
            const label = document.getElementById('wallet-label');
            if (label) label.innerText = acc.name.toUpperCase();
        }

        window.switchAccount = (id) => {
            localStorage.setItem('wallet_current_account', id);
            window.currentAccount = id;
            if (window.walletAccounts) applyAccountTheme(id, window.walletAccounts);
            
            // Toggle Safe to Spend Widget Visibility
            const safeSpendWidget = document.getElementById('safe-spend-widget');
            if (safeSpendWidget) {
                const isAdmin = auth.currentUser && auth.currentUser.email === 'johnpaulinso123@gmail.com';
                // USER REQUEST: Only visible for BPI wallet
                safeSpendWidget.style.display = (id === 'bpi' && isAdmin) ? 'block' : 'none';
                if (id === 'bpi' && isAdmin) updateSafeSpendUI();
            }

            // FIX 2: AUTO-SYNC only if token is still fresh (prevents 401 cascade)
            if (id === 'atome' || id === 'bpi') {
                const token = localStorage.getItem('g_access_token');
                const tokenIssuedAt = parseInt(localStorage.getItem('g_token_issued_at') || '0');
                const tokenAge = Date.now() - tokenIssuedAt;
                const TOKEN_MAX_AGE = 50 * 60 * 1000; // 50 minutes
                if (token && tokenAge < TOKEN_MAX_AGE) {
                    // Debounce: Cancel any pending sync and schedule a new one
                    if (switchSyncTimer) clearTimeout(switchSyncTimer);
                    switchSyncTimer = setTimeout(() => {
                        log(`üîÑ Auto-sync check for ${id} wallet on switch...`);
                        handleScan(5, false);
                    }, 800);
                } else {
                    console.log(`‚è≠Ô∏è Token expired/missing for ${id}. Skipping auto-sync on switch.`);
                }
            }

            loadData();
        };

        function applyUserView(user) {
            const isRedirectPending = localStorage.getItem('auth_redirect_pending') === 'true';
            const isGoogleUser = user && !user.isAnonymous;
            const isAdmin = user && user.email === 'johnpaulinso123@gmail.com';
            const lastAuthType = localStorage.getItem('wallet_auth_type');
                        // SHOW/HIDE GATE
             const gate = document.getElementById('guestGate');
             if (gate) {
                 const isGoogleUser = user && !user.isAnonymous;
                 // Never re-show gate during an active login flow
                 if (window.justLoggedIn) {
                     gate.style.display = 'none';
                 } else {
                     gate.style.display = isGoogleUser ? 'none' : 'flex';
                 }
             }

            const scrollContainer = document.getElementById('cardCarouselScroll');
            const placeholder = document.querySelector('.add-card-placeholder');

            if (!isAdmin) {
                if (placeholder) placeholder.style.display = 'flex';
                
                if (scrollContainer) {
                    scrollContainer.style.overflowX = 'auto';
                    scrollContainer.style.scrollSnapType = 'x mandatory';
                    scrollContainer.style.padding = '30px 35px 25px 35px';
                    scrollContainer.style.justifyContent = 'flex-start';
                }
                
                // FORCE THEME TO DARK
                applyTheme('atome');
                updateHeaderIcon('atome');
            } else {
                if (placeholder) placeholder.style.display = 'flex';
                if (scrollContainer) {
                    scrollContainer.style.overflowX = 'auto';
                    scrollContainer.style.scrollSnapType = 'x mandatory';
                    scrollContainer.style.padding = '30px 35px 25px 35px';
                    scrollContainer.style.justifyContent = 'flex-start';
                }
            }
        }

        // ACCOUNT MANAGEMENT & SWIPE LOGIC
        window.currentAccount = localStorage.getItem('wallet_current_account') || 'atome';

        window.getCollectionName = (accId) => {
            if (accId === 'atome') return "transactions";
            if (accId === 'bpi') return "bpi_transactions";
            return `txns_${accId}`;
        };
        
        // APPLY THEME ON LOAD
        window.addEventListener('DOMContentLoaded', () => {
            initPrivacyLock(); // Feature 5: Security first
            setTimeout(() => {
                const isAdmin = auth.currentUser && auth.currentUser.email === 'johnpaulinso123@gmail.com';
                if (!isAdmin) window.currentAccount = 'atome';
                applyTheme(window.currentAccount);
                updateHeaderIcon(window.currentAccount);
            }, 200);
        });

        // DYNAMIC THEME APPLICATOR
        window.applyTheme = (accountOrColor) => {
            let primaryColor = '#121212'; // Default to a dark theme
            
            // Check if it's an account ID or a hex color
            if (accountOrColor.startsWith('#')) {
                primaryColor = accountOrColor;
            } else {
                const acc = window.walletAccounts?.find(a => a.id === accountOrColor);
                if (acc) primaryColor = acc.color;
            }

            const theme = {
                primary: primaryColor,
                nav: primaryColor,
                trend: primaryColor,
                light: primaryColor + 'cc' // add some transparency
            };
            
            window.currentThemeTrend = theme.trend; 
            
            // 1. Update FAB
            const fab = document.querySelector('.fab');
            if(fab) {
                fab.style.backgroundColor = theme.primary;
                fab.style.transition = 'background-color 0.4s ease'; 
            }
            
            // 2. Update Active Nav Item
            const activeNav = document.querySelector('.nav-item.active');
            if(activeNav) {
                activeNav.style.color = theme.nav;
                activeNav.style.transition = 'color 0.4s ease';
            }

            // 3. Update Trend Chart Line & Text
            const trendPath = document.getElementById('trendPath');
            if(trendPath) {
                trendPath.setAttribute('stroke', theme.trend);
                trendPath.style.transition = 'stroke 0.5s ease';
            }
            
            const trendTotal = document.getElementById('trend-period-total');
            if(trendTotal) {
                trendTotal.style.color = theme.trend;
                trendTotal.style.transition = 'color 0.4s ease';
            }

            // 4. Update SVG Gradient
            const stop1 = document.querySelector('#trendGradient stop[offset="0%"]');
            const stop2 = document.querySelector('#trendGradient stop[offset="100%"]');
            if(stop1) {
                stop1.style.stopColor = theme.trend;
                stop1.setAttribute('stop-color', theme.trend);
                stop1.style.transition = 'stop-color 0.5s ease';
            }
            if(stop2) {
                stop2.style.stopColor = theme.trend;
                stop2.setAttribute('stop-color', theme.trend);
                stop2.style.transition = 'stop-color 0.5s ease';
            }
            
            // 5. Update Logo Toggle Icon (if active)
            const logoIcon = document.getElementById('logo-toggle-icon');
            if(logoIcon && logoIcon.innerText === 'visibility') {
                 logoIcon.style.color = theme.trend;
                 logoIcon.style.transition = 'color 0.4s ease';
            }

            // 6. Update Chart Summary Heading (Optional dramatic effect)
            const summaryAmount = document.getElementById('expenses-total-summary');
            // if(summaryAmount) summaryAmount.style.color = theme.trend;
        };

        // DYNAMIC CARDS LOADER
        function loadSavedCardsToIndex() {
            // Deprecated - handled by updateBalanceCardsUI
        }

        function setupAccountSwitcher() {
            // Removed loadSavedCardsToIndex call as it's now dynamic
            const viewport = document.getElementById('cardCarouselScroll');
            const cards = document.querySelectorAll('.balance-card');
            if (!viewport || cards.length === 0) return;

            // DRAG & SWIPE LOGIC (Both Touch + PC Mouse)
            let isDown = false;
            let startX;
            let scrollLeft;
            let hasDragged = false;

            // MOUSE EVENTS (PC Swipe)
            viewport.addEventListener('mousedown', (e) => {
                isDown = true;
                viewport.style.cursor = 'grabbing';
                viewport.style.scrollSnapType = 'none'; // Disable snapping while dragging
                startX = e.pageX - viewport.offsetLeft;
                scrollLeft = viewport.scrollLeft;
                hasDragged = false;
            });

            viewport.addEventListener('mouseleave', () => {
                if (!isDown) return;
                isDown = false;
                viewport.style.cursor = 'grab';
                viewport.style.scrollSnapType = 'x mandatory';
            });

            viewport.addEventListener('mouseup', () => {
                if (!isDown) return;
                isDown = false;
                viewport.style.cursor = 'grab';
                viewport.style.scrollSnapType = 'x mandatory';
            });

            viewport.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                e.preventDefault();
                const x = e.pageX - viewport.offsetLeft;
                const walk = (x - startX) * 1.5; // Drag speed
                if (Math.abs(walk) > 5) hasDragged = true;
                viewport.scrollLeft = scrollLeft - walk;
            });

            // TOUCH EVENTS
            viewport.addEventListener('touchstart', (e) => {
                startX = e.touches[0].pageX - viewport.offsetLeft;
                scrollLeft = viewport.scrollLeft;
                isDown = true;
                hasDragged = false;
            }, { passive: true });

            viewport.addEventListener('touchend', () => {
                isDown = false;
            }, { passive: true });

            // SWIPE OBSERVER
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    // Only trigger if truly intersecting
                    if (entry.isIntersecting) {
                        const account = entry.target.dataset.account;
                        
                        // Update UI Scale/Shadow - ALWAYS DO THIS
                        cards.forEach(c => c.classList.remove('active'));
                        entry.target.classList.add('active');

                        if (window.isInitialLoading) return;

                        if (window.currentAccount !== account) {
                            window.currentAccount = account;
                            localStorage.setItem('wallet_current_account', account);
                            
                            // Apply Dynamic Theme
                            if (typeof applyTheme === 'function') applyTheme(account);

                            // Reset Pagination
                            window.historyLimit = 6;
                            
                            // FIX 1: INSTANT CACHE LOAD ‚Äî show cached balance/transactions immediately
                            // instead of zeroing everything (which causes the 0-flash)
                            const swipeCacheKey = `wallet_cache_${auth.currentUser?.uid}_${account}`;
                            const swipeCachedData = localStorage.getItem(swipeCacheKey);
                            let usedCache = false;
                            if (swipeCachedData) {
                                try {
                                    const cache = JSON.parse(swipeCachedData);
                                    if (cache.txns && (Date.now() - cache.timestamp < 86400000)) {
                                        window.allTxns = cache.txns;
                                        renderHistory(cache.txns);
                                        updateBalanceToThisMonth(cache.txns, account);
                                        usedCache = true;
                                    }
                                } catch(e) { /* fall through */ }
                            }
                            if (!usedCache) {
                                window.allTxns = [];
                                renderHistory([]);
                            }
                            
                            // Clear charts (will be re-drawn by loadData)
                            const pieSvg = document.getElementById('pie-chart-svg');
                            const trendSvg = document.getElementById('trend-chart-svg');
                            if (pieSvg) pieSvg.innerHTML = '';
                            if (trendSvg) trendSvg.innerHTML = '';
                            const chartTotalLabel = document.getElementById('chart-total-label');
                            const chartTotalVal = document.getElementById('chart-total-val');
                            if (chartTotalLabel) chartTotalLabel.innerText = 'TOTAL';
                            if (chartTotalVal) chartTotalVal.innerText = '‚Ç±0.00';
                            const legend = document.getElementById('chart-legend');
                            if (legend) legend.innerHTML = '';
                            
                            log(`Active: ${account.toUpperCase()}`);
                            
                            updateHeaderIcon(account); // Update sticky header icon

                            // FIX 2: AUTO-SYNC only if token is still fresh (prevents 401 cascade)
                            if (account === 'atome' || account === 'bpi') {
                                const token = localStorage.getItem('g_access_token');
                                const tokenIssuedAt = parseInt(localStorage.getItem('g_token_issued_at') || '0');
                                const tokenAge = Date.now() - tokenIssuedAt;
                                const TOKEN_MAX_AGE = 50 * 60 * 1000; // 50 minutes
                                if (token && tokenAge < TOKEN_MAX_AGE) {
                                    if (switchSyncTimer) clearTimeout(switchSyncTimer);
                                    switchSyncTimer = setTimeout(() => {
                                        log(`üîÑ Auto-sync check for ${account} wallet on swipe...`);
                                        handleScan(5, false);
                                    }, 800);
                                } else {
                                    console.log(`‚è≠Ô∏è Token expired/missing for ${account}. Skipping auto-sync on swipe.`);
                                }
                            }

                            // FIX 4: Debounced loadData from observer
                            const now = Date.now();
                            if (now - lastObserverLoadTime > OBSERVER_LOAD_DEBOUNCE) {
                                lastObserverLoadTime = now;
                                loadData();
                            }
                        }
                    }
                });
            }, { 
                threshold: 0.55, // FIX 5: Lower threshold to prevent double-swipe requirement
                root: viewport
            });

            cards.forEach(card => observer.observe(card));
            
            // Initial Scroll to saved account
            const savedCard = document.querySelector(`.balance-card[data-account="${window.currentAccount}"]`);
            if (savedCard) {
                setTimeout(() => {
                    savedCard.scrollIntoView({ behavior: 'auto', block: 'nearest', inline: 'center' });
                    updateHeaderIcon(window.currentAccount);
                    applyTheme(window.currentAccount); // Ensure theme matches initial card
                }, 200);
            }
        }
        
        function updateHeaderIcon(account) {
            const cardBg = document.getElementById('card-bg');
            if (cardBg) {
                const isAdmin = auth.currentUser && auth.currentUser.email === 'johnpaulinso123@gmail.com';
                if (account === 'bpi' && isAdmin) {
                    cardBg.setAttribute('fill', '#8b0000'); // BPI red
                } else {
                    cardBg.setAttribute('fill', '#1a1a1a'); // Atome black (Default)
                }
            }
        }

        // FETCH TRANSACTIONS FROM FIRESTORE (REAL-TIME LISTENER)
        window.unsubscribeSnapshot = null; // Store listener to detach later
        window.isDataLoading = false; 

        async function loadData(providedUid = null) {
            const uid = providedUid || auth.currentUser?.uid;
            if (!uid) return;

            // PREVENT REDUNDANT CALLS: Early exit if already loading this specific account
            const loadKey = `${uid}_${window.currentAccount}`;
            if (window.lastLoadKey === loadKey && window.isDataLoading) {
                console.log('‚è≥ Load already in progress for:', loadKey);
                return;
            }
            window.lastLoadKey = loadKey;
            window.isDataLoading = true;

            window.historyLimit = 6; 
            const container = document.getElementById('history-container');
            const spinner = document.getElementById('loading-spinner');
            
            // Clear existing listener if any
            if (window.unsubscribeSnapshot) {
                window.unsubscribeSnapshot();
                window.unsubscribeSnapshot = null;
            }

            // SNAPSHOT LOCK: Prevent stale snapshot data from overwriting new account data
            const currentSyncId = Date.now() + Math.random();
            window.activeSyncId = currentSyncId;

            // INSTANT CACHE LOAD for seamless switching
            const cacheKey = `wallet_cache_${uid}_${window.currentAccount}`;
            const cachedData = localStorage.getItem(cacheKey);
            let hasValidCache = false;

            if (cachedData) {
                try {
                    const cache = JSON.parse(cachedData);
                    const now = Date.now();
                    // 24 hour expiry (86400000 ms)
                    if (cache.txns && (now - cache.timestamp < 86400000)) {
                        window.allTxns = cache.txns;
                        renderHistory(cache.txns);
                        updateBalanceToThisMonth(cache.txns);
                        hasValidCache = true;
                        
                        // Robust Chart Initialization with slight delay to ensure DOM readiness
                        setTimeout(() => {
                            const filterEl = document.getElementById('chart-filter');
                            if (filterEl) {
                                filterEl.value = 'this_month';
                                filterChart();
                            }
                        }, 100);
                        
                        if (spinner) spinner.style.display = 'none'; 
                    }
                } catch(e) { console.warn("Cache error", e); }
            }

            // SPINNER LOGIC: Only show if no cache is valid, or show with short delay
            if (spinner) {
                if (!hasValidCache) {
                    spinner.style.display = 'block';
                } else {
                    // Cache exists: Only show spinner if data takes >500ms to arrive
                    clearTimeout(window.spinnerTimeout);
                    window.spinnerTimeout = setTimeout(() => {
                        if (window.isDataLoading && spinner) {
                            spinner.style.display = 'block';
                            log('Cloud sync taking longer than expected...');
                        }
                    }, 500);
                }
            }

            try {
                const isAnon = auth.currentUser.isAnonymous;
                
                const syncStatusText = document.getElementById('syncStatusText');
                if (syncStatusText) syncStatusText.innerText = isAnon ? 'Local Storage Only' : 'Cloud Live Sync';
                
                // MULTI-ACCOUNT COLLECTION SELECTION
                const collectionName = getCollectionName(window.currentAccount);
                let q = query(collection(db, "users", uid, collectionName), orderBy("date", "desc"));
                
                // DATA ISOLATION: Query ONLY the current account's path.
                // Replaced getDocs with onSnapshot
                const syncAccount = window.currentAccount; // Capture for closure check
                window.unsubscribeSnapshot = onSnapshot(q, (snap) => {
                    // STALE CHECK: If user switched accounts while this listener was active
                    if (window.activeSyncId !== currentSyncId || syncAccount !== window.currentAccount) {
                        return;
                    }
                    let txns = [];

                    // 1. QUICK COMPARISON (Check if first 5 IDs match and length matches)
                    const prevTxns = window.allTxns || [];
                    const snapCount = snap.docs.length;
                    
                    snap.docs.forEach(d => {
                        const data = d.data();
                        if (data.deleted) return; 
                        
                        // PRE-CALCULATE SORT KEYS for performance
                        const dateVal = new Date(data.date).getTime() || 0;
                        const createVal = data.createdAt ? 
                            (data.createdAt.toMillis ? data.createdAt.toMillis() : new Date(data.createdAt).getTime()) : 0;
                        
                        txns.push({ 
                            id: d.id, 
                            _sortKey: dateVal, 
                            _createKey: createVal, 
                            ...data 
                        });
                    });

                    // Sort locally - Optimized (O(N log N) with fewer object creations)
                    txns.sort((a, b) => {
                        if (b._sortKey !== a._sortKey) return b._sortKey - a._sortKey;
                        return b._createKey - a._createKey;
                    });

                    const isSame = prevTxns.length === txns.length && 
                                   txns.every((t, i) => 
                                       prevTxns[i] && 
                                       prevTxns[i].id === t.id && 
                                       prevTxns[i].note === t.note && 
                                       prevTxns[i].manualCategory === t.manualCategory &&
                                       prevTxns[i].manualAmount === t.manualAmount &&
                                       prevTxns[i].excluded === t.excluded &&
                                       prevTxns[i].refund === t.refund
                                   );

                    if (isSame && document.getElementById('history-container').children.length > 0) {
                        log(`Snapshot matches cache for ${syncAccount}. Render skipped.`);
                        
                        // Ensure chart is still rendered if it's currently empty
                        const filterEl = document.getElementById('chart-filter');
                        const chartVal = document.getElementById('chart-total-val');
                        if (filterEl && (filterEl.value !== 'this_month' || (chartVal && chartVal.innerText === '0'))) {
                           filterEl.value = 'this_month';
                           filterChart();
                        }

                        spinner.style.display = 'none';
                        return;
                    }

                    const batchUpdates = []; 
                    // No need to re-loop or re-sort if we already did it above or can reuse it
                    
                    // Store globally & Cache with timestamp
                    window.allTxns = txns;
                    const currentAccCacheKey = `wallet_cache_${uid}_${syncAccount}`;
                    
                    // Cleanup internal sort keys before caching
                    const cacheTxns = txns.map(({_sortKey, _createKey, ...t}) => t);
                    
                    localStorage.setItem(currentAccCacheKey, JSON.stringify({
                        txns: cacheTxns,
                        timestamp: Date.now()
                    }));
                    
                    // Reset loading state as data has arrived
                    window.isDataLoading = false;
                    clearTimeout(window.spinnerTimeout);
                    if (spinner) spinner.style.display = 'none';
                    
                    updateBalanceToThisMonth(txns, syncAccount); 

                    if (txns.length === 0) {
                        // EMPTY STATE
                        document.getElementById('expenses-total-summary').innerText = 'PHP 0.00';
                        document.getElementById('trend-period-total').innerText = 'PHP 0.00';
                        document.getElementById('chart-total-val').innerText = '0';
                        const balanceEl = document.querySelector(`.balance-card[data-account="${syncAccount}"] .balance-amount`) || document.getElementById(`${syncAccount}-balance`);
                        if (balanceEl) {
                            balanceEl.innerText = 'PHP 0.00';
                            balanceEl.dataset.raw = 'PHP 0.00';
                            balanceEl.classList.add('privacy-mask');
                            if(localStorage.getItem('balance_hidden') === 'true') balanceEl.innerText = '******';
                        }
                        
                        if (window.drawPieChart) window.drawPieChart([], 0);
                        if (window.drawTrendChart) window.drawTrendChart([]);

                        container.innerHTML = `
                            <div style="text-align:center; padding:60px 20px; color:#64748b; background: white; border-radius: 12px; border: 1px dashed #cbd5e1;">
                                <i class="material-icons" style="font-size: 48px; margin-bottom: 10px; opacity: 0.5;">inbox</i>
                                <p style="margin:0; font-weight: 500;">No transactions found.</p>
                                <p style="font-size: 13px; margin: 10px 0 0;">Click "Scan Gmail" to sync your Atome payments.</p>
                            </div>`;
                    } else {
                        renderHistory(txns);
                        
                        // Apply active category filter
                        if (window.filterTxnList) filterTxnList();

                        // Always default chart filter to 'this_month' on fresh data load/page return
                        const defaultFilter = 'this_month';
                        const filterEl = document.getElementById('chart-filter');
                        if (filterEl) {
                           filterEl.value = defaultFilter;
                           // Use a small delay if coming from fresh load to ensure components are ready
                           setTimeout(() => filterChart(), 50);
                        }
                    }
                }, (error) => {
                    log('Snapshot Error: ' + error.message, 'error');
                    window.isDataLoading = false;
                    if (spinner) spinner.style.display = 'none';
                    clearTimeout(window.spinnerTimeout);
                });

                // Clear loading state after listener is successfully attached
                // The actual data processing happens in the listener
                setTimeout(() => { 
                    window.isDataLoading = false; 
                    clearTimeout(window.spinnerTimeout);
                    if (spinner) spinner.style.display = 'none';
                }, 1000); // 1s safety margin for initial sync

                window.highlightTransactions = (categoryName, categoryColor = null) => {
                    const items = document.querySelectorAll('.premium-txn');
                    const normalizedTarget = categoryName ? categoryName.toLowerCase().trim() : null;
                    
                    items.forEach(item => {
                        item.classList.remove('highlight-txn');
                        item.style.backgroundColor = '';
                        item.style.borderLeft = '';
                        item.style.boxShadow = '';
                        
                        if (!normalizedTarget) return;

                        // Only highlight if the item is actually visible (not hidden by month filter or search)
                        const isVisible = item.offsetParent !== null; 
                        if (!isVisible) return;

                        const catElement = item.querySelector('.txn-sub span:last-child');
                        if (catElement) {
                            const itemCat = catElement.innerText.toLowerCase().trim();
                            if (itemCat === normalizedTarget) {
                                item.classList.add('highlight-txn');
                                if (categoryColor) {
                                    item.style.backgroundColor = categoryColor + '10'; // 10 is ~6% opacity hex
                                    item.style.borderLeft = `4px solid ${categoryColor}`;
                                    item.style.boxShadow = `inset 4px 0 0 ${categoryColor}`;
                                }
                            }
                        }
                    });
                };
            } catch (e) { 
                log('Failed to load history: ' + e.message, 'error');
                spinner.style.display = 'none';
            }
        }
        window.loadData = loadData;

        // BACKGROUND WATCHER: Keep Atome balance in sync even when on BPI account
        window.watchAtomeBalance = () => {
            const uid = auth.currentUser?.uid;
            if (!uid) return;
            
            // Avoid duplicate listeners
            if (window.unsubscribeAtomeWatch) {
                window.unsubscribeAtomeWatch();
            }

            log('Background Atome Watcher: Starting...', 'ready');
            const q = query(collection(db, "users", uid, "transactions"), orderBy("date", "desc"));
            
            window.unsubscribeAtomeWatch = onSnapshot(q, (snap) => {
                let incomeTotal = 0;
                let expenseTotal = 0;

                snap.docs.forEach(d => {
                    const t = d.data();
                    if (t.deleted || t.excluded || t.refund) return;
                    
                    const amt = t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0);
                    const mapped = getMerchantDisplay(t.merchant, t);

                    if (mapped.category === 'Income') {
                        incomeTotal += amt;
                    } else {
                        expenseTotal += amt;
                    }
                });

                const balance = incomeTotal - expenseTotal;
                window.atomeBalanceVal = balance;
                
                // Update Atome specific elements if they exist in the DOM (even if hidden)
                const atomeEl = document.getElementById('atome-balance') || document.querySelector('.balance-card[data-account="atome"] .balance-amount');
                if (atomeEl) {
                    const formatted = `PHP ${balance.toLocaleString(undefined, {minimumFractionDigits:2})}`;
                    atomeEl.dataset.raw = formatted;
                    const isHidden = localStorage.getItem('balance_hidden') === 'true';
                    atomeEl.innerText = isHidden ? '******' : formatted;
                }

                log(`Background Atome Sync: ${balance.toFixed(2)}`, 'ready');
                updateSafeSpendUI();
            }, (err) => {
                log('Atome Watcher Error: ' + err.message, 'error');
            });
        };

        // BACKGROUND CACHE HYDRATION (Warm up all accounts)
        window.hydrateAllCaches = async () => {
            const uid = auth.currentUser?.uid;
            if (!uid) return;
            
            const savedAccounts = JSON.parse(localStorage.getItem('wallet_accounts') || '[]');
            const defaultAccounts = ['atome', 'bpi'];
            const allAccountIds = [...new Set([...defaultAccounts, ...savedAccounts.map(a => a.id)])];
            
            log(`Warming up cache for ${allAccountIds.length} accounts...`);
            
            for (const accId of allAccountIds) {
                if (accId === window.currentAccount) continue; // Current already handled
                
                try {
                    const collectionName = accId === 'atome' ? "transactions" : (accId === 'bpi' ? "bpi_transactions" : `txns_${accId}`);
                    // Use getDocs for one-time fetch to avoid many active listeners
                    const q = query(collection(db, "users", uid, collectionName), orderBy("date", "desc"), limit(100));
                    const snap = await getDocs(q);
                    
                    const txns = snap.docs.map(d => ({ id: d.id, ...d.data() })).filter(t => !t.deleted);
                    const cacheKey = `wallet_cache_${uid}_${accId}`;
                    localStorage.setItem(cacheKey, JSON.stringify({
                        txns: txns,
                        timestamp: Date.now()
                    }));
                } catch (e) { console.warn(`Silent hydrate failed for ${accId}`, e); }
            }
        };

        window.atomeBalanceVal = 0;
        window.bpiBalanceVal = 0;

        // BALANCE CACHE: Save computed balances to localStorage for instant load on refresh
        window.saveWalletBalanceCache = () => {
            const balances = {
                atome: window.atomeBalanceVal || 0,
                bpi: window.bpiBalanceVal || 0
            };
            // Also capture any other wallet balances from walletAccounts
            if (window.walletAccounts) {
                window.walletAccounts.forEach(acc => {
                    if (acc.id === 'atome') balances.atome = window.atomeBalanceVal || acc.balance || 0;
                    else if (acc.id === 'bpi') balances.bpi = window.bpiBalanceVal || acc.balance || 0;
                    else if (acc.balance !== undefined) balances[acc.id] = acc.balance;
                });
            }
            localStorage.setItem('wallet_cached_balances', JSON.stringify(balances));
            console.log('üí∞ Saved balance cache:', balances);
        };

        function updateBPIInsight() {
            const insightEl = document.getElementById('bpi-remaining-insight');
            if (!insightEl) return;

            // Try to pull from global state first, then fallback to DOM if global is 0
            let bpi = window.bpiBalanceVal;
            let atome = window.atomeBalanceVal;

            if (bpi === 0) {
                const bpiEl = document.getElementById('bpi-balance');
                if (bpiEl) bpi = parseFloat(bpiEl.innerText.replace(/[^\d.-]/g, '')) || 0;
            }
            if (atome === 0) {
                const atomeEl = document.getElementById('atome-balance');
                if (atomeEl) atome = parseFloat(atomeEl.innerText.replace(/[^\d.-]/g, '')) || 0;
            }

            if (bpi === 0 && atome === 0) return;

            const remaining = bpi + atome;
            const atomeLabel = (atome < 0 ? '-' : '+') + '‚Ç±' + Math.abs(atome).toLocaleString(undefined, {minimumFractionDigits:2});
            
            const rawHTML = `‚Ç±${remaining.toLocaleString(undefined, {minimumFractionDigits:2})} <span style="opacity: 0.6; font-weight: 600;">(${atomeLabel})</span>`;
            
            insightEl.dataset.raw = rawHTML;
            insightEl.classList.add('privacy-mask');
            
            if (localStorage.getItem('balance_hidden') === 'true') {
                insightEl.innerText = '******';
            } else {
                insightEl.innerHTML = rawHTML;
            }
            insightEl.style.opacity = '1';

            // Trigger Safe to Spend update
            updateSafeSpendUI();
            
            // PERSIST BALANCES: Save to localStorage for instant load on refresh
            if (window.saveWalletBalanceCache) window.saveWalletBalanceCache();
        }

        window.updateSafeSpendUI = () => {
             // Only for Admin on BPI account
             const isAdmin = auth.currentUser && auth.currentUser.email === 'johnpaulinso123@gmail.com';
             const isBPI = window.currentAccount === 'bpi';
             const widget = document.getElementById('safe-spend-widget');
             
             if (!widget || !isAdmin || !isBPI) {
                 if (widget) widget.style.display = 'none';
                 return;
             }
             
             widget.style.display = 'block';

             // Config from Firestore (with fallbacks)
             const config = window.safeToSpendConfig || {
                savingsAmount: 3000,
                obligations: []
             };

             // 1. Get Balance
             let balance = window.bpiBalanceVal;
             if (balance === 0) {
                 const bpiEl = document.getElementById('bpi-balance');
                 if (bpiEl) balance = parseFloat(bpiEl.innerText.replace(/[^\d.-]/g, '')) || 0;
             }

             // 2. Savings from Firestore
             const savingsValue = config.savingsAmount || 3000;
             const ccPayment = Math.abs(window.atomeBalanceVal || 0);

             // 3. Obligations Sum (only included ones)
             let obligationsTotal = 0;
             if (config.obligations) {
                 config.obligations.forEach(ob => {
                     if (ob.included !== false) obligationsTotal += (parseFloat(ob.amount) || 0);
                 });
             }

             // 3. Calculate Safe to Spend
             const mainBalValue = 3000;
             
             const isExcluded = config.excludeMaintaining === true;
             const isSavingsExcluded = config.excludeSavings === true;
             
             const effectiveMainBal = isExcluded ? 0 : mainBalValue;
             const effectiveSavings = isSavingsExcluded ? 0 : savingsValue;
             
             // NEW: Toggleable items
             const isAtomeExcluded = config.excludeAtome === true;
             const isSalaryIncluded = config.includeSalary === true;
             const salaryValue = config.salaryAmount || 8800;
             
             const effectiveAtome = isAtomeExcluded ? 0 : ccPayment;
             const effectiveSalary = isSalaryIncluded ? salaryValue : 0;

             const safeAmount = balance - effectiveMainBal - effectiveSavings - effectiveAtome - obligationsTotal + effectiveSalary;
             const safeEl = document.getElementById('safe-spend-val');
             const formatted = `PHP ${safeAmount.toLocaleString(undefined, {minimumFractionDigits:2})}`;
             
             safeEl.dataset.raw = formatted;
             safeEl.innerText = localStorage.getItem('balance_hidden') === 'true' ? '******' : formatted;
             
             // Dynamic color (Health check)
             if (safeAmount < 1000) safeEl.style.color = '#ef4444'; // Red (High Risk)
             else if (safeAmount < 5000) safeEl.style.color = '#f59e0b'; // Orange (Risky)
             else safeEl.style.color = '#10b981'; // Green (Safe)

             // 4. Update Breakdown Items
             const isHidden = localStorage.getItem('balance_hidden') === 'true';

             // Maintaining Balance Update
             const itemMaintaining = document.getElementById('item-maintaining');
             const checkMaintaining = document.getElementById('maintaining-check');
             const metaMaintaining = document.getElementById('maintaining-meta');
             const maintainingEl = document.getElementById('breakdown-maintaining');
             
             if (isExcluded) {
                 if (itemMaintaining) {
                    itemMaintaining.style.opacity = '0.4';
                    itemMaintaining.style.filter = 'grayscale(1)';
                 }
                 if (checkMaintaining) checkMaintaining.innerText = 'remove_circle_outline';
                 if (metaMaintaining) metaMaintaining.innerText = 'Excluded from safe budget';
             } else {
                 if (itemMaintaining) {
                    itemMaintaining.style.opacity = '1';
                    itemMaintaining.style.filter = 'none';
                 }
                 if (checkMaintaining) checkMaintaining.innerText = 'account_balance';
                 if (metaMaintaining) metaMaintaining.innerText = 'BPI REQUIRED';
             }
             if (maintainingEl) {
                 const val = `‚Ç±${mainBalValue.toLocaleString(undefined, {minimumFractionDigits:2})}`;
                 maintainingEl.dataset.raw = val;
                 maintainingEl.innerText = isHidden ? '******' : val;
             }

             // Savings Update
             const itemSavings = document.getElementById('item-savings');
             const checkSavings = document.getElementById('savings-check');
             const metaSavings = document.getElementById('savings-meta');
             const savingsEl = document.getElementById('breakdown-savings');

             if (isSavingsExcluded) {
                 if (itemSavings) {
                    itemSavings.style.opacity = '0.4';
                    itemSavings.style.filter = 'grayscale(1)';
                 }
                 if (checkSavings) checkSavings.innerText = 'remove_circle_outline';
                 if (metaSavings) metaSavings.innerText = 'Excluded from safe budget';
             } else {
                 if (itemSavings) {
                    itemSavings.style.opacity = '1';
                    itemSavings.style.filter = 'none';
                 }
                 if (checkSavings) checkSavings.innerText = 'savings';
                 if (metaSavings) metaSavings.innerText = 'MONTHLY INCOME';
             }
             if (savingsEl) {
                 const val = `‚Ç±${savingsValue.toLocaleString(undefined, {minimumFractionDigits:2})}`;
                 savingsEl.dataset.raw = val;
                 savingsEl.innerText = isHidden ? '******' : val;
             }

             // CC Payment Update
             const itemCredit = document.getElementById('item-credit');
             const checkCredit = document.getElementById('credit-check');
             const metaCredit = document.getElementById('credit-meta');
             const creditEl = document.getElementById('breakdown-credit');

             if (isAtomeExcluded) {
                 if (itemCredit) {
                    itemCredit.style.opacity = '0.4';
                    itemCredit.style.filter = 'grayscale(1)';
                 }
                 if (checkCredit) checkCredit.innerText = 'remove_circle_outline';
                 if (metaCredit) metaCredit.innerText = 'Excluded from safe budget';
             } else {
                 if (itemCredit) {
                    itemCredit.style.opacity = '1';
                    itemCredit.style.filter = 'none';
                 }
                 if (checkCredit) checkCredit.innerText = 'credit_card';
                 if (metaCredit) metaCredit.innerText = 'ATOME WALLET LINK';
             }
             if (creditEl) {
                 const val = `‚Ç±${ccPayment.toLocaleString(undefined, {minimumFractionDigits:2})}`;
                 creditEl.dataset.raw = val;
                 creditEl.innerText = isHidden ? '******' : val;
             }

             // Salary Update
             const itemSalary = document.getElementById('item-salary');
             const checkSalary = document.getElementById('salary-check');
             const metaSalary = document.getElementById('salary-meta');
             const salaryEl = document.getElementById('breakdown-salary');

             if (!isSalaryIncluded) {
                 if (itemSalary) {
                    itemSalary.style.opacity = '0.4';
                    itemSalary.style.filter = 'grayscale(1)';
                 }
                 if (checkSalary) checkSalary.innerText = 'remove_circle_outline';
                 if (metaSalary) metaSalary.innerText = 'Excluded from safe budget';
             } else {
                 if (itemSalary) {
                    itemSalary.style.opacity = '1';
                    itemSalary.style.filter = 'none';
                 }
                 if (checkSalary) checkSalary.innerText = 'payments';
                 if (metaSalary) metaSalary.innerText = 'INCLUDED IN SAFE BUDGET';
             }
             if (salaryEl) {
                 const val = `‚Ç±${salaryValue.toLocaleString(undefined, {minimumFractionDigits:2})}`;
                 salaryEl.dataset.raw = val;
                 salaryEl.innerText = isHidden ? '******' : val;
             }

             // 5. Dynamic Obligations rendering
             const obContainer = document.getElementById('dynamic-obligations-container');
             if (obContainer) {
                 if (config.obligations && config.obligations.length > 0) {
                     obContainer.innerHTML = config.obligations.map(ob => {
                         const isIncluded = ob.included !== false; // Default to true
                         const excludedStyle = isIncluded ? '' : 'opacity: 0.4; filter: grayscale(1);';
                         const toggleIcon = isIncluded ? 'check_circle' : 'remove_circle_outline';
                         const toggleColor = isIncluded ? '#64748b' : '#cbd5e1';
                         
                         return `
                         <div class="breakdown-item" style="margin-top: 2px; ${excludedStyle} transition: all 0.3s ease;">
                             <div onclick="toggleObligation('${ob.id}')" style="cursor: pointer; display: flex; align-items: center; gap: 10px; flex: 1;">
                                 <div class="breakdown-icon" style="background: rgba(0,0,0,0.03); color: ${toggleColor}; width: 34px; height: 34px; border-radius: 10px; font-size: 18px;">
                                     <i class="material-icons" style="font-size: 18px;">${toggleIcon}</i>
                                 </div>
                                 <div class="breakdown-info">
                                     <div class="breakdown-name" style="color: #64748b; font-size: 9px;">${ob.title.toUpperCase()}</div>
                                     <div class="breakdown-meta" style="font-size: 8.5px;">${isIncluded ? 'Fixed Obligation' : 'Excluded'}</div>
                                 </div>
                             </div>
                             <div style="display: flex; align-items: center; gap: 4px;">
                                 <div class="breakdown-val privacy-mask" onclick="editObligationAmount('${ob.id}')" style="color: #64748b; font-size: 12px; cursor: pointer; padding: 4px 8px; border-radius: 6px; transition: background 0.2s;">‚Ç±${(parseFloat(ob.amount) || 0).toLocaleString(undefined, {minimumFractionDigits:2})}</div>
                                 <button onclick="deleteObligation('${ob.id}')" style="background:none; border:none; color:#cbd5e1; cursor:pointer; padding:4px; display:flex; align-items:center;">
                                     <i class="material-icons" style="font-size: 16px;">delete_outline</i>
                                 </button>
                             </div>
                         </div>
                         `;
                     }).join('');
                 } else {
                     obContainer.innerHTML = '';
                 }
             }




             // 5. Update Footer & Salary Info
             const cashIn = parseFloat(localStorage.getItem('bpi_expected_cashin') || '8800');
             const footerBadge = document.getElementById('footer-cash-in-badge');
             if (footerBadge) {
                const formattedCI = `‚Ç±${cashIn.toLocaleString()}`;
                footerBadge.dataset.raw = formattedCI;
                footerBadge.innerText = isHidden ? '******' : formattedCI;
             }

             const paycheck = calculateNextPaycheck();
             document.getElementById('footer-paycheck-date').innerText = paycheck.date;
             document.getElementById('footer-countdown').innerText = `${paycheck.days} ${paycheck.days === 1 ? 'Day' : 'Days'}`;
             document.getElementById('budget-until-date').innerText = paycheck.date;
        };

        function calculateNextPaycheck() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth();
            const day = now.getDate();

            let targetDay;
            let targetMonth = month;
            let targetYear = year;

            if (day < 15) {
                targetDay = 15;
            } else if (day < 30) {
                targetDay = 30;
                // Check if month has 30 days, otherwise end of month
                const lastDayOfMonth = new Date(year, month + 1, 0).getDate();
                if (lastDayOfMonth < 30) targetDay = lastDayOfMonth;
            } else {
                targetDay = 15;
                targetMonth = month + 1;
                if (targetMonth > 11) {
                    targetMonth = 0;
                    targetYear++;
                }
            }

            const targetDate = new Date(targetYear, targetMonth, targetDay);
            const diffTime = targetDate - now;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            return {
                date: `${monthNames[targetMonth]} ${targetDay}`,
                days: diffDays >= 0 ? diffDays : 0
            };
        }

        window.promptSetObligations = () => {
            const current = localStorage.getItem('bpi_obligations') || '0';
            showAppDialog({
                title: 'Upcoming Obligations',
                message: 'Enter total amount of upcoming fixed payments, bills, or debts (PHP).',
                input: true,
                value: current,
                callback: (val) => {
                    if (val !== null && val !== false && !isNaN(val)) {
                        localStorage.setItem('bpi_obligations', val);
                        updateSafeSpendUI();
                        showToast('Obligations updated!');
                    }
                }
            });
        };

        window.promptSetCashIn = () => {
            const current = localStorage.getItem('bpi_expected_cashin') || '8800';
            showAppDialog({
                title: 'Expected Cash In',
                message: 'Enter your expected paycheck amount (e.g. 8800).',
                input: true,
                value: current,
                callback: (val) => {
                    if (val !== null && val !== false && !isNaN(val)) {
                        localStorage.setItem('bpi_expected_cashin', val);
                        updateSafeSpendUI();
                        showToast('Expected cash-in updated!');
                    }
                }
            });
        };


        window.toggleBalanceVisibility = (e) => {
             if(e) e.stopPropagation();
             const isHidden = localStorage.getItem('balance_hidden') === 'true';
             const newState = !isHidden;
             localStorage.setItem('balance_hidden', newState);
             
             console.log('üîí Privacy Toggle:', newState ? 'HIDING' : 'SHOWING');
             
             // Update all visibility buttons (eye icons)
             const buttons = document.querySelectorAll('.visibility-btn i');
             buttons.forEach(btn => {
                 btn.innerText = newState ? 'visibility_off' : 'visibility';
             });
             
             // Update ALL masked elements
             const maskedElements = document.querySelectorAll('.privacy-mask');
             console.log('üìä Found', maskedElements.length, 'privacy-mask elements');
             
             maskedElements.forEach((el, index) => {
                 const raw = el.dataset.raw || el.innerText;
                 if(!el.dataset.raw) el.dataset.raw = raw; // Init if missing
                 
                 console.log(`  [${index}] ${el.className}:`, raw, '‚Üí', newState ? '******' : raw);
                 
                 // Apply mask or show raw
                 if(newState) {
                     el.innerText = '******';
                 } else {
                     el.innerText = raw;
                 }
             });
             
             // Update BPI insight if exists (Special case handling inside function)
             updateBPIInsight();
        };

        window.toggleMaintainingBalance = async () => {
             const config = window.safeToSpendConfig || {};
             const isExcluded = config.excludeMaintaining === true;
             const newState = !isExcluded;
             
             // Optimistic update
             window.safeToSpendConfig = { ...config, excludeMaintaining: newState };
             updateSafeSpendUI();
             
             // Persist to Firestore
             try {
                 const uid = auth.currentUser?.uid;
                 if (uid) {
                     await setDoc(doc(db, "users", uid, "config", "safe_to_spend"), { excludeMaintaining: newState }, { merge: true });
                 }
             } catch (e) { console.error('Failed to save maintaining toggle', e); }
             
             showToast(newState ? 'Maintaining balance excluded' : 'Maintaining balance included');
        };

        window.toggleSavings = async () => {
             const config = window.safeToSpendConfig || {};
             const isExcluded = config.excludeSavings === true;
             const newState = !isExcluded;
             
             // Optimistic update
             window.safeToSpendConfig = { ...config, excludeSavings: newState };
             updateSafeSpendUI();
             
             // Persist to Firestore
             try {
                 const uid = auth.currentUser?.uid;
                 if (uid) {
                     await setDoc(doc(db, "users", uid, "config", "safe_to_spend"), { excludeSavings: newState }, { merge: true });
                 }
             } catch (e) { console.error('Failed to save savings toggle', e); }
             
             showToast(newState ? 'Savings excluded' : 'Savings included');
        };

        window.toggleAtome = async () => {
             const config = window.safeToSpendConfig || {};
             const isExcluded = config.excludeAtome === true;
             const newState = !isExcluded;
             
             window.safeToSpendConfig = { ...config, excludeAtome: newState };
             updateSafeSpendUI();
             
             try {
                 const uid = auth.currentUser?.uid;
                 if (uid) {
                     await setDoc(doc(db, "users", uid, "config", "safe_to_spend"), { excludeAtome: newState }, { merge: true });
                 }
             } catch (e) { console.error('Failed to save Atome toggle', e); }
             
             showToast(newState ? 'Atome excluded' : 'Atome included');
        };

        window.toggleSalary = async () => {
             const config = window.safeToSpendConfig || {};
             const isIncluded = config.includeSalary === true;
             const newState = !isIncluded;
             
             window.safeToSpendConfig = { ...config, includeSalary: newState };
             updateSafeSpendUI();
             
             try {
                 const uid = auth.currentUser?.uid;
                 if (uid) {
                     await setDoc(doc(db, "users", uid, "config", "safe_to_spend"), { includeSalary: newState }, { merge: true });
                 }
             } catch (e) { console.error('Failed to save salary toggle', e); }
             
             showToast(newState ? 'Salary included' : 'Salary excluded');
        };

        window.promptSetSalary = async () => {
            const currentAmount = window.safeToSpendConfig?.salaryAmount || 8800;
            const res = await showAppDialog({
                title: 'Upcoming Salary Amount',
                message: 'Enter your expected salary amount (PHP).',
                input: true,
                value: currentAmount
            });
            if (res !== null && res !== false && !isNaN(res)) {
                const val = parseFloat(res);
                const uid = auth.currentUser.uid;
                await setDoc(doc(db, "users", uid, "config", "safe_to_spend"), { 
                    salaryAmount: val 
                }, { merge: true });
                showToast('Salary amount updated!');
            }
        };

        window.promptSetSavings = async () => {
            const currentAmount = window.safeToSpendConfig?.savingsAmount || 3000;
            const res = await showAppDialog({
                title: 'Monthly Savings Goal',
                message: 'Enter your monthly savings target (PHP).',
                input: true,
                value: currentAmount
            });
            if (res !== null && res !== false && !isNaN(res)) {
                const val = parseFloat(res);
                const uid = auth.currentUser.uid;
                await setDoc(doc(db, "users", uid, "config", "safe_to_spend"), { 
                    ...window.safeToSpendConfig,
                    savingsAmount: val 
                }, { merge: true });
                showToast('Savings goal updated!');
            }
        };

        window.closeObligationModal = () => {
            const modal = document.getElementById('obligation-modal');
            modal.classList.remove('show');
        };

        window.deleteObligation = async (id) => {
            const config = window.safeToSpendConfig || { obligations: [] };
            const updatedObligations = (config.obligations || []).filter(ob => ob.id !== id);
            
            const uid = auth.currentUser.uid;
            await setDoc(doc(db, "users", uid, "config", "safe_to_spend"), {
                ...config,
                obligations: updatedObligations
            }, { merge: true });
            
            showToast('Obligation removed');
        };

        window.toggleObligation = async (id) => {
            const config = window.safeToSpendConfig || { obligations: [] };
            const updatedObligations = (config.obligations || []).map(ob => {
                if (ob.id === id) {
                    return { ...ob, included: ob.included === false ? true : false };
                }
                return ob;
            });
            
            // Optimistic update
            window.safeToSpendConfig = { ...config, obligations: updatedObligations };
            updateSafeSpendUI();
            
            const uid = auth.currentUser?.uid;
            if (uid) {
                await setDoc(doc(db, "users", uid, "config", "safe_to_spend"), {
                    obligations: updatedObligations
                }, { merge: true });
            }
        };

        window.editObligationAmount = async (id) => {
            const config = window.safeToSpendConfig || { obligations: [] };
            const obligation = (config.obligations || []).find(ob => ob.id === id);
            if (!obligation) return;
            
            const result = await showAppDialog({
                title: 'Edit Obligation Amount',
                message: `Update amount for "${obligation.title}"`,
                input: true,
                value: obligation.amount || 0
            });
            
            if (result !== null && result !== false && !isNaN(result)) {
                const newAmount = parseFloat(result);
                const updatedObligations = config.obligations.map(ob => {
                    if (ob.id === id) {
                        return { ...ob, amount: newAmount };
                    }
                    return ob;
                });
                
                // Optimistic update
                window.safeToSpendConfig = { ...config, obligations: updatedObligations };
                updateSafeSpendUI();
                
                const uid = auth.currentUser?.uid;
                if (uid) {
                    await setDoc(doc(db, "users", uid, "config", "safe_to_spend"), {
                        obligations: updatedObligations
                    }, { merge: true });
                }
                showToast('Obligation updated!');
            }
        };

        window.promptSetObligations = () => {
            const config = window.safeToSpendConfig || { obligations: [] };
            const titleInput = document.getElementById('ob-input-title');
            const amountInput = document.getElementById('ob-input-amount');
            const saveBtn = document.getElementById('ob-save-btn');

            titleInput.value = '';
            amountInput.value = '';

            const modal = document.getElementById('obligation-modal');
            modal.classList.add('show');

            saveBtn.onclick = async () => {
                const title = titleInput.value.trim() || 'Obligation';
                const amount = parseFloat(amountInput.value) || 0;
                
                const uid = auth.currentUser.uid;
                const newObligation = {
                    id: Date.now().toString(),
                    title: title,
                    amount: amount
                };
                
                const updatedObligations = [...(config.obligations || []), newObligation];
                
                await setDoc(doc(db, "users", uid, "config", "safe_to_spend"), {
                    ...config,
                    obligations: updatedObligations
                }, { merge: true });

                closeObligationModal();
                showToast('Obligation added!');
            };
        };

        // DARK MODE TOGGLE
        window.toggleDarkMode = () => {
            const currentTheme = localStorage.getItem('theme_preference') || 'light';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            
            // Update body class
            if (newTheme === 'dark') {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
            
            // Update icon and text in dropdown
            const icon = document.getElementById('dark-mode-icon');
            const text = document.getElementById('dark-mode-text');
            if (icon) icon.innerText = newTheme === 'dark' ? 'light_mode' : 'dark_mode';
            if (text) text.innerText = newTheme === 'dark' ? 'Light Mode' : 'Dark Mode';
            
            // Save preference
            localStorage.setItem('theme_preference', newTheme);
            
            console.log('üåì Theme toggled to:', newTheme);
        };

        // SAFETY: Initialize visibility and theme on load
        window.addEventListener('DOMContentLoaded', () => {
             // Initialize theme
             const savedTheme = localStorage.getItem('theme_preference') || 'light';
             if (savedTheme === 'dark') {
                 document.body.classList.add('dark-mode');
                 const icon = document.getElementById('dark-mode-icon');
                 const text = document.getElementById('dark-mode-text');
                 if (icon) icon.innerText = 'light_mode';
                 if (text) text.innerText = 'Light Mode';
             }

             // Initialize privacy mask
             const isHidden = localStorage.getItem('balance_hidden') === 'true';
             if(isHidden) {
                 setTimeout(() => {
                    const buttons = document.querySelectorAll('.visibility-btn i');
                    buttons.forEach(btn => btn.innerText = 'visibility_off');
                    
                    // Force mask on all elements that might have rendered early
                    const maskedElements = document.querySelectorAll('.privacy-mask');
                    maskedElements.forEach(el => {
                        if(!el.dataset.raw) el.dataset.raw = el.innerText;
                        el.innerText = '******';
                    });
                 }, 50);
             }
        });

        function updateBalanceToThisMonth(txns, targetAccount) {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth();
            
            let incomeTotal = 0;
            let expenseTotal = 0;

            txns.forEach(t => {
                if (t.excluded || t.refund) return;
                const d = new Date(t.date);
                // Removed monthly filter to make balance cumulative
                // if (d.getFullYear() !== year || d.getMonth() !== month) return;

                const mapped = getMerchantDisplay(t.merchant, t);
                const amt = t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0);
                
                if (mapped.category === 'Income') {
                    incomeTotal += amt;
                } else {
                    expenseTotal += amt;
                }
            });

            // Target the specific card's balance element
            const acc = targetAccount || window.currentAccount;
            const balanceEl = document.querySelector(`.balance-card[data-account="${acc}"] .balance-amount`) || document.getElementById(`${acc}-balance`);
            if (balanceEl) {
                const balance = incomeTotal - expenseTotal;
                const formatted = `PHP ${balance.toLocaleString(undefined, {minimumFractionDigits:2})}`;
                
                // Store raw for toggle
                balanceEl.dataset.raw = formatted;
                
                // Add privacy class
                balanceEl.classList.add('privacy-mask');
                
                // Apply visibility state
                const isHidden = localStorage.getItem('balance_hidden') === 'true';
                balanceEl.innerText = isHidden ? '******' : formatted;
                
                // Store globally and update insight
                if (acc === 'atome') window.atomeBalanceVal = balance;
                if (acc === 'bpi') window.bpiBalanceVal = balance;
                updateBPIInsight();
            }

            // Update insight cards and comparison charts
            updateInsightCards(txns);

        }


        // ---- INSIGHT CARDS & MONTHLY SUMMARY ----
        function updateInsightCards(txns) {
            if (!txns || txns.length === 0) return;
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth();
            const dayOfMonth = now.getDate();

            // This month's expenses (non-excluded, non-refund, non-income)
            const thisMonthTxns = txns.filter(t => {
                if (t.excluded || t.refund || t.reimbursed) return false;
                const d = new Date(t.date);
                if (d.getFullYear() !== year || d.getMonth() !== month) return false;
                const mapped = getMerchantDisplay(t.merchant, t);
                return mapped.category !== 'Income';
            });

            // Last month's expenses
            const lastMonthDate = new Date(year, month - 1, 1);
            const lmYear = lastMonthDate.getFullYear();
            const lmMonth = lastMonthDate.getMonth();
            const lastMonthTxns = txns.filter(t => {
                if (t.excluded || t.refund || t.reimbursed) return false;
                const d = new Date(t.date);
                if (d.getFullYear() !== lmYear || d.getMonth() !== lmMonth) return false;
                const mapped = getMerchantDisplay(t.merchant, t);
                return mapped.category !== 'Income';
            });

            const getAmt = t => t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0);

            const isHidden = localStorage.getItem('balance_hidden') === 'true';
            
            // --- DAILY AVERAGE ---
            const thisMonthTotal = thisMonthTxns.reduce((s, t) => s + getAmt(t), 0);
            const dailyAvg = dayOfMonth > 0 ? thisMonthTotal / dayOfMonth : 0;
            const dailyAvgEl = document.getElementById('daily-avg-val');
            const dailyAvgSub = document.getElementById('daily-avg-sub');
            if (dailyAvgEl) {
                const formatted = '‚Ç±' + dailyAvg.toLocaleString(undefined, { maximumFractionDigits: 0 });
                dailyAvgEl.dataset.raw = formatted;
                dailyAvgEl.textContent = isHidden ? '******' : formatted;
            }

            // Compare to last month's daily average
            const lastMonthTotal = lastMonthTxns.reduce((s, t) => s + getAmt(t), 0);
            const daysInLastMonth = new Date(lmYear, lmMonth + 1, 0).getDate();
            const lastDailyAvg = daysInLastMonth > 0 ? lastMonthTotal / daysInLastMonth : 0;
            if (dailyAvgSub) {
                if (lastDailyAvg > 0) {
                    const pctChange = ((dailyAvg - lastDailyAvg) / lastDailyAvg) * 100;
                    const arrow = pctChange > 0 ? '‚Üë' : '‚Üì';
                    dailyAvgSub.textContent = `${arrow} ${Math.abs(pctChange).toFixed(0)}% vs last month`;
                    dailyAvgSub.className = 'insight-sub ' + (pctChange > 0 ? 'up' : 'down');
                } else {
                    dailyAvgSub.textContent = 'this month';
                    dailyAvgSub.className = 'insight-sub neutral';
                }
            }

            // --- BIGGEST EXPENSE ---
            let biggestAmt = 0;
            let biggestName = '‚Äî';
            thisMonthTxns.forEach(t => {
                const amt = getAmt(t);
                if (amt > biggestAmt) {
                    biggestAmt = amt;
                    const mapped = getMerchantDisplay(t.merchant, t);
                    // USER REQUEST: Prioritize merchant name over note
                    biggestName = mapped.name || t.merchant || t.note || 'Unknown';
                }
            });
            const bigVal = document.getElementById('biggest-txn-val');
            const bigSub = document.getElementById('biggest-txn-sub');
            if (bigVal) {
                const formatted = '‚Ç±' + biggestAmt.toLocaleString(undefined, { maximumFractionDigits: 0 });
                bigVal.dataset.raw = formatted;
                bigVal.textContent = isHidden ? '******' : formatted;
            }
            if (bigSub) bigSub.textContent = biggestName.toUpperCase();

            // --- MONTHLY SUMMARY ---
            const summaryTotal = document.getElementById('summary-total');
            const summaryChange = document.getElementById('summary-change');
            const summaryTopCat = document.getElementById('summary-top-cat');
            const summaryCount = document.getElementById('summary-txn-count');

            if (summaryTotal) {
                const formatted = '‚Ç±' + thisMonthTotal.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                summaryTotal.dataset.raw = formatted;
                summaryTotal.textContent = isHidden ? '******' : formatted;
            }
            if (summaryCount) summaryCount.textContent = thisMonthTxns.length;

            // % change vs last month
            if (summaryChange) {
                if (lastMonthTotal > 0) {
                    const pct = ((thisMonthTotal - lastMonthTotal) / lastMonthTotal) * 100;
                    const arrow = pct > 0 ? '‚Üë' : '‚Üì';
                    summaryChange.textContent = `${arrow} ${Math.abs(pct).toFixed(0)}%`;
                    summaryChange.className = 's-value ' + (pct > 0 ? 'red' : 'green');
                } else {
                    summaryChange.textContent = '‚Äî';
                    summaryChange.className = 's-value';
                }
            }

            // Top category
            if (summaryTopCat) {
                const catTotals = {};
                thisMonthTxns.forEach(t => {
                    const mapped = getMerchantDisplay(t.merchant, t);
                    const cat = t.manualCategory || mapped.category || 'Uncategorized';
                    const label = typeof displayCategoryName === 'function' ? displayCategoryName(cat) : cat;
                    catTotals[label] = (catTotals[label] || 0) + getAmt(t);
                });
                const topCat = Object.entries(catTotals).sort((a, b) => b[1] - a[1])[0];
                summaryTopCat.textContent = topCat ? topCat[0] : '‚Äî';
            }
        }

        // Toggle Monthly Summary collapse
        window.toggleMonthlySummary = () => {
            const body = document.getElementById('summary-body');
            const toggle = document.getElementById('summary-toggle');
            if (body) body.classList.toggle('collapsed');
            if (toggle) toggle.classList.toggle('collapsed');
        };

        window.toggleAdminMode = () => {
            const user = auth.currentUser;
            const adminEmail = 'johnpaulinso123@gmail.com';
            if (user && user.email && user.email.toLowerCase().trim() === adminEmail) {
                const adminDiv = document.getElementById('admin-controls');
                const logDiv = document.getElementById('log-container');
                if (!adminDiv || !logDiv) return showToast('Admin elements missing');
                const isHidden = adminDiv.style.display === 'none';
                adminDiv.style.display = isHidden ? 'block' : 'none';
                logDiv.style.display = isHidden ? 'block' : 'none';
                showToast(isHidden ? 'Admin View On' : 'Admin View Off');
            } else {
                showToast('Action restricted');
            }
        };

        window.exportData = () => {
            if (!window.allTxns || window.allTxns.length === 0) {
                showToast('No data to export');
                return;
            }

            const today = new Date().toISOString().split('T')[0];
            
            // 1. JSON Export
            const dataStr = JSON.stringify(window.allTxns, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            const jsonName = `wallet_backup_${today}.json`;
            const jsonLink = document.createElement('a');
            jsonLink.setAttribute('href', dataUri);
            jsonLink.setAttribute('download', jsonName);
            jsonLink.click();

            // 2. CSV Export
            setTimeout(() => {
                const headers = ['Date', 'Merchant', 'Amount', 'Category', 'Note', 'Excluded', 'Refund'];
                const csvRows = [headers.join(',')];
                
                window.allTxns.forEach(t => {
                    const mapped = getMerchantDisplay(t.merchant, t);
                    const row = [
                        new Date(t.date).toLocaleDateString(),
                        `"${(mapped.name || '').replace(/"/g, '""')}"`,
                        t.amount || (t.manualAmount || 0),
                        `"${(mapped.category || '').replace(/"/g, '""')}"`,
                        `"${(t.note || '').replace(/"/g, '""')}"`,
                        t.excluded ? 'Yes' : 'No',
                        t.refund ? 'Yes' : 'No'
                    ];
                    csvRows.push(row.join(','));
                });

                const csvStr = csvRows.join('\n');
                const csvUri = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csvStr);
                const csvName = `wallet_export_${today}.csv`;
                const csvLink = document.createElement('a');
                csvLink.setAttribute('href', csvUri);
                csvLink.setAttribute('download', csvName);
                csvLink.click();
            }, 300);

            showToast('JSON + CSV Export Created');
        };

        window.importData = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedTxns = JSON.parse(e.target.result);
                    if (!Array.isArray(importedTxns)) throw new Error('Invalid format');
                    const confirmed = await showAppDialog({
                        title: 'Import Data',
                        message: `Import ${importedTxns.length} transactions? These will be merged with your current history.`,
                        confirm: true
                    });
                    if (!confirmed) return;
                    showToast('Importing...');
                    const uid = auth.currentUser.uid;
                    const txnsCol = collection(db, `users/${uid}/transactions`);
                    for (const t of importedTxns) {
                        const { id, ...cleanT } = t;
                        if (id) {
                            await setDoc(doc(db, `users/${uid}/transactions`, id), cleanT, { merge: true });
                        } else {
                            await addDoc(txnsCol, { ...cleanT, createdAt: serverTimestamp() });
                        }
                    }
                    showToast('Import Complete');
                    event.target.value = '';
                } catch (err) {
                    showToast('Import failed: ' + err.message);
                }
            };
            reader.readAsText(file);
        };

        // HARD REFRESH FUNCTION
        window.hardRefresh = () => {
             if(!confirm('This will clear local cache and reload the app to fix sync issues. Continue?')) return;
             
             // Clear Data Caches
             const keys = Object.keys(localStorage);
             for(let k of keys) {
                 if(k.startsWith('wallet_cache_') || k.startsWith('last_deep_sync_') || k.startsWith('last_quick_sync_')) {
                     localStorage.removeItem(k);
                 }
             }
             
             // Unregister Service Workers (Force Update)
             if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(function(registrations) {
                    for(let registration of registrations) {
                        registration.unregister();
                    }
                });
             }
             
             // Force Reload
             window.location.reload();
        };

        // FILTERING LOGIC
        window.filterChart = () => {
            const filterEl = document.getElementById('chart-filter');
            const filter = filterEl.value;

            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth();
            const date = now.getDate();
            
            if (!window.allTxns) return;

            // Helper for week numbers
            const getWeek = (d) => {
                const onejan = new Date(d.getFullYear(), 0, 1);
                return Math.ceil((((d - onejan) / 86400000) + onejan.getDay() + 1) / 7);
            };

            const checkPeriod = (t, periodType, shift = 0) => {
                const d = (t.date && t.date.seconds) ? new Date(t.date.seconds * 1000) : new Date(t.date);
                if (isNaN(d.getTime())) return false;
                
                const dYear = d.getFullYear();
                const dMonth = d.getMonth();
                const dDate = d.getDate();
                const dWeek = getWeek(d);
                const currentWeek = getWeek(now);

                // Handle dynamic month values (YYYY-MM format)
                if (typeof periodType === 'string' && periodType.match(/^\d{4}-\d{2}$/)) {
                    const [targetYear, targetMonth] = periodType.split('-').map(Number);
                    if (shift === 0) {
                        return dYear === targetYear && dMonth === targetMonth - 1;
                    } else if (shift === 1) {
                        const prevDate = new Date(targetYear, targetMonth - 1 - 1, 1);
                        return dYear === prevDate.getFullYear() && dMonth === prevDate.getMonth();
                    }
                }

                // Handle "all_time" filter
                if (periodType === 'all_time') {
                    return shift === 0;
                }

                if (periodType === 'today') {
                    // Current: Today (shift 0), Past: Yesterday (shift 1)
                    const target = new Date(now);
                    target.setDate(date - shift);
                    return dYear === target.getFullYear() && dMonth === target.getMonth() && dDate === target.getDate();
                }

                if (periodType === 'this_month') {
                    // Current (0): This Month, Past (1): Last Month
                    const targetMonth = (month - shift + 12) % 12;
                    const targetYear = year - Math.floor((12 - (month - shift) - 1) / 12); // Handle year wrap roughly, or simplified:
                    // Better:
                    const targetD = new Date(year, month - shift, 1);
                    return dMonth === targetD.getMonth() && dYear === targetD.getFullYear();
                }
                
                if (periodType === 'last_7_days') {
                    // Rolling 7 days from now (Shift 0: 0-6 days ago, Shift 1: 7-13 days ago)
                    const limit = new Date(now);
                    limit.setDate(now.getDate() - (7 * (shift + 1)) + 1);
                    limit.setHours(0,0,0,0);
                    
                    const upper = new Date(now);
                    upper.setDate(now.getDate() - (7 * shift));
                    upper.setHours(23,59,59,999);
                    
                    return d >= limit && d <= upper;
                }

                if (periodType === 'this_week') {
                     // Current (0): This week, Past (1): Last week
                     // Note: Simple logic assuming same year for simplicity or handling close year boundaries
                     if (shift === 0) return dWeek === currentWeek && dYear === year;
                     if (shift === 1) return dWeek === currentWeek - 1 && dYear === year;
                }
                
                if (periodType === 'last_week') {
                     // Current (0): Last week, Past (1): 2 weeks ago
                     if (shift === 0) return dWeek === currentWeek - 1 && dYear === year;
                     if (shift === 1) return dWeek === currentWeek - 2 && dYear === year;
                }

                if (periodType === 'first_15') {
                    // Current (0): <= 15th of THIS month
                    // Past (1): > 15th of PREVIOUS month
                    if (shift === 0) return dDate <= 15 && dMonth === month && dYear === year;
                    if (shift === 1) {
                        const prevMonthDate = new Date(year, month - 1, 1);
                        return dDate > 15 && dMonth === prevMonthDate.getMonth() && dYear === prevMonthDate.getFullYear();
                    }
                }
                
                if (periodType === 'last_15') {
                    // Current (0): > 15th of THIS month
                    // Past (1): <= 15th of THIS month
                    if (shift === 0) return dDate > 15 && dMonth === month && dYear === year;
                    if (shift === 1) return dDate <= 15 && dMonth === month && dYear === year;
                }
                
                if (periodType === 'last_month') {
                    // Current (0): Last month
                    // Past (1): 2 months ago
                    const targetDate = new Date(year, month - 1 - shift, 1);
                     return dMonth === targetDate.getMonth() && dYear === targetDate.getFullYear();
                }
                
                if (periodType === 'last_3_months') {
                    const limit = new Date(now);
                    limit.setMonth(limit.getMonth() - 3 - (shift * 3));
                    const upper = new Date(now);
                    if (shift > 0) upper.setMonth(upper.getMonth() - 3);
                    
                    return d >= limit && (shift === 0 || d < upper);
                }
                
                if (periodType === 'last_6_months') {
                    const limit = new Date(now);
                    limit.setMonth(limit.getMonth() - 6 - (shift * 6));
                    const upper = new Date(now);
                    if (shift > 0) upper.setMonth(upper.getMonth() - 6);
                    return d >= limit && (shift === 0 || d < upper);
                }
                
                if (periodType === 'this_year') {
                    return dYear === (year - shift);
                }
                
                return false;
            };

            const filtered = window.allTxns.filter(t => checkPeriod(t, filter, 0));
            const past = window.allTxns.filter(t => checkPeriod(t, filter, 1));
            
            const pastTotal = past.reduce((sum, t) => {
                 if (t.excluded || t.refund || t.reimbursed) return sum;
                 const mapped = getMerchantDisplay(t.merchant, t);
                 if (mapped.category === 'Income') return sum;
                 return sum + (t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0));
            }, 0);

            refreshChart(filtered, pastTotal);
            
            // Re-render history to apply highlights if needed
            renderHistory(window.allTxns);
        };

        // CHART LOGIC
        const categoryConfig = {
            'Online shopping': { color: '#f97316', darkColor: '#ea580c', class: 'cat-online' },
            'Vehicle': { color: '#8b5cf6', darkColor: '#7c3aed', class: 'cat-vehicle' },
            'Shopping': { color: '#3b82f6', darkColor: '#2563eb', class: 'cat-shopping' },
            'Service': { color: '#d946ef', darkColor: '#c026d3', class: 'cat-service-magenta' },
            'Food & Drinks': { color: '#eab308', darkColor: '#ca8a04', class: 'cat-food' },
            'Life & Entertainment': { color: '#10b981', darkColor: '#059669', class: 'cat-life' },
            'Trading Expenses': { color: '#ef4444', darkColor: '#dc2626', class: 'cat-trading' },
            'Trade Copier': { color: '#0891b2', darkColor: '#0e7490', class: 'cat-aqua' },
            'Financial Expenses': { color: '#ef4444', darkColor: '#dc2626', class: 'cat-financial' },
            'Credit Card Payment': { color: '#f59e0b', darkColor: '#d97706', class: 'cat-credit-card' },
            'Transportation': { color: '#8b5cf6', darkColor: '#7c3aed', class: 'cat-vehicle' },
            'Travel': { color: '#06b6d4', darkColor: '#0891b2', class: 'cat-aqua' },
            'Education': { color: '#1e40af', darkColor: '#1e3a8a', class: 'cat-shopping' },
            'Sport': { color: '#10b981', darkColor: '#059669', class: 'cat-life' },
            'Savings': { color: '#16a34a', darkColor: '#16a34a', class: 'cat-investments' },
            'Income': { color: '#16a34a', darkColor: '#16a34a', class: 'cat-income' },
            'Other': { color: '#64748b', darkColor: '#475569', class: 'cat-financial' }
        };

        function refreshChart(txns, pastTotal = 0) {
            const chartSection = document.getElementById('chart-section');
            const totals = {};
            let grandTotal = 0;

            let incomeTotal = 0;
            let expenseTotal = 0;

            txns.forEach(t => {
                if (t.excluded || t.refund || t.reimbursed) return;
                const mapped = getMerchantDisplay(t.merchant, t);
                const amt = t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0);
                let cat = mapped.category || 'Other';
                if (cat === 'Financial expenses') cat = 'Financial Expenses';
                if (cat === 'Trading expenses') cat = 'Trading Expenses';
                
                if (cat === 'Income') {
                    incomeTotal += amt;
                } else {
                    totals[cat] = (totals[cat] || 0) + amt;
                    expenseTotal += amt;
                }
            });
            
            grandTotal = expenseTotal; // Chart shows Expenses only

            // Balance update removed from chart filter to stay as 'This Month'
            
            // Always show progress even if zero
            chartSection.style.display = 'block';

            const segments = Object.entries(totals).map(([name, value]) => ({
                name,
                value,
                color: (categoryConfig[name] || categoryConfig['Other']).color,
                class: (categoryConfig[name] || categoryConfig['Other']).class
            })).sort((a, b) => b.value - a.value);

            // Update Summary Total
            const summaryTotalEl = document.getElementById('expenses-total-summary');
            if (summaryTotalEl) {
                const formatted = `PHP ${grandTotal.toLocaleString(undefined, {minimumFractionDigits:2})}`;
                summaryTotalEl.dataset.raw = formatted;
                summaryTotalEl.classList.add('privacy-mask');
                summaryTotalEl.style.color = 'var(--text-primary)';
                summaryTotalEl.innerText = localStorage.getItem('balance_hidden') === 'true' ? '******' : formatted;
            }

            // Update Growth with passed pastTotal
            const growthEl = document.getElementById('mom-growth');
            const growthBox = document.getElementById('mom-growth-box');
            if (growthEl && growthBox) {
                if (pastTotal > 0) {
                    const diff = ((grandTotal - pastTotal) / pastTotal) * 100;
                    const diffAbs = Math.abs(Math.round(diff));
                    growthEl.innerText = `${diff >= 0 ? '+' : '-'}${diffAbs}%`;
                    growthBox.style.color = diff >= 0 ? '#ef4444' : '#10b981';
                } else {
                    growthEl.innerText = '+0%';
                    growthBox.style.color = '#94a3b8';
                }
            }
            
            drawPieChart(segments, grandTotal);
        }


        function drawTrendChart(txns) {
            const path = document.getElementById('trendPath');
            const area = document.getElementById('trendArea');
            const pathCompare = document.getElementById('trendPathCompare');
            const areaCompare = document.getElementById('trendAreaCompare');
            const dots = document.getElementById('trendDots');
            const dotsCompare = document.getElementById('trendDotsCompare');
            const totalEl = document.getElementById('trend-period-total');
            const filterEl = document.getElementById('trend-filter');
            const filter = filterEl ? filterEl.value : 'this_month';
            
            if (!path || txns.length === 0) return;

            // Reset elements
            if (pathCompare) pathCompare.setAttribute('d', '');
            if (areaCompare) areaCompare.setAttribute('d', '');
            if (dotsCompare) dotsCompare.innerHTML = '';
            const legendEl = document.getElementById('trend-legend');
            if (legendEl) legendEl.style.display = (filter === 'this_vs_prev') ? 'flex' : 'none';

            // CATEGORY FILTER
            const trendCatEl = document.getElementById('txn-cat-filter');
            const selectedTrendCat = trendCatEl ? trendCatEl.value : 'all';

            const matchesCatFilter = (t, mappedTrn) => {
                if (selectedTrendCat === 'all') return true;
                const txnCatId = t.manualCategory || t.category || mappedTrn.category || '';
                const txnCatLabel = displayCategoryName ? displayCategoryName(txnCatId) : txnCatId;
                return txnCatId.toLowerCase() === selectedTrendCat.toLowerCase() || 
                       txnCatLabel.toLowerCase() === selectedTrendCat.toLowerCase();
            };

            const labelsContainer = document.getElementById('trend-labels');
            if (labelsContainer) labelsContainer.innerHTML = '';

            const now = new Date();
            let periodTotal = 0;
            let dataPoints = [];
            let dataPointsCompare = [];
            let labels = [];

            if (filter === 'this_week') {
                dataPoints = [0,0,0,0,0,0,0];
                labels = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
                const startOfWeek = new Date(now);
                startOfWeek.setDate(now.getDate() - now.getDay());
                startOfWeek.setHours(0,0,0,0);

                txns.forEach(t => {
                    const d = new Date(t.date);
                    const mappedTrn = getMerchantDisplay(t.merchant, t);
                    if (t.excluded || t.refund || t.reimbursed || d < startOfWeek || mappedTrn.category === 'Income') return; 
                    if (!matchesCatFilter(t, mappedTrn)) return;

                    const diff = Math.floor((d - startOfWeek) / 86400000);
                    if (diff >= 0 && diff < 7) {
                        const amt = t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0);
                        dataPoints[diff] += amt;
                        periodTotal += amt;
                    }
                });
            } else if (filter === 'last_6_months') {
                const monthsCount = 6;
                dataPoints = new Array(monthsCount).fill(0);
                for (let i = monthsCount - 1; i >= 0; i--) {
                    const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
                    labels.push(d.toLocaleString('default', { month: 'short' }));
                }
                const limitDate = new Date(now.getFullYear(), now.getMonth() - 5, 1);
                txns.forEach(t => {
                    const d = new Date(t.date);
                    const mappedTrn = getMerchantDisplay(t.merchant, t);
                    if (t.excluded || t.refund || t.reimbursed || d < limitDate || mappedTrn.category === 'Income') return;
                    if (!matchesCatFilter(t, mappedTrn)) return;
                    const monthDiff = (now.getFullYear() - d.getFullYear()) * 12 + (now.getMonth() - d.getMonth());
                    const idx = (monthsCount - 1) - monthDiff;
                    if (idx >= 0 && idx < monthsCount) {
                        const amt = t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0);
                        dataPoints[idx] += amt;
                        periodTotal += amt;
                    }
                });
            } else {
                // this_month or last_3_months or this_vs_prev
                let weeksCount = 4;
                if (filter === 'last_3_months') weeksCount = 12;
                else if (filter === 'this_vs_prev') {
                    // Force 5 weeks for current vs previous comparison
                    weeksCount = 5;
                } else {
                    const firstDay = new Date(now.getFullYear(), now.getMonth(), 1);
                    const lastDay = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                    weeksCount = Math.ceil((firstDay.getDay() + lastDay.getDate()) / 7);
                }

                dataPoints = new Array(weeksCount).fill(0);
                if (filter === 'this_vs_prev') dataPointsCompare = new Array(weeksCount).fill(0);
                
                const limitDate = (filter === 'last_3_months') 
                    ? new Date(now.getTime() - (12 * 7 * 86400000))
                    : new Date(now.getFullYear(), now.getMonth(), 1);

                const prevMonthLimit = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                const prevMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);

                txns.forEach(t => {
                    const d = new Date(t.date);
                    const mappedTrn = getMerchantDisplay(t.merchant, t);
                    if (t.excluded || t.refund || t.reimbursed || mappedTrn.category === 'Income') return;
                    if (!matchesCatFilter(t, mappedTrn)) return;
                    
                    if (d >= limitDate) {
                        let idx;
                        if (filter === 'last_3_months') {
                            const diffWeeks = Math.floor((now - d) / (7 * 86400000));
                            idx = (weeksCount - 1) - diffWeeks;
                        } else {
                            const firstDay = new Date(d.getFullYear(), d.getMonth(), 1);
                            idx = Math.ceil((d.getDate() + firstDay.getDay()) / 7) - 1;
                        }
                        if (idx >= 0 && idx < weeksCount) {
                            const amt = t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0);
                            dataPoints[idx] += amt;
                            periodTotal += amt;
                        }
                    } else if (filter === 'this_vs_prev' && d >= prevMonthLimit && d <= prevMonthEnd) {
                        const firstDayPrev = new Date(d.getFullYear(), d.getMonth(), 1);
                        const idx = Math.ceil((d.getDate() + firstDayPrev.getDay()) / 7) - 1;
                        if (idx >= 0 && idx < weeksCount) {
                            const amt = t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0);
                            dataPointsCompare[idx] += amt;
                        }
                    }
                });

                // Labels
                const mNamesShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                for(let i=0; i<weeksCount; i++) {
                    if (filter === 'last_3_months') {
                        // Calculate specific month/week for the 12-week span
                        const weekDate = new Date(limitDate.getTime() + (i * 7 * 86400000));
                        const mName = mNamesShort[weekDate.getMonth()];
                        const firstDayM = new Date(weekDate.getFullYear(), weekDate.getMonth(), 1);
                        const wNum = Math.ceil((weekDate.getDate() + firstDayM.getDay()) / 7);
                        labels.push(`${mName} W${wNum}`);
                    } else {
                        labels.push(filter === 'this_vs_prev' ? `Week ${i+1}` : `W${i+1}`);
                    }
                }
            }

            // UI UPDATES
            if (labelsContainer) {
                labelsContainer.innerHTML = ''; // Clear existing labels
                labels.forEach((l, i) => {
                    const span = document.createElement('span');
                    span.className = 'trend-label';
                    if (window.currentThemeTrend && document.body.classList.contains('dark-mode')) {
                         span.style.color = '#94a3b8';
                    }
                    span.innerText = l;
                    labelsContainer.appendChild(span);
                });
            }

            const periodFormatted = `PHP ${periodTotal.toLocaleString(undefined, {minimumFractionDigits:2})}`;
            if (totalEl) {
                totalEl.dataset.raw = periodFormatted;
                totalEl.classList.add('privacy-mask');
                totalEl.innerText = localStorage.getItem('balance_hidden') === 'true' ? '******' : periodFormatted;
            }

            const monthLabelEl = document.getElementById('trend-month-label');
            if (monthLabelEl) {
                const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
                if (filter === 'this_vs_prev') monthLabelEl.innerText = "Current vs Previous Month";
                else if (filter === 'this_month') monthLabelEl.innerText = `${monthNames[now.getMonth()]} ${now.getFullYear()}`;
                else if (filter === 'this_week') monthLabelEl.innerText = "This Week";
                else monthLabelEl.innerText = filter.replace(/_/g, ' ').toUpperCase();
            }

            // DRAWING
            const max = Math.max(...dataPoints, ...dataPointsCompare, 500) * 1.2;
            const w = 400, h = 130, padding = 20;
            const chartW = w - (padding * 2);
            const step = chartW / (dataPoints.length - 1 || 1);

            const drawPath = (points, pathEl, areaEl, dotsEl, isCompare) => {
                if (!points || points.length === 0) return;
                let d = "", areaD = "";
                if (dotsEl) dotsEl.innerHTML = '';

                for (let i = 0; i < points.length; i++) {
                    const x = padding + (i * step);
                    const y = h - (points[i] / max) * h;
                    
                    if (i === 0) {
                        d += `M ${x} ${y}`;
                        areaD += `M ${x} ${h} L ${x} ${y}`;
                    } else {
                        const px = padding + ((i-1) * step);
                        const py = h - (points[i-1] / max) * h;
                        const cp1x = px + (x - px) / 2;
                        d += ` C ${cp1x} ${py}, ${cp1x} ${y}, ${x} ${y}`;
                        areaD += ` C ${cp1x} ${py}, ${cp1x} ${y}, ${x} ${y}`;
                    }
                    
                    // Dots removed as per user request
                }
                areaD += ` L ${padding + ((points.length-1) * step)} ${h} Z`;
                if (areaEl) areaEl.setAttribute('d', areaD);
                if (pathEl) pathEl.setAttribute('d', d);
            };

            let trendColor = window.currentThemeTrend || '#3b82f6';
            const isDarkMode = document.body.classList.contains('dark-mode');
            
            // PRIORITY: If we have a distinctive theme color (like BPI Red #931B1B), use it.
            // If it's a generic dark color or unset, use accessibility defaults.
            const isGenericColor = !window.currentThemeTrend || window.currentThemeTrend === '#121212' || window.currentThemeTrend === '#1e293b';
            
            if (isGenericColor) {
                if (isDarkMode) {
                    trendColor = '#ffffff';
                } else {
                    trendColor = '#1e293b'; // Standard visibility
                }
            } else {
                // Keep the account's vibrant theme color (e.g. BPI Red)
                trendColor = window.currentThemeTrend;
            }

            drawPath(dataPoints, path, area, dots, false);
            if (filter === 'this_vs_prev') {
                drawPath(dataPointsCompare, pathCompare, areaCompare, dotsCompare, true);
                // USER REQUEST: Sync legend indicator with theme
                const legendIndicator = document.querySelector('#trend-legend div > div[style*="background"]');
                if (legendIndicator) {
                    legendIndicator.style.background = trendColor;
                }
            } else {
                if (pathCompare) pathCompare.setAttribute('d', '');
                if (areaCompare) areaCompare.setAttribute('d', '');
            }
                if (trendColor) {
                    path.setAttribute('stroke', trendColor);
                    totalEl.style.color = trendColor;
                }

                // Interaction Helper
                const getPoint = (i) => ({
                    x: padding + (i * step),
                    y: h - (dataPoints[i] / max) * h
                });

                // Add Guide Line
                let guide = document.getElementById('trend-guide');
                if (!guide) {
                    guide = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    guide.id = 'trend-guide';
                    guide.setAttribute('y1', 0);
                    guide.setAttribute('y2', h);
                    guide.setAttribute('stroke', '#cbd5e1');
                    guide.setAttribute('stroke-width', '1');
                    guide.setAttribute('stroke-dasharray', '4 4');
                    guide.style.opacity = '0';
                    guide.style.transition = 'opacity 0.2s';
                    document.getElementById('trendChart').insertBefore(guide, path);
                }

                const trendSvg = document.getElementById('trendChart');
                let isTooltipPinned = false;

                const updateTooltip = (nearestIdx, e) => {
                    const p = getPoint(nearestIdx);
                    guide.setAttribute('x1', p.x);
                    guide.setAttribute('x2', p.x);
                    guide.style.opacity = '1';

                    const tooltip = document.getElementById('chart-tooltip');
                    let tooltipHTML = `<div style="font-weight:800; margin-bottom:2px;">${labels[nearestIdx] || 'Period'}</div>`;
                    tooltipHTML += `<div style="color:#d1fae5; font-size:13px; font-weight:800;">‚Ç±${Math.round(dataPoints[nearestIdx]).toLocaleString()}</div>`;
                    
                    if (filter === 'this_vs_prev' && dataPointsCompare[nearestIdx] !== undefined) {
                        tooltipHTML += `<div style="color:#94a3b8; font-size:11px; margin-top:2px;">‚Ç±${Math.round(dataPointsCompare[nearestIdx]).toLocaleString()}</div>`;
                    }
                    
                    tooltip.innerHTML = tooltipHTML;
                    tooltip.style.opacity = '1';
                    tooltip.style.display = 'block';
                    
                    // Center tooltip above the point if possible
                    const rect = trendSvg.getBoundingClientRect();
                    const absoluteX = rect.left + (p.x / 400) * rect.width + window.scrollX;
                    const absoluteY = rect.top + (p.y / 130) * rect.height + window.scrollY;
                    
                    tooltip.style.left = `${absoluteX}px`;
                    tooltip.style.top = `${absoluteY - 10}px`;
                    tooltip.style.transform = 'translate(-50%, -100%)';
                };

                trendSvg.onclick = (e) => {
                    e.stopPropagation();
                    const rect = trendSvg.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const viewBoxX = (mouseX / rect.width) * 400;
                    
                    let nearestIdx = 0;
                    let minDist = Infinity;
                    for (let i = 0; i < dataPoints.length; i++) {
                        const p = getPoint(i);
                        const dist = Math.abs(p.x - viewBoxX);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestIdx = i;
                        }
                    }

                    updateTooltip(nearestIdx, e);
                    isTooltipPinned = true;
                };

                trendSvg.onmousemove = (e) => {
                    if (isTooltipPinned) return;
                    const rect = trendSvg.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const viewBoxX = (mouseX / rect.width) * 400;
                    
                    let nearestIdx = 0;
                    let minDist = Infinity;
                    for (let i = 0; i < dataPoints.length; i++) {
                        const p = getPoint(i);
                        const dist = Math.abs(p.x - viewBoxX);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestIdx = i;
                        }
                    }

                    updateTooltip(nearestIdx, e);
                };

                trendSvg.onmouseleave = () => {
                    if (!isTooltipPinned) {
                        guide.style.opacity = '0';
                        document.getElementById('chart-tooltip').style.opacity = '0';
                    }
                };

                // Click outside to dismiss
                const dismissPin = (e) => {
                    if (isTooltipPinned && !trendSvg.contains(e.target)) {
                        isTooltipPinned = false;
                        guide.style.opacity = '0';
                        document.getElementById('chart-tooltip').style.opacity = '0';
                    }
                };
                window.addEventListener('click', dismissPin);
                // Clean up previous event listener if function is called again
                if (window._trendPinCleanup) window.removeEventListener('click', window._trendPinCleanup);
                window._trendPinCleanup = dismissPin;
            }

        let selectedCategoryName = null;

        function drawPieChart(segments, total, isUpdate = false) {
            const svgGroup = document.getElementById('pieContent');
            const legend = document.getElementById('chart-legend');
            const totalVal = document.getElementById('chart-total-val');
            const totalLabel = document.getElementById('chart-total-label');
            const totalPct = document.getElementById('chart-total-pct');
            
            svgGroup.innerHTML = '';
            legend.innerHTML = '';

            const centerX = 120; 
            const centerY = 120;
            const radius = 90; 
            const strokeWidth = 40; 
            const circumference = 2 * Math.PI * radius;
            
            const totalFormatted = total > 0 ? `‚Ç±${Math.round(total).toLocaleString()}` : "‚Ç±0";

            // State-based Label Logic
            if (totalLabel && totalVal) {
                if (!selectedCategoryName) {
                    totalLabel.innerText = 'TOTAL';
                    totalVal.innerText = localStorage.getItem('balance_hidden') === 'true' ? '******' : totalFormatted;
                    totalVal.dataset.raw = totalFormatted;
                    if (totalPct) totalPct.innerText = '';
                } else {
                    const seg = segments.find(s => s.name === selectedCategoryName);
                    if (seg) {
                        totalLabel.innerText = seg.name;
                        const valText = `‚Ç±${Math.round(seg.value).toLocaleString()}`;
                        totalVal.dataset.raw = valText;
                        totalVal.innerText = localStorage.getItem('balance_hidden') === 'true' ? '******' : valText;
                        
                        // Calculate percentage
                        if (totalPct) {
                            const pct = total > 0 ? ((seg.value / total) * 100).toFixed(2) : "0.00";
                            totalPct.innerText = parseFloat(pct) > 0 ? `${pct}%` : '';
                            totalPct.style.color = seg.color || '#10b981';
                        }
                    } else {
                        // Reset if category not found in current data
                        selectedCategoryName = null;
                        totalLabel.innerText = 'TOTAL';
                        totalVal.innerText = localStorage.getItem('balance_hidden') === 'true' ? '******' : totalFormatted;
                        totalVal.dataset.raw = totalFormatted;
                        if (totalPct) totalPct.innerText = '';
                    }
                }
            }

            // 1. Reset Layer (Background)
            const bgLayer = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            bgLayer.setAttribute('cx', centerX);
            bgLayer.setAttribute('cy', centerY);
            bgLayer.setAttribute('r', 120);
            bgLayer.setAttribute('fill', 'transparent');
            bgLayer.style.cursor = 'default';
            bgLayer.onclick = () => resetSelection();
            svgGroup.appendChild(bgLayer);

            const isDarkMode = document.body.classList.contains('dark-mode');

            // 2. Track Ring
            const track = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            track.setAttribute('cx', centerX);
            track.setAttribute('cy', centerY);
            track.setAttribute('r', radius);
            track.setAttribute('fill', 'none');
            track.setAttribute('stroke', isDarkMode ? '#262626' : '#f1f5f9');
            track.setAttribute('stroke-width', strokeWidth);
            svgGroup.appendChild(track);

            // 3. Center Button (Reset)
            const centerBtn = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerBtn.setAttribute('cx', centerX);
            centerBtn.setAttribute('cy', centerY);
            centerBtn.setAttribute('r', radius - strokeWidth/2);
            centerBtn.setAttribute('fill', 'transparent');
            centerBtn.style.cursor = 'pointer';
            centerBtn.onclick = (e) => {
                e.stopPropagation();
                resetSelection();
            };
            svgGroup.appendChild(centerBtn);
            
            if (segments.length === 0 || total === 0) {
                legend.innerHTML = `<div style="font-size:12px; color:#94a3b8; font-weight:600; grid-column: span 2; text-align:center;">No data for this period</div>`;
                return;
            }

            let currentAngle = -90;

            function resetSelection() {
                selectedCategoryName = null;
                drawPieChart(segments, total, true); 
                window.highlightTransactions(null);
            }

            segments.forEach((seg, index) => {
                const percent = seg.value / total;
                const arcLength = percent * circumference;
                const isSelected = selectedCategoryName === seg.name;
                const dimOpacity = selectedCategoryName && !isSelected ? 0.2 : 1;
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', centerX);
                circle.setAttribute('cy', centerY);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', seg.color);
                circle.setAttribute('stroke-width', isSelected ? strokeWidth + 6 : strokeWidth);
                if (selectedCategoryName && !isSelected) circle.setAttribute('opacity', '0.2');
                
                // Opening Animation Logic
                if (!isUpdate) {
                    circle.setAttribute('stroke-dasharray', `0 ${circumference}`);
                    setTimeout(() => {
                        circle.setAttribute('stroke-dasharray', `${arcLength} ${circumference}`);
                    }, 100 + (index * 40));
                } else {
                    circle.setAttribute('stroke-dasharray', `${arcLength} ${circumference}`);
                }
                
                circle.setAttribute('transform', `rotate(${currentAngle} ${centerX} ${centerY})`);
                circle.style.opacity = dimOpacity;
                circle.style.transition = 'all 0.4s cubic-bezier(0.16, 1, 0.3, 1)';
                circle.style.cursor = 'pointer';
                
                const handleInteraction = (e) => {
                    if(e) e.stopPropagation();
                    selectedCategoryName = (selectedCategoryName === seg.name) ? null : seg.name;
                    drawPieChart(segments, total, true);
                    window.highlightTransactions(selectedCategoryName, seg.color);
                };

                circle.onclick = handleInteraction;

                // Tooltip
                circle.onmouseenter = (e) => {
                    const tooltip = document.getElementById('chart-tooltip');
                    tooltip.innerHTML = `<div style="font-weight:800; margin-bottom:2px;">${seg.name}</div><div style="color:#d1fae5; font-size:13px;">‚Ç±${Math.round(seg.value).toLocaleString()} (${(percent*100).toFixed(1)}%)</div>`;
                    tooltip.style.opacity = '1';
                    tooltip.style.left = `${e.pageX + 15}px`;
                    tooltip.style.top = `${e.pageY - 40}px`;
                    circle.style.filter = 'brightness(1.1)';
                };
                circle.onmouseleave = () => {
                    document.getElementById('chart-tooltip').style.opacity = '0';
                    circle.style.filter = 'none';
                };

                svgGroup.appendChild(circle);
                currentAngle += (percent * 360);
                
                // Legend
                const lItem = document.createElement('div');
                lItem.className = `legend-item ${isSelected ? 'active' : ''}`;
                lItem.style.opacity = dimOpacity;
                lItem.style.transition = 'all 0.3s';
                lItem.style.cursor = 'pointer';
                lItem.innerHTML = `<div class="legend-color" style="background: ${seg.color}"></div><span>${seg.name}</span>`;
                lItem.onclick = handleInteraction;
                legend.appendChild(lItem);
            });
        }
        function drawPieChart_OLD_Implementation(segments, total) {
            const container = document.getElementById('chart-anim-container');
            const svgGroup = document.getElementById('pieContent');
            const legend = document.getElementById('chart-legend');
            const totalVal = document.getElementById('chart-total-val');
            
            svgGroup.innerHTML = '';
            legend.innerHTML = '';
            totalVal.innerText = total > 0 ? `‚Ç±${Math.round(total).toLocaleString()}` : "‚Ç±0";

            const centerX = 120; // Centered for the 240 viewBox
            const centerY = 120;
            const radius = 110; 
            const innerRadius = 70;
            let currentAngle = -90;
            
            // Handle Empty State (0 segments)
            if (segments.length === 0 || total === 0) {
                // Clear any previous chart first
                svgGroup.innerHTML = '';
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', centerX);
                circle.setAttribute('cy', centerY);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', '#f1f5f9');
                svgGroup.appendChild(circle);
                
                legend.innerHTML = '<div style="font-size:12px; color:#94a3b8; font-weight:600; grid-column: span 2; text-align:center;">No data for this period</div>';
                return;
            }
            if (segments.length === 1) {
                const seg = segments[0];
                
                // Draw full donut
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                // Calculate d for full circle donut
                const d = [
                    `M ${centerX} ${centerY - radius}`,
                    `A ${radius} ${radius} 0 1 1 ${centerX} ${centerY + radius}`,
                    `A ${radius} ${radius} 0 1 1 ${centerX} ${centerY - radius}`,
                    `M ${centerX} ${centerY - innerRadius}`,
                    `A ${innerRadius} ${innerRadius} 0 1 0 ${centerX} ${centerY + innerRadius}`,
                    `A ${innerRadius} ${innerRadius} 0 1 0 ${centerX} ${centerY - innerRadius}`,
                    'Z'
                ].join(' ');

                path.setAttribute('d', d);
                // Ensure trend line is white in dark mode
                const isDarkMode = document.body.classList.contains('dark-mode');
                path.setAttribute('stroke', isDarkMode ? '#ffffff' : '#3b82f6');
                path.setAttribute('fill', seg.color);
                path.setAttribute('fill-rule', 'evenodd');
                path.classList.add('chart-segment'); 
                path.classList.add('pie-animate'); // Add spin animation
                path.style.cursor = 'pointer';
                path.onclick = () => {
                    const isHidden = localStorage.getItem('balance_hidden') === 'true';
                    document.getElementById('chart-total-label').innerText = seg.name;
                    const valText = `‚Ç±${Math.round(seg.value).toLocaleString()}`;
                    const valEl = document.getElementById('chart-total-val');
                    valEl.dataset.raw = valText;
                    valEl.innerText = isHidden ? '******' : valText;
                    window.highlightTransactions(seg.name);
                };
                
                svgGroup.appendChild(path);
                
                // Legend
                const lItem = document.createElement('div');
                lItem.className = 'legend-item';
                lItem.innerHTML = `<div class="legend-color" style="background: ${seg.color}"></div><span>${seg.name}</span>`;
                legend.appendChild(lItem);
                
                return;
            }

            segments.forEach(seg => {
                const percent = (seg.value / total) * 100;
                if (percent < 0.5) return; 

                const angle = (seg.value / total) * 360;
                const endAngle = currentAngle + angle;

                const largeArc = angle > 180 ? 1 : 0;
                
                const x1 = centerX + radius * Math.cos((currentAngle * Math.PI) / 180);
                const y1 = centerY + radius * Math.sin((currentAngle * Math.PI) / 180);
                const x2 = centerX + radius * Math.cos((endAngle * Math.PI) / 180);
                const y2 = centerY + radius * Math.sin((endAngle * Math.PI) / 180);
                
                const ix1 = centerX + innerRadius * Math.cos((currentAngle * Math.PI) / 180);
                const iy1 = centerY + innerRadius * Math.sin((currentAngle * Math.PI) / 180);
                const ix2 = centerX + innerRadius * Math.cos((endAngle * Math.PI) / 180);
                const iy2 = centerY + innerRadius * Math.sin((endAngle * Math.PI) / 180);

                const d = [
                    `M ${x1} ${y1}`,
                    `A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2}`,
                    `L ${ix2} ${iy2}`,
                    `A ${innerRadius} ${innerRadius} 0 ${largeArc} 0 ${ix1} ${iy1}`,
                    'Z'
                ].join(' ');

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', d);
                path.setAttribute('fill', seg.color);
                path.setAttribute('stroke', '#fff');
                path.setAttribute('stroke-width', '4'); 
                path.classList.add('pie-animate'); // Add spin animation
                path.style.transition = 'all 0.3s';
                path.style.cursor = 'pointer';
                path.style.transformOrigin = 'center';
                
                // Interaction Events
                const showTooltip = (e) => {
                    const tooltip = document.getElementById('chart-tooltip');
                    if (!tooltip) return;
                    
                    const percentText = percent.toFixed(1) + '%';
                    tooltip.innerHTML = `<div style="font-weight: 800; margin-bottom: 4px;">${seg.name}</div><div style="color:#d1fae5; font-size: 13px;">‚Ç±${Math.round(seg.value).toLocaleString()} <span style="opacity: 0.8;">(${percentText})</span></div>`;
                    tooltip.style.opacity = '1';
                    tooltip.style.display = 'block';
                    
                    // Better positioning - offset from cursor
                    const x = e.pageX || e.clientX;
                    const y = e.pageY || e.clientY;
                    tooltip.style.left = `${x + 15}px`;
                    tooltip.style.top = `${y - 40}px`;
                };

                const hideTooltip = () => {
                    const tooltip = document.getElementById('chart-tooltip');
                    if (!tooltip) return;
                    tooltip.style.opacity = '0';
                    setTimeout(() => {
                        tooltip.style.display = 'none';
                    }, 200);
                };

                // Hover effect
                path.addEventListener('mouseenter', (e) => {
                    path.style.filter = 'brightness(1.1)';
                    path.style.transform = 'scale(1.02)';
                    showTooltip(e);
                });
                
                path.addEventListener('mousemove', (e) => {
                    showTooltip(e);
                });
                
                path.addEventListener('mouseleave', () => {
                    path.style.filter = 'none';
                    path.style.transform = 'scale(1)';
                    hideTooltip();
                });

                // Touch events for mobile
                let touchTimeout;
                path.addEventListener('touchstart', (e) => {
                    clearTimeout(touchTimeout);
                    path.style.filter = 'brightness(1.1)';
                    path.style.transform = 'scale(1.02)';
                    showTooltip(e.touches[0]);
                }, { passive: true });
                
                path.addEventListener('touchend', () => {
                    touchTimeout = setTimeout(() => {
                        path.style.filter = 'none';
                        path.style.transform = 'scale(1)';
                        hideTooltip();
                    }, 1000); // Keep tooltip visible for 1.5s after touch
                });

                path.onclick = (e) => {
                    const isHidden = localStorage.getItem('balance_hidden') === 'true';
                    // Update Center Label
                    const percentText = percent.toFixed(1) + '%';
                    document.getElementById('chart-total-label').innerText = seg.name;
                    const valText = `‚Ç±${Math.round(seg.value).toLocaleString()} (${percentText})`;
                    const valEl = document.getElementById('chart-total-val');
                    valEl.dataset.raw = valText;
                    valEl.innerText = isHidden ? '******' : valText;
                    window.highlightTransactions(seg.name);
                };
                
                svgGroup.appendChild(path);

                // Add to legend (Simple style)
                const lItem = document.createElement('div');
                lItem.className = 'legend-item';
                lItem.innerHTML = `
                    <div class="legend-color" style="background: ${seg.color}"></div>
                    <span>${seg.name}</span>
                `;
                legend.appendChild(lItem);

                currentAngle = endAngle;
            });

            // Animation trigger removed as requested (Visibility fix)
        }

        // RENDER ACCORDIONS (OPTIMIZED)
        window.historyLimit = 6;
        function renderHistory(txns) {
            const container = document.getElementById('history-container');
            const fragment = document.createDocumentFragment();
            
            // Check visibility state ONCE at the start for consistency
            const isHidden = localStorage.getItem('balance_hidden') === 'true';
            
            drawTrendChart(txns);

            const groups = {};
            txns.forEach(t => {
                const d = new Date(t.date);
                if (isNaN(d)) return;
                const key = d.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                if (!groups[key]) groups[key] = { items: [], total: 0 };
                
                groups[key].items.push(t);
                const mappedSumCheck = getMerchantDisplay(t.merchant, t);
                if (!t.excluded && !t.refund && !t.reimbursed && mappedSumCheck.category !== 'Income') {
                    const amt = t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0);
                    groups[key].total += amt;
                }
            });

            const entries = Object.entries(groups);
            // Ensure chronological order (descending)
            entries.sort((a, b) => new Date(b[1].items[0].date) - new Date(a[1].items[0].date));
            
            const visibleEntries = entries.slice(0, window.historyLimit);

            visibleEntries.forEach(([month, data], index) => {
                const accordion = document.createElement('div');
                accordion.className = 'month-accordion';
                
                const savedState = localStorage.getItem(`accordion_${month}`);
                const isCollapsed = savedState === 'collapsed' || (savedState === null && index !== 0);
                
                const header = document.createElement('div');
                header.className = `month-header ${isCollapsed ? 'collapsed' : ''}`;
                header.innerHTML = `
                    <span class="month-title">${month}</span>
                    <div style="display:flex; align-items:center; gap:12px;">
                        <span class="month-total privacy-mask" data-raw="‚Ç±${data.total.toLocaleString(undefined, {minimumFractionDigits:2})}">
                            ${isHidden ? '******' : '‚Ç±' + data.total.toLocaleString(undefined, {minimumFractionDigits:2})}
                        </span>
                        <i class="material-icons expand-icon">expand_more</i>
                    </div>
                `;

                
                const content = document.createElement('div');
                content.className = `month-content ${isCollapsed ? 'collapsed' : ''}`;
                
                let contentHTML = '';
                data.items.forEach(t => {
                    const mapped = getMerchantDisplay(t.merchant, t);
                    const isIncome = mapped.category === 'Income';
                    const isRefund = t.refund || false;
                    const isReimbursed = t.reimbursed || false;
                    const excludedClass = t.excluded ? 'txn-excluded' : '';
                    
                    const d = new Date(t.date);
                    const shortDate = d.toLocaleDateString('en-US', { day: '2-digit', month: 'short' });
                    const amount = (t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0));
                    
                    let displayNote = t.note || '';
                    if (!displayNote && mapped.category === 'Vehicle') {
                        displayNote = (amount > 250) ? "Car Refill" : "Motor Refill";
                    }
                    
                    let displayAmtColor = '';
                    let displayTitleColor = '';

                    if (isIncome) {
                        displayAmtColor = 'color: #16a34a;';
                        displayTitleColor = 'color: #16a34a;';
                    } else if (isRefund || isReimbursed) {
                        displayAmtColor = 'color: #f59e0b;';
                        displayTitleColor = 'color: #f59e0b;';
                    } else if (mapped.category === 'Credit Card Payment') {
                        // Credit Card / Atome Specific Styling
                        displayAmtColor = 'color: #f59e0b;'; // Orange Gold
                        displayTitleColor = 'color: #f59e0b;'; // Orange Gold
                    } else {
                        // Expense Logic
                        if (mapped.category === 'Savings') {
                            displayTitleColor = 'color: #16a34a;'; // Bright Green for Title
                        } else if (Math.abs(amount) >= 1000) {
                            displayAmtColor = 'color: #ef4444;'; // Red Red
                        } else if (window.currentAccount === 'bpi') {
                            displayAmtColor = 'color: #991b1b;'; // Dark Red
                        }
                    }
                    let displayName = (mapped.category === 'Credit Card Payment' || isIncome) ? mapped.name : mapped.name;
                    // Note: If merchant was set to 'Atome' in parse, it might be lowercase. 
                    // Let's ensure 'ATOME PAYMENT' is honored if that was the intent.
                    if (mapped.category === 'Credit Card Payment') displayName = 'ATOME PAYMENT';
                    // else if (isIncome) displayName = 'INCOME'; // REMOVED to allow database overrides
                    let refundChip = isRefund ? '<span class="refund-badge" style="display: inline-block; background: #fef3c7; color: #d97706; font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: 4px; margin-left: 6px; letter-spacing: 0.3px;">REFUNDED</span>' : '';
                    let reimbursedChip = isReimbursed ? '<span class="reimbursed-badge">REIMBURSED</span>' : '';
                    
                    // Payment chip for duplicated ATOME PAYMENT from BPI to Atome
                    const isPaymentDuplicate = t.duplicatedFromAccount === 'bpi' && window.currentAccount === 'atome' && mapped.name.toUpperCase().includes('ATOME PAYMENT');
                    const paymentChip = isPaymentDuplicate ? '<span class="payment-badge" style="display: inline-block; background: #d1fae5; color: #059669; font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: 4px; margin-left: 6px; letter-spacing: 0.3px;">PAYMENT</span>' : '';
                    
                    // LOGO DETECTION
                    const mUpper = mapped.name.toUpperCase();
                    let logo = null;
                    if (mUpper.includes('JOLLIBEE')) logo = 'logos/jollibee.png';
                    else if (mUpper.includes('MCDO') || mUpper.includes('MCDONALDS')) logo = 'logos/mcdo.png';
                    else if (mUpper.includes('SHELL')) logo = 'logos/shell.png';
                    else if (mUpper.includes('SHOPEE')) logo = 'logos/shopee.png';
                    else if (mUpper.includes('LAZADA')) logo = 'logos/lazada.jpg';
                    else if (mUpper.includes('GLOBE') || mUpper.includes('GOMO')) logo = 'logos/globe.png';
                    else if (mUpper.includes('SM') || mUpper.includes('SM STORE')) logo = 'logos/sm.png';
                    else if (mUpper.includes('SPOTIFY')) logo = 'logos/spotify.png';
                    else if (mUpper.includes('TIKTOK')) logo = 'logos/tiktokshop.png';
                    else if (mUpper.includes('TECFUEL')) logo = 'logos/tecfuel.png';
                    else if (mUpper.includes('MR DIY')) logo = 'logos/mrdiy.png';
                    else if (mUpper.includes('METRO')) logo = 'logos/supermetro.png';
                    else if (mUpper.includes('7 11')) logo = 'logos/711.png';
                    else if (mUpper.includes('7/11')) logo = 'logos/711.png';
                    else if (mUpper.includes('WATSONS')) logo = 'logos/watsons.png';
                    else if (mUpper.includes('J AND L')) logo = 'logos/jandlmall.png';
                    else if (mUpper.includes('TRADERSCONNECT')) logo = 'logos/tradersconnect.png';
                    
                    const logoHTML = logo ? `<div class="brand-badge" style="display: ${typeof showLogos !== 'undefined' && showLogos ? 'flex' : 'none'}"><img src="${logo}"></div>` : '';

                    const noteSafe = (t.note || '').replace(/"/g, '&quot;');
                    contentHTML += `
                        <div class="txn-swipe-wrapper">
                            <div class="txn-swipe-bg left">DELETE</div>
                            <div class="txn-swipe-bg right" style="${t.excluded ? 'background: #3b82f6;' : 'background: #f59e0b;'}">${t.excluded ? 'INCLUDE' : 'EXCLUDE'}</div>
                            <div class="premium-txn ${excludedClass}" 
                                 data-txn-id="${t.id}" 
                                 data-merchant="${mapped.name.replace(/'/g, "\\'")}" 
                                 data-amount="${amount}"
                                 data-date="${t.date}"
                                 data-manual-amount="${t.manualAmount !== undefined ? t.manualAmount : ''}"
                                 data-category="${mapped.category}"
                                 data-note="${noteSafe}"
                                 data-excluded="${t.excluded || false}"
                                 data-refund="${t.refund || false}"
                                 data-reimbursed="${t.reimbursed || false}">
                                <div class="icon-box ${mapped.catClass}">
                                    <i class="material-icons">${mapped.icon}</i>
                                    ${logoHTML}
                                </div>
                                <div class="txn-details">
                                    <div class="txn-merch" style="${displayTitleColor}">${displayName}${refundChip}${reimbursedChip}${paymentChip}</div>
                                    <div class="txn-sub">
                                        <span>${shortDate}</span> ‚Ä¢ <span>${displayCategoryName(mapped.category)}</span>
                                    </div>
                                    ${displayNote ? `<div class="txn-note" style="color: ${(mapped.category === 'Savings' || mapped.category === 'Income' || mapped.category === 'Life & Entertainment' || mapped.category === 'Sport') ? '#16a34a' : (isRefund || isReimbursed ? '#f59e0b' : (categoryConfig[mapped.category]?.darkColor || '#475569'))}; font-size: 11px; margin-top:2px;">${displayNote}</div>` : ''}
                                </div>
                                <div class="txn-right">
                                    <div class="txn-amount privacy-mask ${Math.abs(amount) >= 1000 ? 'large' : ''}" style="${displayAmtColor}" data-raw="${(!isIncome && !isRefund && !isReimbursed && window.currentAccount !== 'atome') ? '-' : ''}‚Ç±${Math.abs(amount).toLocaleString(undefined, {minimumFractionDigits:2})}">
                                        ${isHidden ? '******' : ((!isIncome && !isRefund && !isReimbursed && window.currentAccount !== 'atome') ? '-' : '') + '‚Ç±' + Math.abs(amount).toLocaleString(undefined, {minimumFractionDigits:2})}
                                    </div>
                                </div>
                            </div>
                        </div>`;
                });
                
                content.innerHTML = contentHTML;
                header.onclick = () => {
                    const isNowCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isNowCollapsed);
                    localStorage.setItem(`accordion_${month}`, isNowCollapsed ? 'collapsed' : 'expanded');
                };
                
                accordion.appendChild(header);
                accordion.appendChild(content);
                fragment.appendChild(accordion);
            });
            
            container.innerHTML = '';
            container.appendChild(fragment);

            // Load More Button
            if (entries.length > window.historyLimit) {
                const loadMoreWrap = document.createElement('div');
                loadMoreWrap.style.cssText = 'padding: 10px 0 40px; text-align: center;';
                const btn = document.createElement('button');
                btn.className = 'load-more-btn'; // Hook for CSS
                btn.style.cssText = 'display: inline-flex; align-items: center; justify-content: center; gap: 8px; color: #000; font-weight: 800; font-size: 11px; letter-spacing: 0.5px; text-transform: uppercase; background: #ebf5ff; border: none; border-radius: 25px; padding: 12px 32px; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 12px rgba(29, 78, 216, 0.08);';
                btn.innerHTML = '<span>Load More</span><i class="material-icons" style="font-size: 20px;">keyboard_arrow_down</i>';
                
                btn.onclick = () => {
                    btn.innerHTML = '<i class="material-icons spin" style="font-size: 20px;">sync</i>';
                    btn.style.opacity = '0.7';
                    btn.style.pointerEvents = 'none';
                    setTimeout(() => {
                        window.historyLimit += 6;
                        renderHistory(window.allTxns);
                    }, 400);
                };
                
                btn.onmouseenter = () => { btn.style.background = '#dbeafe'; btn.style.transform = 'translateY(-1px)'; };
                btn.onmouseleave = () => { btn.style.background = '#ebf5ff'; btn.style.transform = 'translateY(0)'; };
                
                loadMoreWrap.appendChild(btn);
                container.appendChild(loadMoreWrap);
            }

            // Re-apply search if it was active
            if ((document.getElementById('txn-search')?.value || '') !== '' || document.getElementById('txn-cat-filter').value !== 'all') {
                filterTxnList();
            }

            setTimeout(() => setupLongPressHandlers(), 50);

            // CRITICAL FIX: Force update all privacy-masked elements after rendering
            // This ensures that when switching wallets, the privacy state is respected
            if (isHidden) {
                setTimeout(() => {
                    const maskedElements = document.querySelectorAll('.privacy-mask');
                    maskedElements.forEach(el => {
                        if (!el.dataset.raw) el.dataset.raw = el.innerText;
                        el.innerText = '******';
                    });
                }, 10);
            }

            // FEATURE UPDATES (NEW)
            updateBudgetUI();
            drawCashFlowChart();
            detectSubscriptions();
            updateCategoryBudgetsUI();
        }

        // CATEGORY BUDGET LIMITER LOGIC
        let selectedBudgetCatId = null;

        window.updateCategoryBudgetsUI = async () => {
            const widget = document.getElementById('cat-budget-widget');
            const listContainer = document.getElementById('cat-budget-list');
            const account = window.currentAccount;
            const uid = auth.currentUser?.uid;

            if (!uid || !widget || !listContainer) return;

            // Only show for main wallets and Atome
            const visibleAccounts = ['atome', 'bpi', 'default_wallet'];
            if (!visibleAccounts.includes(account)) {
                widget.style.display = 'none';
                return;
            }
            widget.style.display = 'block';

            // Get limits from Firestore
            const budgetRef = doc(db, "users", uid, "config", `budgets_${account}`);
            const docSnap = await getDoc(budgetRef).catch(() => null);
            let budgets = (docSnap && docSnap.exists()) ? docSnap.data().categories : null;

            // Default Testing Limits for Atome
            if (!budgets && account === 'atome') {
                budgets = {
                    'Shopping': 1000,
                    'Online shopping': 2000,
                    'Vehicle': 2000
                };
                await setDoc(budgetRef, { categories: budgets }, { merge: true });
            }

            if (!budgets || Object.keys(budgets).length === 0) {
                listContainer.innerHTML = '<div style="text-align:center; padding:30px 20px; color:#94a3b8; font-size:12px; font-weight:600; border: 1px dashed #e2e8f0; border-radius: 16px;">No category limits set.<br>Click ADD to start budgeting.</div>';
                return;
            }

            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth();

            const itemsHTML = Object.entries(budgets).map(([cat, limit]) => {
                // Calculate spent for this category THIS MONTH
                let spent = 0;
                if (window.allTxns) {
                    window.allTxns.forEach(t => {
                        const d = new Date(t.date);
                        // USER REQUEST: Monthly filter - budgets reset each month
                        if (d.getFullYear() === year && d.getMonth() === month && !t.excluded && !t.refund && !t.reimbursed) {
                            const mapped = getMerchantDisplay(t.merchant, t);
                            const itemCatLabel = displayCategoryName(mapped.category);
                            if (mapped.category === cat || itemCatLabel === cat) {
                                spent += Math.abs(t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0));
                            }
                        }
                    });
                }

                const percent = Math.min((spent / limit) * 100, 100);
                
                // Dynamic Font Color Logic
                let spentColor = ''; // Default
                if (percent >= 90) spentColor = 'color: #ef4444;'; // Red
                else if (percent >= 75) spentColor = 'color: #f97316;'; // Orange
                else if (percent < 50) spentColor = 'color: #10b981;'; // Green

                let statusClass = '';
                if (percent >= 90) statusClass = 'high';
                else if (percent >= 75) statusClass = 'mid';
                else if (percent >= 50) statusClass = 'low';

                const catInfo = CATEGORIES.find(c => c.id === cat) || CATEGORIES.find(c => c.label === cat) || { id: cat, icon: 'category', color: '#64748b' };
                const displayLabel = catInfo.label || cat;

                const spentDisplay = (() => {
                    const isHidden = localStorage.getItem('balance_hidden') === 'true';
                    if (isHidden) return '******';
                    
                    const spentStr = Math.round(spent).toLocaleString();
                    if (spent <= limit) return `‚Ç±${spentStr}`;

                    // NEW Rule:
                    // 1. If OVERSPEND is 1000 or more: Everything turns RED (PHP symbol, Commas, Digits)
                    if ((spent - limit) >= 1000) {
                        return `<span style="color: #ef4444;">‚Ç±${spentStr}</span>`;
                    }

                    // 2. Minor Overspend (< 1000): Partial coloring
                    // PHP symbol and Commas are gray. Matching leading digits are gray.
                    const limitStr = Math.round(limit).toLocaleString();
                    const sDigits = spentStr.replace(/[^\d]/g, '');
                    const lDigits = limitStr.replace(/[^\d]/g, '').padStart(sDigits.length, '0');
                    
                    let result = '<span style="color: #94a3b8;">‚Ç±</span>';
                    let mismatchStarted = false;
                    
                    for (let i = 0, dIdx = 0; i < spentStr.length; i++) {
                        const char = spentStr[i];
                        if (/\d/.test(char)) {
                            const limitDigit = lDigits[dIdx];
                            
                            if (!mismatchStarted && parseInt(char) > parseInt(limitDigit)) {
                                mismatchStarted = true;
                            }
                            
                            if (mismatchStarted) {
                                result += `<span style="color: #ef4444;">${char}</span>`;
                            } else {
                                result += `<span style="color: #94a3b8;">${char}</span>`;
                            }
                            dIdx++;
                        } else {
                            // Commas and separators stay gray in minor overspend
                            result += `<span style="color: #94a3b8;">${char}</span>`;
                        }
                    }
                    return result;
                })();

                return `
                    <div class="cat-budget-item" onclick="handleCatClick(event, '${cat}')" data-cat="${cat}">
                        <div class="cat-budget-info">
                            <div class="cat-budget-name-group">
                                <div class="cat-budget-icon-box ${catInfo.cls || ''}" style="width: 32px; height: 32px; border-radius: 8px; display: flex; align-items: center; justify-content: center; border: 1px solid rgba(0,0,0,0.03);">
                                    <i class="material-icons" style="font-size: 18px;">${catInfo.icon}</i>
                                </div>
                                <span class="cat-budget-name">${displayLabel}</span>
                            </div>
                            <div class="cat-budget-values">
                                <span class="privacy-mask" style="${spentColor}" data-raw="‚Ç±${Math.round(spent).toLocaleString()}">
                                    ${spentDisplay}
                                </span>
                                <span class="budget-sep">/</span>
                                <span style="color: #64748b;">‚Ç±${Math.round(limit).toLocaleString()}</span>
                            </div>
                        </div>
                        <div class="cat-budget-progress-bg">
                            <div class="cat-budget-progress-fill ${statusClass}" style="width: ${percent}%;"></div>
                        </div>
                    </div>
                `;
            }).join('');

            listContainer.innerHTML = itemsHTML;
        };

        window.handleCatClick = async (e, category) => {
            if (e) e.preventDefault();
            
            const choice = await showAppDialog({
                title: category,
                message: 'Manage monthly budget limit.',
                confirm: false,
                customActions: [
                    { label: 'EDIT', value: 'edit' },
                    { label: 'REMOVE', value: 'remove', class: 'danger' }
                ]
            });

            if (choice === 'edit') {
                editCategoryBudget(category);
            } else if (choice === 'remove') {
                const confirmed = await showAppDialog({
                    title: 'Remove Limit',
                    message: `Stop tracking monthly budget for ${category}?`,
                    confirm: true
                });
                
                if (confirmed) {
                    const account = window.currentAccount;
                    const uid = auth.currentUser.uid;
                    const budgetRef = doc(db, "users", uid, "config", `budgets_${account}`);
                    const docSnap = await getDoc(budgetRef);
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        delete data.categories[category];
                        await setDoc(budgetRef, { categories: data.categories });
                        showToast(`${category} budget removed`);
                        updateCategoryBudgetsUI();
                    }
                }
            }
        };

        window.editCategoryBudget = async (category) => {
            const account = window.currentAccount;
            const uid = auth.currentUser.uid;
            const budgetRef = doc(db, "users", uid, "config", `budgets_${account}`);
            const docSnap = await getDoc(budgetRef);
            
            if (docSnap.exists()) {
                const currentLimit = docSnap.data().categories[category] || 0;
                
                const amountInput = document.getElementById('budget-cat-amount');
                const saveBtn = document.getElementById('save-cat-budget-btn');
                const title = document.getElementById('cat-budget-modal-title');
                const selectionArea = document.getElementById('cat-budget-selection-area');
                
                title.innerText = `Edit ${category} Limit`;
                amountInput.value = currentLimit;
                if (selectionArea) selectionArea.style.display = 'none';
                
                document.getElementById('cat-budget-modal').classList.add('show');
                document.querySelector('.mobile-wrapper')?.classList.add('blur-active');
                
                saveBtn.onclick = async () => {
                    const limit = parseFloat(amountInput.value);
                    if (isNaN(limit) || limit <= 0) return showToast('Enter a valid amount');

                    const budgets = docSnap.data().categories;
                    budgets[category] = limit;

                    await setDoc(budgetRef, { categories: budgets }, { merge: true });
                    showToast(`Updated ${category} budget`);
                    closeModals();
                    updateCategoryBudgetsUI();
                };
            }
        };

        window.promptAddCategoryBudget = () => {
            const grid = document.getElementById('budget-cat-grid');
            const amountInput = document.getElementById('budget-cat-amount');
            const saveBtn = document.getElementById('save-cat-budget-btn');
            
            amountInput.value = '';
            selectedBudgetCatId = null;
            
            // Populate Category Grid
            grid.innerHTML = CATEGORIES.filter(c => c.id !== 'Income').map(cat => {
                // Force Green for Savings
                const isSavings = cat.id === 'Savings';
                const labelColor = isSavings ? '#15803d' : '#64748b';
                
                return `
                <div class="cat-option" id="btn-budget-cat-${cat.id.replace(/\s+/g, '-')}" onclick="selectBudgetCategory('${cat.id}')" style="padding: 12px 4px; gap: 8px; border-radius: 16px;">
                    <div class="cat-budget-icon-box ${cat.cls || ''}" style="width: 40px; height: 40px; border-radius: 12px; display: flex; align-items: center; justify-content: center; border: 1px solid rgba(0,0,0,0.03);">
                        <i class="material-icons" style="font-size: 20px;">${cat.icon}</i>
                    </div>
                    <span style="font-size: 10px; font-weight: 800; text-transform: uppercase; color: ${labelColor}; letter-spacing: 0.2px; text-align: center;">${cat.label}</span>
                </div>
                `;
            }).join('');

            document.getElementById('cat-budget-modal-title').innerText = 'Category Limit';
            const selectionArea = document.getElementById('cat-budget-selection-area');
            if (selectionArea) selectionArea.style.display = 'block';

            document.getElementById('cat-budget-modal').classList.add('show');
            document.querySelector('.mobile-wrapper')?.classList.add('blur-active');
            document.querySelector('.fab')?.classList.add('blur-active');
            document.querySelector('.bottom-nav')?.classList.add('blur-active');
            setTimeout(() => amountInput.focus(), 300);

            saveBtn.onclick = async () => {
                if (!selectedBudgetCatId) return showToast('Please select a category');
                const limit = parseFloat(amountInput.value);
                if (isNaN(limit) || limit <= 0) return showToast('Enter a valid amount');

                const account = window.currentAccount;
                const uid = auth.currentUser.uid;
                const budgetRef = doc(db, "users", uid, "config", `budgets_${account}`);
                
                const docSnap = await getDoc(budgetRef).catch(() => null);
                let budgets = (docSnap && docSnap.exists()) ? docSnap.data().categories : {};
                budgets[selectedBudgetCatId] = limit;

                await setDoc(budgetRef, { categories: budgets }, { merge: true });
                showToast(`Budget set for ${selectedBudgetCatId}`);
                closeModals();
                updateCategoryBudgetsUI();
            };
        };

        window.selectBudgetCategory = (catId) => {
            selectedBudgetCatId = catId;
            document.querySelectorAll('#budget-cat-grid .cat-option').forEach(el => el.classList.remove('active'));
            const activeEl = document.getElementById(`btn-budget-cat-${catId.replace(/\s+/g, '-')}`);
            if (activeEl) activeEl.classList.add('active');
        };

        // PROFILE DROPDOWN LOGIC
        window.toggleProfileDropdown = (e) => {
            e.stopPropagation();
            const dropdown = document.getElementById('profile-dropdown');
            dropdown.classList.toggle('active');
            
            // Refresh biometric status when opening
            if (dropdown.classList.contains('active') && typeof window.updateBiometricStatus === 'function') {
                window.updateBiometricStatus();
            }
        };

        // Close dropdown when clicking elsewhere
        window.addEventListener('click', (e) => {
            const dropdown = document.getElementById('profile-dropdown');
            if (dropdown && dropdown.classList.contains('active')) {
                const badge = document.getElementById('profile-badge');
                if (!badge.contains(e.target)) {
                    dropdown.classList.remove('active');
                }
            }
            
            // PIE CHART TOOLTIP CLOSE ON OUTSIDE TAP
            const tooltip = document.getElementById('chart-tooltip');
            if (tooltip && tooltip.style.opacity === '1') {
                const isSegment = e.target.classList.contains('chart-segment') || e.target.classList.contains('pie-animate');
                if (!isSegment) {
                    tooltip.style.opacity = '0';
                    setTimeout(() => { tooltip.style.display = 'none'; }, 200);
                }
            }
        });
 
        // HIDE CHART TOOLTIP ON SCROLL
        document.querySelector('.mobile-wrapper')?.addEventListener('scroll', () => {
            const tooltip = document.getElementById('chart-tooltip');
            if (tooltip && tooltip.style.opacity === '1') {
                tooltip.style.opacity = '0';
                setTimeout(() => { tooltip.style.display = 'none'; }, 200);
            }
        }, { passive: true });

        window.handleSignout = async () => {
            if (confirm('Sign out?')) {
                log('üö® Initiating deep sign-out and data purge...');
                
                // Detach realtime listener
                if (window.unsubscribeSnapshot) {
                    window.unsubscribeSnapshot();
                    window.unsubscribeSnapshot = null;
                }

                localStorage.clear();
                window.allTxns = [];
                const historyContainer = document.getElementById('history-container');
                const logContainer = document.getElementById('log-container');
                if (historyContainer) historyContainer.innerHTML = '';
                if (logContainer) logContainer.innerHTML = '';
                
                try {
                    await auth.signOut();
                    // Hard reload to flush all memory states and clear persistence
                    window.location.href = window.location.origin + window.location.pathname + '?logout=true&t=' + Date.now();
                } catch (e) {
                    log('Sign out error: ' + e.message, 'error');
                }
            }
        };

        const getBody = (payload) => {
            let body = "";
            if (payload.body && payload.body.data) {
                const b64 = payload.body.data.replace(/-/g, '+').replace(/_/g, '/');
                try {
                    // Standard way to handle UTF-8 in base64
                    body = decodeURIComponent(escape(atob(b64)));
                } catch(e) { body = atob(b64); }
            } else if (payload.parts) {
                payload.parts.forEach(part => {
                    body += getBody(part);
                });
            }
            return body;
        };

        const stripTags = (html) => {
            if (!html) return "";
            return html.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
                       .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
                       .replace(/<br\s*\/?>/gi, '\n')
                       .replace(/<\/p>| <\/div>|<\/tr>/gi, '\n')
                       .replace(/<\/td>/gi, ' | ')
                       .replace(/<[^>]*>/g, ' ')
                       .replace(/[ \t]+/g, ' ')
                       .replace(/\n\s+/g, '\n')
                       .trim();
        };

        // GMAIL SCAN (OPTIMIZED WITH PARALLELISM + CONCURRENCY GUARD)
        window.isSyncing = false; // Persistent flag
        window.handleScan = async (limit, manualTrigger = false) => {
            if (window.isSyncing) {
                console.log('üîÑ Sync already in progress. Skipping...');
                return;
            }
            
            const syncAccount = window.currentAccount;
            
            // BLOCK EMAIL SYNC FOR REGULAR WALLETS: Only BPI and Atome accounts can sync with Gmail
            const allowedSyncAccounts = ['bpi', 'atome'];
            if (!allowedSyncAccounts.includes(syncAccount)) {
                console.log(`üö´ Email sync blocked for regular wallet: ${syncAccount}`);
                if (manualTrigger) {
                    showToast('Email sync is only available for BPI and Atome accounts');
                }
                return;
            }

            // SMART TOKEN VALIDATION: Try existing token first, auto-refresh on 401
            // Instead of rejecting tokens after 50 min, let the API tell us via 401
            const storedToken = localStorage.getItem('g_access_token');
            
            if (storedToken) {
                console.log('üöÄ Using stored Gmail token (will auto-refresh on 401)...');
                accessToken = storedToken;
            } else if (!storedToken) {
                // No token at all ‚Äî need to authenticate
                if (!manualTrigger) return;
                
                if (tokenClient) {
                    console.log('üîë No token found. Requesting authentication...');
                    window.pendingSyncLimit = limit;
                    window.pendingSyncManual = manualTrigger;
                    tokenClient.requestAccessToken({ prompt: '' });
                    return;
                }
            }

            window.isSyncing = true;
            
            const activeCard = document.querySelector(`.balance-card[data-account="${window.currentAccount}"]`);
            const btn = activeCard ? activeCard.querySelector('.scan-btn') : null;
            const statusText = activeCard ? activeCard.querySelector('.syncStatusText') : null;
            const originalHTML = btn ? btn.innerHTML : '';

            if (btn) {
                btn.disabled = true;
                btn.innerHTML = '<i class="material-icons spin" style="font-size:12px;">sync</i>';
            }
            if (statusText) statusText.innerText = 'Syncing';
            
            try {
                log(`Syncing ${syncAccount.toUpperCase()}...`);
                
                // MULTI-ACCOUNT QUERY
                let query = '';
                if (syncAccount === 'atome') {
                    // Broader Atome Query
                    query = `(subject:"Transaction Confirmation" OR subject:"payment confirmation" OR subject:"Atome Card") (from:Atome OR from:no-reply@atome.ph OR from:noreply@atome.ph)`;
                } else {
                    // BPI Query
                    query = `(subject:"Funds Transfer" OR subject:"Fund Transfer" OR subject:"Interbank" OR subject:"Pay via QR" OR from:bpi_online@bpi.com.ph OR from:onlinebanking@bpi.com.ph OR from:bpiinstapay@bpi.com.ph OR from:BPI)`;
                }
                
                log(`Scanning ${syncAccount} (Target Limit: ${limit})...`);
                
                let savedCount = 0;
                let pageToken = '';
                let totalProcessed = 0;

                // Loop for pagination if limit > 500
                while (totalProcessed < limit) {
                    const maxResults = Math.min(500, limit - totalProcessed);
                    let url = `https://gmail.googleapis.com/gmail/v1/users/me/messages?maxResults=${maxResults}&q=${encodeURIComponent(query)}`;
                    if (pageToken) url += `&pageToken=${pageToken}`;

                    const res = await fetch(url, { headers: { 'Authorization': `Bearer ${accessToken}` }});
                    
                    if (res.status === 401) {
                        console.warn('üö´ Gmail Token expired.');
                        window.isSyncing = false;
                        
                        // Clear the expired token so we don't keep retrying with it
                        localStorage.removeItem('g_access_token');
                        accessToken = null;
                        
                        // TOKEN REFRESH LOCK: Prevent popup storms
                        const now = Date.now();
                        if (tokenRefreshInProgress || (now - lastTokenRefreshAttempt) < TOKEN_REFRESH_COOLDOWN) {
                            console.log('üîá Token refresh already in progress or on cooldown. Skipping.');
                            throw new Error('Unauthorized - Refresh throttled');
                        }
                        
                        if (tokenClient) {
                            tokenRefreshInProgress = true;
                            lastTokenRefreshAttempt = now;
                            window.pendingSyncLimit = limit;
                            window.pendingSyncManual = manualTrigger;
                            // FIX 3: Mark that this refresh was triggered by a 401,
                            // so the GIS callback doesn't re-trigger handleScan (breaking the loop)
                            window.refreshTriggeredBy401 = true;
                            // ALWAYS silent ‚Äî never open a visible popup automatically
                            window.isSilentRefresh = true;
                            console.log('üîÑ Attempting ONE silent token refresh...');
                            tokenClient.requestAccessToken({ prompt: 'none' });
                        }
                        throw new Error('Unauthorized - Silent refresh attempted');
                    }
                    
                    const data = await res.json();
                    const msgs = data.messages || [];
                    pageToken = data.nextPageToken;

                    if (msgs.length === 0) break;

                    // OPTIMIZED BATCH WRITES: Use Firestore writeBatch for bulk commits
                    const fetchBatchSize = 10;
                    for (let i = 0; i < msgs.length; i += fetchBatchSize) {
                        const batch = msgs.slice(i, i + fetchBatchSize);
                        
                        // Fetch email details in parallel
                        const txnsToWrite = [];
                        const promises = batch.map(async (m) => {
                            try {
                                const detailRes = await fetch(`https://gmail.googleapis.com/gmail/v1/users/me/messages/${m.id}`, { headers: { 'Authorization': `Bearer ${accessToken}` }});
                                const d = await detailRes.json();
                                
                                let txn = null;
                                const fullBody = getBody(d.payload);
                                const cleanText = stripTags(fullBody) || d.snippet;

                                if (syncAccount === 'atome') {
                                    txn = parseAtomeEmail(cleanText, d.internalDate);
                                } else {
                                    const subjectHeader = d.payload.headers.find(h => h.name.toLowerCase() === 'subject');
                                    const subject = subjectHeader ? subjectHeader.value : '';
                                    txn = parseBPIEmail(cleanText, d.internalDate, subject);
                                }

                                if (txn) {
                                    if (!auth.currentUser) await signInAnonymously(auth);
                                    const uid = auth.currentUser.uid;
                                    const collectionName = getCollectionName(syncAccount);
                                    const docRef = doc(db, "users", uid, collectionName, txn.id);
                                    
                                    const snap = await getDoc(docRef);
                                    if (!snap.exists()) {
                                        return { txn, docRef, uid };
                                    }
                                }
                            } catch (err) { return null; }
                            return null;
                        });
                        
                        const results = await Promise.all(promises);
                        const validTxns = results.filter(Boolean);
                        
                        if (validTxns.length > 0) {
                            // BATCH WRITE: Commit all new transactions at once
                            const firestoreBatch = writeBatch(db);
                            const uid = validTxns[0].uid;
                            
                            for (const {txn, docRef} of validTxns) {
                                firestoreBatch.set(docRef, { ...txn, deleted: false, createdAt: serverTimestamp() });
                                
                                // USER REQUEST 2026: Automatic duplicate BPI "Atome Payment" to Atome
                                const merchantLower = txn.merchant?.toLowerCase() || '';
                                const categoryLower = txn.manualCategory?.toLowerCase() || '';
                                const isAtomePayment = merchantLower.includes('atome') || categoryLower.includes('credit card payment');

                                if (syncAccount === 'bpi' && isAtomePayment) {
                                    const atomeCol = getCollectionName('atome');
                                    const atomeTxnId = 'auto_' + txn.id;
                                    const atomeDocRef = doc(db, "users", uid, atomeCol, atomeTxnId);

                                    try {
                                        const atomeSnap = await getDoc(atomeDocRef);
                                        if (!atomeSnap.exists()) {
                                            log(`Auto-duplicating ${txn.merchant} to Atome wallet...`);
                                            const atomeTxn = {
                                                ...txn,
                                                id: atomeTxnId,
                                                amount: Math.abs(txn.amount),
                                                manualAmount: txn.manualAmount !== undefined ? Math.abs(txn.manualAmount) : undefined,
                                                manualCategory: 'Income',
                                                note: (txn.note || '') + ' (BPI Sync)',
                                                duplicatedFrom: txn.id,
                                                duplicatedFromAccount: 'bpi'
                                            };
                                            firestoreBatch.set(atomeDocRef, { ...atomeTxn, deleted: false, createdAt: serverTimestamp() });
                                        }
                                    } catch (e) {
                                        console.error("Auto-duplicate check failed", e);
                                    }
                                }
                            }
                            
                            await firestoreBatch.commit();
                            savedCount += validTxns.length;
                            console.log(`‚úÖ Batch committed ${validTxns.length} transactions`);
                        }
                    }
                    
                    totalProcessed += msgs.length;
                    if (!pageToken) break; 
                }
                
                if (savedCount > 0) {
                    // Update sync timestamps
                    const now = Date.now();
                    localStorage.setItem(`last_quick_sync_${syncAccount}`, now);
                    if (limit >= 400) {
                        localStorage.setItem(`last_deep_sync_${syncAccount}`, now);
                    }
                    
                    // Final sanity check before reloading data
                    if (window.currentAccount !== syncAccount) {
                        log("Sync finished but account changed. Data saved to cloud.");
                        return;
                    }
                    if (limit > 100) localStorage.setItem(`last_deep_sync_${syncAccount}`, Date.now());
                    log(`Sync complete! +${savedCount} processed.`, 'success');
                    await loadData();
                } else {
                    log('Sync complete. No new valid txns found.');
                }
            } catch (e) { log('Scan error: ' + e.message, 'error'); }
            finally {
              window.isSyncing = false;
              // Re-query in case the DOM was refreshed during the sync
              const finalCard = document.querySelector(`.balance-card[data-account="${syncAccount}"]`);
              const finalBtn = finalCard ? finalCard.querySelector('.scan-btn') : null;
              const finalStatusText = finalCard ? finalCard.querySelector('.syncStatusText') : null;

              if (finalBtn) {
                  finalBtn.disabled = false;
                  // Try to restore original icon or use a safe default
                  finalBtn.innerHTML = '<i class="material-icons">sync</i>';
              }
              if (finalStatusText) finalStatusText.innerText = 'Synced';
            }
        };

        function parseAtomeEmail(text, ts) {
            // Updated Atome Regex to handle stripped HTML and different wordings
            const amtMatch = text.match(/payment\s+of[^\d]*([\d,]+\.?\d*)/i) || text.match(/amount[^\d]*([\d,]+\.?\d*)/i);
            const merchMatch = text.match(/for\s+([^,]+?)\s+using/i) || text.match(/at\s+([^,]+?)\s+(?:using|on)/i);
            
            if (!amtMatch) return null;
            
            return {
                id: 'txn_' + ts,
                amount: parseFloat(amtMatch[1].replace(/,/g, '')),
                merchant: merchMatch ? merchMatch[1].trim() : "Atome Transaction",
                date: formatLocalDate(parseInt(ts))
            };
        }

        function parseBPIEmail(text, ts, subject) {
            let amount = 0;
            let merchant = "BPI Transfer";
            let note = "";
            let isIncome = false;
            let category = "Financial Expenses";
            let dateVal = formatLocalDate(parseInt(ts));

            const tLower = text.toLowerCase();
            const sLower = subject.toLowerCase();

            // EXCLUSION: Skip marketing
            if (tLower.includes("never ask for your bank details") && !tLower.includes("confirmation number")) return null;

            // 1. Detect Amount & Fees
            let fee = 0;
            const feeMatch = text.match(/(?:Service Fee|Fee)\s*\|\s*PHP\s*([\d,]+\.\d{2})/i) || 
                             text.match(/(?:Service Fee|Fee):\s*‚Ç±?([\d,]+\.\d{2})/i);
            if (feeMatch) {
                fee = parseFloat(feeMatch[1].replace(/,/g, ''));
                console.log(`BPI Fee detected: ${fee}`);
            }

            const totalAmtMatch = text.match(/Total Amount\s*\|\s*PHP\s*([\d,]+\.\d{2})/i) ||
                                  text.match(/Total Amount:\s*‚Ç±?([\d,]+\.\d{2})/i);
            
            const baseAmtMatch = text.match(/(?:Transfer Amount|Amount)\s*\|\s*PHP\s*([\d,]+\.\d{2})/i) ||
                                 text.match(/(?:Transfer Amount|Amount):\s*‚Ç±?([\d,]+\.\d{2})/i) ||
                                 text.match(/(?:PHP|PHP\s|P|‚Ç±)\s?([\d,]+\.\d{2})/i);

            if (totalAmtMatch) {
                amount = parseFloat(totalAmtMatch[1].replace(/,/g, ''));
                console.log(`BPI Total Amount used: ${amount}`);
            } else if (baseAmtMatch) {
                amount = parseFloat(baseAmtMatch[1].replace(/,/g, ''));
                // If fee is found separately and "Total Amount" isn't present, add it
                if (fee > 0 && !text.includes("Total Amount")) {
                    console.log(`BPI Adding fee ${fee} to base amount ${amount}`);
                    amount += fee;
                }
            }

            if (amount === 0) return null;

            // 2. Detect Date from Body
            const dateMatch = text.match(/Transaction Date and Time\s+(?:\|\s*)?([^;\n\r|]+)/i) || 
                              text.match(/Date and Time\s+(?:\|\s*)?([^;\n\r|]+)/i);
            if (dateMatch) {
                const parsedDate = new Date(dateMatch[1].trim());
                if (!isNaN(parsedDate)) dateVal = formatLocalDate(parsedDate);
            }

            // 3. SPECIAL DETECTION: ATOME PAYMENTS & AUB
            const payToMatch = text.match(/Pay To\s*\|\s*([^|\n\r]+)/i) || text.match(/To\s*\|\s*([^|\n\r]+)/i);
            const bankNameMatch = text.match(/Bank Name\s*\|\s*([^|\n\r]+)/i) || text.match(/Bank\s*\|\s*([^|\n\r]+)/i);
            const refNoMatch = text.match(/Transaction Ref No\.\s*\|\s*([A-Z0-9]+)/i);

            const isAtome = (payToMatch && payToMatch[1].toLowerCase().includes("atome")) || 
                            (sLower.includes("pay atome")) ||
                            (bankNameMatch && (
                                bankNameMatch[1].toLowerCase().includes("aub") || 
                                bankNameMatch[1].toLowerCase().includes("asia united bank") ||
                                bankNameMatch[1].toLowerCase().includes("asian bank united")
                            ));

            if (isAtome) {
                merchant = "ATOME PAYMENT";
                category = "Credit Card Payment";
                if (refNoMatch) note = "Ref No: " + refNoMatch[1].trim();
                else if (bankNameMatch) note = "Ref No: " + bankNameMatch[1].trim(); 
            } else if (sLower.includes("incoming") || tLower.includes("incoming") || tLower.includes("you have an incoming") || text.includes("Incoming Funds") || text.includes("received a transfer")) {
                // 4. INCOME
                isIncome = true;
                merchant = "INCOME"; 
                category = "Income";
                const bankMatch = bankNameMatch || text.match(/Transfer From\s*(?:\|\s*)?([^|\n\r]+)/i);
                if (bankMatch) note = "FROM " + bankMatch[1].trim().toUpperCase();
            } else if (tLower.includes("transfer money") || sLower.includes("interbank") || sLower.includes("funds transfer") || sLower.includes("fund transfer") || payToMatch || text.includes("successfully submitted your")) {
                // 5. OUTGOING PAYMENTS
                isIncome = false;
                merchant = "PAYMENT";
                category = "Financial Expenses";
                
                let bank = bankNameMatch ? bankNameMatch[1].trim() : "";

                // USER REQUEST: STRICT NOTES "TO [BANK]"
                if (bank) {
                    note = "TO " + bank.toUpperCase();
                } else {
                    // Internal BPI transfers don't show "Bank Name", so default to BPI
                    note = "TO BPI";
                }
            }

            return {
                id: 'bpi_' + ts,
                amount: amount,
                merchant: merchant,
                note: note,
                date: dateVal,
                manualCategory: category
            };
        }

        // iOS-STYLE LONG-PRESS MENU
        let longPressTimer = null;
        let currentElevatedItem = null;
        let clonedItem = null;
        
        function setupLongPressHandlers() {
            document.querySelectorAll('.premium-txn').forEach(item => {
                const wrapper = item.closest('.txn-swipe-wrapper');
                const bgLeft = wrapper ? wrapper.querySelector('.txn-swipe-bg.left') : null;
                const bgRight = wrapper ? wrapper.querySelector('.txn-swipe-bg.right') : null;

                // Remove old event listeners by cloning
                const newItem = item.cloneNode(true);
                item.parentNode.replaceChild(newItem, item);
                
                let startX, startY;
                let isSwiping = false;
                let swipeDirection = null; // 'left' or 'right'
                
                const startTouch = (e) => {
                    startX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                    startY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                    isSwiping = false;
                    swipeDirection = null;
                    newItem.style.transition = 'none';

                    longPressTimer = setTimeout(() => {
                        if (!isSwiping) showIOSMenu(newItem, e);
                    }, 400);
                };
                
                const moveTouch = (e) => {
                    if (!startX || !startY) return;
                    const currentX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                    const currentY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                    
                    const diffX = currentX - startX;
                    const diffY = currentY - startY;

                    // Detect swipe vs scroll vs long-press
                    if (!isSwiping && Math.abs(diffX) > 10 && Math.abs(diffX) > Math.abs(diffY)) {
                        isSwiping = true;
                        if (longPressTimer) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                        }
                    }

                    if (isSwiping) {
                        // Prevent page scroll if swiping
                        if (e.cancelable) e.preventDefault();

                        // Limit swipe distance
                        const moveX = Math.max(-120, Math.min(120, diffX));
                        newItem.style.transform = `translateX(${moveX}px)`;

                        // Show/hide background labels
                        if (bgLeft) bgLeft.classList.toggle('active', moveX < -10);
                        if (bgRight) bgRight.classList.toggle('active', moveX > 10);
                    } else if (Math.sqrt(diffX*diffX + diffY*diffY) > 10) {
                        if (longPressTimer) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                        }
                    }
                };
                
                const endTouch = (e) => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }

                    if (isSwiping) {
                        const currentX = e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
                        const diffX = currentX - startX;
                        newItem.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';

                        if (diffX < -80) {
                            // SWIPE LEFT -> DELETE MODAL
                            const txnId = newItem.dataset.txnId;
                            if (typeof openDeleteModal === 'function') {
                                openDeleteModal(txnId);
                                newItem.style.transform = 'translateX(0)';
                            }
                        } else if (diffX > 80) {
                            // SWIPE RIGHT -> EXCLUDE
                            const txnId = newItem.dataset.txnId;
                            const isExcluded = newItem.dataset.excluded === 'true';
                            const merch = newItem.dataset.merchant || '';
                            if (typeof toggleExclusion === 'function') toggleExclusion(txnId, merch, isExcluded);
                            newItem.style.transform = 'translateX(0)';
                        } else {
                            // SNAP BACK
                            newItem.style.transform = 'translateX(0)';
                        }

                        // Hide BGs
                        setTimeout(() => {
                            if (bgLeft) bgLeft.classList.remove('active');
                            if (bgRight) bgRight.classList.remove('active');
                        }, 300);
                    }

                    startX = null;
                    startY = null;
                    isSwiping = false;
                };
                
                newItem.addEventListener('mousedown', startTouch);
                newItem.addEventListener('touchstart', startTouch, { passive: true });
                newItem.addEventListener('mouseup', endTouch);
                newItem.addEventListener('touchend', endTouch);
                newItem.addEventListener('mousemove', moveTouch);
                newItem.addEventListener('touchmove', moveTouch, { passive: false }); // Needs false to prevent scroll
                newItem.addEventListener('mouseleave', endTouch);
            });
        }
        
        function showIOSMenu(item, event) {
            if (event.cancelable) event.preventDefault();

            // Haptic feedback if available (Mobile feel)
            if (navigator.vibrate) navigator.vibrate(50);
            
            const txnId = item.dataset.txnId;
            const merchant = item.dataset.merchant || '';
            const amount = parseFloat(item.dataset.amount) || 0;
            const isExcluded = item.dataset.excluded === 'true';
            const category = item.dataset.category || '';
            const note = item.dataset.note || '';
            const isRefund = item.dataset.refund === 'true';
            const isReimbursed = item.dataset.reimbursed === 'true';
            const date = item.dataset.date || '';
            const manualAmount = item.dataset.manualAmount || '';
            
            // 1. Get exact position
            const rect = item.getBoundingClientRect();
            
            // 2. Hide original item visually but keep space
            currentElevatedItem = item;
            item.classList.add('popped'); // Scale up the original item too for the "pop" feel
            item.style.visibility = 'hidden';
            
            // 3. Create and position clone
            clonedItem = item.cloneNode(true);
            clonedItem.classList.add('elevated-clone');
            clonedItem.classList.remove('popped'); // Clone doesn't need popped class as it has its own elevated style
            
            // Strip IDs to prevent duplicate conflicts
            clonedItem.removeAttribute('id');
            clonedItem.querySelectorAll('[id]').forEach(el => el.removeAttribute('id'));

            // Force exact positioning
            clonedItem.style.setProperty('position', 'fixed', 'important');
            clonedItem.style.setProperty('top', `${rect.top}px`, 'important');
            clonedItem.style.setProperty('left', `${rect.left}px`, 'important');
            clonedItem.style.setProperty('width', `${rect.width}px`, 'important');
            clonedItem.style.setProperty('height', `${rect.height}px`, 'important');
            clonedItem.style.setProperty('margin', '0', 'important');
            clonedItem.style.setProperty('z-index', '2100', 'important'); // Above blur
            clonedItem.style.setProperty('display', 'flex', 'important');
            
            clonedItem.style.visibility = 'visible';
            clonedItem.onclick = closeIOSMenu; 
            document.body.appendChild(clonedItem);
            
            // 4. Show blur and backdrop with slight delay for opening animation
            setTimeout(() => {
                document.getElementById('blur-overlay').classList.add('active');
                document.querySelector('.mobile-wrapper').classList.add('blur-active');
            }, 50); // Small delay for perceived smoothness
            
            // Prevent scrolling
            document.body.style.overflow = 'hidden';
            document.querySelector('.mobile-wrapper').style.overflow = 'hidden';
            
            // 5. Build menu - escape values properly
            const menu = document.getElementById('ios-menu');
            const merchantSafe = merchant.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const noteSafe = note.replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/`/g, '\\`');
            const categorySafe = category.replace(/'/g, "\\'");
            
            menu.innerHTML = `
                <div class="ios-action-item" onclick="handleIOSAction('edit', '${txnId}', '${merchantSafe}', ${amount}, '${categorySafe}', '${noteSafe}')">
                    <i class="material-icons" style="color:#2563eb;">edit</i>
                    <span>Edit Transaction</span>
                </div>
                <div class="ios-action-item" onclick="handleIOSAction('duplicate', '${txnId}', '${merchantSafe}', ${amount}, '${categorySafe}', '${noteSafe}', '${date}', '${manualAmount}')">
                    <i class="material-icons" style="color:#059669;">content_copy</i>
                    <span>Duplicate</span>
                </div>
                <div class="ios-action-item ${isExcluded ? '' : 'danger'}" onclick="handleIOSAction('exclude', '${txnId}', ${isExcluded}, '${merchantSafe}')">
                    <i class="material-icons">${isExcluded ? 'add_circle' : 'block'}</i>
                    <span>${isExcluded ? 'Include' : 'Exclude'}</span>
                </div>
                <div class="ios-action-item warning" onclick="handleIOSAction('refund', '${txnId}', ${isRefund})">
                    <i class="material-icons">${isRefund ? 'undo' : 'sync_alt'}</i>
                    <span>${isRefund ? 'Unmark Refund' : 'Mark as Refund'}</span>
                </div>
                <div class="ios-action-item warning" onclick="handleIOSAction('reimbursed', '${txnId}', ${isReimbursed})">
                    <i class="material-icons">${isReimbursed ? 'undo' : 'account_balance_wallet'}</i>
                    <span>${isReimbursed ? 'Unmark Reimbursed' : 'Mark as Reimbursed'}</span>
                </div>
                <div class="ios-action-item danger" onclick="handleIOSAction('delete', '${txnId}')">
                    <i class="material-icons">delete</i>
                    <span>Delete</span>
                </div>
            `;
            
            // 6. Position menu
            menu.classList.add('show');
            if (window.pushModalState) pushModalState('ios-menu');
            const menuHeight = menu.offsetHeight || 180;
            const menuWidth = menu.offsetWidth || 200;
            
            // Get mobile wrapper bounds
            const mobileWrapper = document.querySelector('.mobile-wrapper');
            const wrapperRect = mobileWrapper ? mobileWrapper.getBoundingClientRect() : { left: 0, right: window.innerWidth, top: 0, bottom: window.innerHeight };
            
            // Position menu below the transaction item
            let topPos = rect.bottom + 12;
            
            // If not enough space below, position above
            if (topPos + menuHeight > window.innerHeight - 20) {
                topPos = rect.top - menuHeight - 12;
            }
            
            // Ensure menu doesn't go above viewport
            if (topPos < 20) {
                topPos = rect.bottom + 12; // Force below if above doesn't work
            }
            
            // Align menu's right edge with transaction card's right edge
            let leftPos = rect.right - menuWidth;
            
            // Ensure menu stays within wrapper bounds
            if (leftPos < wrapperRect.left + 20) {
                leftPos = wrapperRect.left + 20;
            }
            
            menu.style.left = `${leftPos}px`;
            menu.style.top = `${topPos}px`;
            menu.style.right = 'auto';
            menu.style.transform = 'none';
        }
        
        window.closeIOSMenu = (fromPopState = false) => {
            const blurOverlay = document.getElementById('blur-overlay');
            const iosMenu = document.getElementById('ios-menu');
            const wasMenuOpen = iosMenu && iosMenu.classList.contains('show');
            const mobileWrapper = document.querySelector('.mobile-wrapper');
            const fab = document.querySelector('.fab');
            
            // Fast close transition - 0.3s
            if (iosMenu) {
                iosMenu.style.transition = 'all 0.3s ease-out';
                iosMenu.classList.remove('show');
            }
            if (blurOverlay) {
                blurOverlay.style.transition = 'opacity 0.3s';
                blurOverlay.classList.remove('active');
            }
            if (mobileWrapper) {
                mobileWrapper.classList.remove('blur-active');
            }
            if (fab) {
                fab.classList.remove('blur-active');
            }
            
            // Restore scrolling
            document.body.style.overflow = '';
            if (mobileWrapper) mobileWrapper.style.overflow = 'auto';
            
            // Animate cloned item back to normal scale before removing
            if (clonedItem) {
                clonedItem.style.transition = 'transform 0.3s ease-out, box-shadow 0.3s ease-out, opacity 0.3s ease-out';
                clonedItem.style.transform = 'scale(1)';
                clonedItem.style.boxShadow = '0 2px 8px rgba(0,0,0,0.08)';
                clonedItem.style.opacity = '0';
                setTimeout(() => {
                    if (clonedItem) {
                        clonedItem.remove();
                        clonedItem = null;
                    }
                }, 300);
            }
            
            // Restore original item visibility immediately
            if (currentElevatedItem) {
                currentElevatedItem.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                currentElevatedItem.style.visibility = 'visible';
                currentElevatedItem.style.filter = 'none';
                currentElevatedItem.style.transform = 'scale(1)';
                currentElevatedItem.style.background = '';
                currentElevatedItem.classList.remove('popped');
                
                // Final cleanup after transition
                const target = currentElevatedItem;
                setTimeout(() => {
                    if (target) {
                        target.style.filter = '';
                        target.style.transform = '';
                    }
                }, 300);
                
                currentElevatedItem = null;
            }

            // Sync history
            if (wasMenuOpen && !fromPopState) {
                history.back();
            }
        };
        
        window.handleIOSAction = (action, txnId, ...args) => {
            // Close menu UI without calling history.back()
            closeIOSMenu(true);
            
            // Helper to open modal with replaceState instead of pushState
            // This converts [home -> menu] history into [home -> modal]
            const openWithReplace = (modalType) => {
                window.modalOpen = true;
                window.replaceModalState(modalType);
            };

            switch(action) {
                case 'edit':
                    openWithReplace('edit-txn');
                    openEditModal(txnId, args[0], args[1], args[2], args[3]);
                    break;
                case 'duplicate':
                    openWithReplace('duplicate-txn');
                    openDuplicateModal(txnId, args[0], args[1], args[2], args[3], args[4], args[5]);
                    break;
                case 'exclude':
                    toggleExclusion(txnId, args[1], args[0]);
                    break;
                case 'refund':
                    toggleRefund(txnId, args[0]);
                    break;
                case 'reimbursed':
                    toggleReimbursed(txnId, args[0]);
                    break;
                case 'delete':
                    openDeleteModal(txnId, window.currentAccount);
                    break;
            }
        };

        window.toggleExclusion = async (id, merchant, isCurrentlyExcluded) => {
            if (auth.currentUser?.isAnonymous) {
                if (confirm('Your data is in "Local Mode". Sign in with Google to sync this exclusion to the cloud?')) {
                    handleAuthClick();
                    return;
                }
            }
            
            // OPTIMISTIC UPDATE
            const idx = window.allTxns.findIndex(t => t.id === id);
            const originalState = isCurrentlyExcluded;
            if (idx > -1) {
                window.allTxns[idx].excluded = !isCurrentlyExcluded;
                renderHistory(window.allTxns);
                updateBalanceToThisMonth(window.allTxns);
                // Also refresh charts/subscriptions if needed
                if (window.detectSubscriptions) detectSubscriptions();
                if (window.drawCashFlowChart) drawCashFlowChart();
            }

            try {
                if (!auth.currentUser) return;
                const uid = auth.currentUser.uid;
                const col = getCollectionName(window.currentAccount);
                await updateDoc(doc(db, "users", uid, col, id), { excluded: !isCurrentlyExcluded });
                showToast(isCurrentlyExcluded ? 'Transaction included' : 'Transaction excluded');
            } catch (e) { 
                log('Toggle failed', 'error');
                // Revert logic could be added here if critical
                 if (idx > -1) {
                    window.allTxns[idx].excluded = originalState;
                    renderHistory(window.allTxns);
                }
            }
        };

        window.toggleRefund = async (id, isCurrentlyRefund) => {
            if (auth.currentUser?.isAnonymous) {
                if (confirm('Your data is in "Local Mode". Sign in with Google to sync changes to the cloud?')) {
                    handleAuthClick();
                    return;
                }
            }
            
            // OPTIMISTIC UPDATE
            const idx = window.allTxns.findIndex(t => t.id === id);
            const originalState = isCurrentlyRefund;
            if (idx > -1) {
                window.allTxns[idx].refund = !isCurrentlyRefund;
                renderHistory(window.allTxns);
                updateBalanceToThisMonth(window.allTxns);
                if (window.drawCashFlowChart) drawCashFlowChart();
            }

            try {
                if (!auth.currentUser) return;
                const uid = auth.currentUser.uid;
                const col = getCollectionName(window.currentAccount);
                await updateDoc(doc(db, "users", uid, col, id), { refund: !isCurrentlyRefund });
                showToast(isCurrentlyRefund ? 'Unmarked as refund' : 'Marked as refund');
            } catch (e) { 
                log('Toggle refund failed: ' + e.message, 'error');
                 // Revert
                 if (idx > -1) {
                    window.allTxns[idx].refund = originalState;
                    renderHistory(window.allTxns);
                }
            }
        };

        window.toggleReimbursed = async (id, isCurrentlyReimbursed) => {
            if (auth.currentUser?.isAnonymous) {
                if (confirm('Your data is in "Local Mode". Sign in with Google to sync changes to the cloud?')) {
                    handleAuthClick();
                    return;
                }
            }
            
            // OPTIMISTIC UPDATE
            const idx = window.allTxns.findIndex(t => t.id === id);
            const originalState = isCurrentlyReimbursed;
            if (idx > -1) {
                window.allTxns[idx].reimbursed = !isCurrentlyReimbursed;
                renderHistory(window.allTxns);
                // No updateBalanceToThisMonth call - reimbursed txns stay in balance
                if (window.detectSubscriptions) detectSubscriptions();
                if (window.drawCashFlowChart) drawCashFlowChart();
            }

            try {
                if (!auth.currentUser) return;
                const uid = auth.currentUser.uid;
                const col = getCollectionName(window.currentAccount);
                await updateDoc(doc(db, "users", uid, col, id), { reimbursed: !isCurrentlyReimbursed });
                showToast(isCurrentlyReimbursed ? 'Reimbursed status removed' : 'Marked as Reimbursed');
            } catch (e) { 
                console.error('Toggle reimbursed failed', e);
                if (idx > -1) {
                    window.allTxns[idx].reimbursed = originalState;
                    renderHistory(window.allTxns);
                }
            }
        };

        // DUPLICATE TRANSACTION LOGIC
        let currentDuplicateTxn = null;

        window.openDuplicateModal = (txnId, merchant, amount, category, note, date, manualAmount) => {
            console.log('üìã openDuplicateModal called with:', { txnId, merchant, amount, category, note, date, manualAmount });
            
            // Store transaction data
            currentDuplicateTxn = {
                id: txnId,
                merchant: merchant,
                amount: typeof amount === 'number' ? amount : parseFloat(amount),
                manualCategory: category,  // Store as manualCategory for consistency with confirmDuplicate
                note: note,
                date: date,
                manualAmount: manualAmount !== '' && manualAmount !== undefined ? parseFloat(manualAmount) : undefined
            };
            
            console.log('üìã currentDuplicateTxn:', currentDuplicateTxn);
            
            // Get all available accounts (including current one)
            const accounts = window.walletAccounts || [];
            
            if (accounts.length === 0) {
                showToast('No accounts available');
                currentDuplicateTxn = null;
                return;
            }
            
            // Build account list HTML (include all accounts)
            const listContainer = document.getElementById('duplicate-account-list');
            listContainer.innerHTML = accounts.map(acc => `
                <label class="duplicate-account-option">
                    <input type="checkbox" value="${acc.id}" class="duplicate-account-checkbox">
                    <span class="duplicate-account-label">${acc.name}${acc.id === window.currentAccount ? ' (Current)' : ''}</span>
                </label>
            `).join('');
            
            // Show modal
            const dupModal = document.getElementById('duplicate-modal');
            if (dupModal) {
                dupModal.style.display = 'flex'; // Reset inline style
                dupModal.classList.add('show');
            }
            window.modalOpen = true;
            const fab = document.querySelector('.fab');
            if (fab) {
                fab.classList.add('clicked');
                setTimeout(() => fab.classList.remove('clicked'), 300);
            }
            document.querySelector('.mobile-wrapper')?.classList.add('blur-active');
            if (window.modalOpen) {
                // Handled by replaceModalState in handleIOSAction
            } else {
                if (window.pushModalState) pushModalState('duplicate-txn');
            }
        };

        window.confirmDuplicate = async () => {
            console.log('üìã confirmDuplicate called, currentDuplicateTxn:', currentDuplicateTxn);
            
            if (!currentDuplicateTxn) {
                console.error('üìã No currentDuplicateTxn!');
                showToast('No transaction selected');
                return;
            }
            
            // Get selected accounts
            const checkboxes = document.querySelectorAll('.duplicate-account-checkbox:checked');
            const selectedAccounts = Array.from(checkboxes).map(cb => cb.value);
            console.log('üìã Selected accounts:', selectedAccounts);
            
            if (selectedAccounts.length === 0) {
                showToast('Please select at least one account');
                return;
            }
            
            const uid = auth.currentUser?.uid;
            console.log('üìã User UID:', uid);
            
            if (!uid) {
                showToast('Please sign in to duplicate transactions');
                closeModals();
                currentDuplicateTxn = null;
                return;
            }
            
            // Get original transaction data with fallback
            let originalTxn = { ...currentDuplicateTxn };
            
            // If date is missing, try to find it from allTxns
            if (!originalTxn.date) {
                const foundTxn = window.allTxns?.find(t => t.id === originalTxn.id);
                if (foundTxn) {
                    originalTxn.date = foundTxn.date;
                    if (!originalTxn.manualCategory) originalTxn.manualCategory = foundTxn.manualCategory;
                }
            }
            
            // Still no date? Use today as fallback
            if (!originalTxn.date) {
                originalTxn.date = formatLocalDate(new Date());
                console.warn('üìã No date found, using today as fallback');
            }
            
            console.log('üìã Final originalTxn:', originalTxn);
            
            // Duplicate to each selected account
            let successCount = 0;
            let errorMessages = [];
            
            for (const targetAccount of selectedAccounts) {
                try {
                    const collectionName = getCollectionName(targetAccount);
                    const newId = `dup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    console.log(`üìã Duplicating to ${targetAccount} (${collectionName}) with ID: ${newId}`);
                    
                    // Check if this is an ATOME PAYMENT being duplicated TO Atome wallet (from ANY source)
                    const isAtomePayment = originalTxn.merchant && originalTxn.merchant.toUpperCase().includes('ATOME');
                    const isToAtome = targetAccount === 'atome';
                    const shouldMarkAsIncome = isAtomePayment && isToAtome;
                    
                    console.log(`üìã isAtomePayment: ${isAtomePayment}, isToAtome: ${isToAtome}, shouldMarkAsIncome: ${shouldMarkAsIncome}`);
                    
                    let duplicatedAmount = originalTxn.amount;
                    let duplicatedManualAmount = originalTxn.manualAmount;
                    let duplicatedCategory = originalTxn.manualCategory;
                    
                    if (shouldMarkAsIncome) {
                        // Convert to positive amount and mark as Income
                        duplicatedAmount = Math.abs(duplicatedAmount);
                        if (duplicatedManualAmount !== undefined) {
                            duplicatedManualAmount = Math.abs(duplicatedManualAmount);
                        }
                        duplicatedCategory = 'Income';
                    }
                    
                    const duplicatedTxn = {
                        amount: duplicatedAmount,
                        merchant: originalTxn.merchant,
                        date: originalTxn.date,
                        manualCategory: duplicatedCategory,
                        note: (originalTxn.note || '') + (shouldMarkAsIncome ? ' (Payment)' : ''),
                        excluded: false,
                        refund: false,
                        deleted: false,
                        duplicatedFrom: currentDuplicateTxn.id,
                        duplicatedFromAccount: window.currentAccount
                    };
                    
                    // Only add manualAmount if it's defined (Firestore doesn't accept undefined)
                    if (duplicatedManualAmount !== undefined) {
                        duplicatedTxn.manualAmount = duplicatedManualAmount;
                    }
                    
                    console.log('üìã Creating duplicatedTxn:', duplicatedTxn);
                    
                    const docRef = doc(db, "users", uid, collectionName, newId);
                    await setDoc(docRef, { ...duplicatedTxn, createdAt: serverTimestamp() });
                    console.log(`üìã ‚úÖ Successfully duplicated to ${targetAccount}`);
                    successCount++;
                } catch (e) {
                    console.error(`üìã ‚ùå Failed to duplicate to ${targetAccount}:`, e);
                    errorMessages.push(`${targetAccount}: ${e.message}`);
                }
            }
            
            if (successCount > 0) {
                showToast(`Transaction duplicated to ${successCount} account(s)`);
            } else {
                showToast('Failed to duplicate: ' + errorMessages.join(', '));
            }
            
            closeModals();
            currentDuplicateTxn = null;
        };

        // DELETE LOGIC
        let currentTxnId = null;
        let currentDeletionAccount = null;

        window.runThanosSnap = (el, callback) => {
            if (!el) return callback();
            
            const rect = el.getBoundingClientRect();
            const count = 150; // High density for "fading" look
            // Monochromatic "Ash" palette: Black, White, Grays
            const colors = ['#000000', '#1a1a1a', '#333333', '#4d4d4d', '#666666', '#808080', '#999999', '#b3b3b3', '#cccccc', '#e6e6e6', '#ffffff'];
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$‚Ç±+-*‚Ä¢. ';
            
            // Create particles
            for (let i = 0; i < count; i++) {
                const p = document.createElement('div');
                p.className = 'snap-particle';
                
                const chosenColor = colors[Math.floor(Math.random() * colors.length)];
                
                // More text-based particles for "fading text" feel
                const isChar = Math.random() > 0.4;
                if (isChar) {
                    p.innerText = chars[Math.floor(Math.random() * chars.length)];
                    p.style.background = 'none';
                    p.style.fontSize = `${Math.random() * 12 + 4}px`;
                    p.style.fontWeight = '800';
                    p.style.color = chosenColor;
                    p.style.opacity = Math.random() * 0.7 + 0.3;
                } else {
                    const size = Math.random() * 3 + 1; // Smaller bits
                    p.style.width = `${size}px`;
                    p.style.height = `${size}px`;
                    p.style.backgroundColor = chosenColor;
                    p.style.opacity = Math.random() * 0.5 + 0.2;
                }
                
                // Start position (randomly inside the element)
                p.style.left = `${rect.left + Math.random() * rect.width}px`;
                p.style.top = `${rect.top + Math.random() * rect.height}px`;
                
                // Random destination (floating away)
                const dx = (Math.random() - 0.5) * 250;
                const dy = (Math.random() - 1.2) * 200; // Upwards
                const rot = Math.random() * 1080 - 540;
                
                p.style.setProperty('--dx', `${dx}px`);
                p.style.setProperty('--dy', `${dy}px`);
                p.style.setProperty('--rot', `${rot}deg`);
                
                // Slower duration
                p.style.animationDuration = `${1.5 + Math.random() * 2}s`;
                
                document.body.appendChild(p);
                
                // Cleanup particle
                setTimeout(() => p.remove(), 4000);
            }
            
            // Trigger disintegration and collapse
            el.classList.add('snapping');
            
            // Wait for collapse to finish before callback
            setTimeout(callback, 1500);
        };

        window.openDeleteModal = (id, accId) => {
            currentTxnId = id;
            currentDeletionAccount = accId || window.currentAccount;
            const delModal = document.getElementById('delete-modal');
            if (delModal) {
                delModal.style.display = 'flex'; // Reset inline style
                delModal.classList.add('show');
                document.querySelector('.mobile-wrapper')?.classList.add('blur-active');
                document.querySelector('.fab')?.classList.add('blur-active');
                document.querySelector('.bottom-nav')?.classList.add('blur-active');
            }
            window.modalOpen = true;
            const fab = document.querySelector('.fab');
            if (fab) {
                fab.classList.add('clicked');
                setTimeout(() => fab.classList.remove('clicked'), 300);
            }
            if (window.pushModalState) pushModalState('delete-txn');
        };

        // UNDO SNACKBAR STACK SYSTEM (max 3)
        window.undoQueue = []; // Array of { id, txnId, accId, col, deletedItem, timer, el }

        function createUndoSnackbar(txnId, accId, col, deletedItem) {
            const stack = document.getElementById('undo-stack');
            if (!stack) return;

            const entryId = Date.now() + '-' + Math.random().toString(36).substr(2, 5);

            // If already 3 in queue, commit and remove the oldest
            if (window.undoQueue.length >= 3) {
                const oldest = window.undoQueue.shift();
                commitAndRemoveSnackbar(oldest);
            }

            // Get the item name for display
            const itemName = deletedItem ? (deletedItem.note || deletedItem.merchant || deletedItem.description || 'Item') : 'Item';
            const displayName = itemName.length > 20 ? itemName.substring(0, 20) + '‚Ä¶' : itemName;

            // Create snackbar element
            const el = document.createElement('div');
            el.className = 'undo-snackbar';
            el.dataset.entryId = entryId;
            el.innerHTML = `
                <div class="undo-snackbar-content">
                    <span class="undo-snackbar-text">${displayName} deleted</span>
                    <button class="undo-snackbar-btn" onclick="undoById('${entryId}')">UNDO</button>
                </div>
                <div class="undo-progress-bar">
                    <div class="undo-progress-fill"></div>
                </div>
            `;
            stack.prepend(el);

            // Set 7-second timer
            const timer = setTimeout(() => {
                const entry = window.undoQueue.find(e => e.id === entryId);
                if (entry) {
                    commitAndRemoveSnackbar(entry);
                    window.undoQueue = window.undoQueue.filter(e => e.id !== entryId);
                }
            }, 7000);

            window.undoQueue.push({ id: entryId, txnId, accId, col, deletedItem, timer, el });
        }

        function commitAndRemoveSnackbar(entry) {
            // Commit the delete to Firestore
            commitDelete(entry.txnId, entry.accId, entry.col);
            clearTimeout(entry.timer);
            // Animate out
            if (entry.el && entry.el.parentNode) {
                entry.el.classList.add('removing');
                setTimeout(() => entry.el.remove(), 300);
            }
        }

        window.undoById = (entryId) => {
            const idx = window.undoQueue.findIndex(e => e.id === entryId);
            if (idx === -1) return;
            const entry = window.undoQueue[idx];
            
            // Cancel pending delete
            clearTimeout(entry.timer);
            
            // Restore the item
            if (entry.deletedItem) {
                window.allTxns.push(entry.deletedItem);
                window.allTxns.sort((a, b) => new Date(b.date) - new Date(a.date));
                renderHistory(window.allTxns);
                updateBalanceToThisMonth(window.allTxns);
                showToast('Transaction restored');
            }
            
            // Remove snackbar
            if (entry.el && entry.el.parentNode) {
                entry.el.classList.add('removing');
                setTimeout(() => entry.el.remove(), 300);
            }
            window.undoQueue.splice(idx, 1);
        };

        window.confirmDelete = async () => {
             if (auth.currentUser?.isAnonymous) {
                if (confirm('Your data is in "Local Mode". Sign in with Google to sync deletions to the cloud?')) {
                    handleAuthClick();
                    return;
                }
            }
            if (!currentTxnId) return;
            // CAPTURE LOCAL COPIES BEFORE closeModals() clears them
            const txnId = currentTxnId;
            const accId = currentDeletionAccount;
            const col = getCollectionName(accId);
            
            closeModals(); // Close modal immediately

            // Locate element for animation
            const txnEl = document.querySelector(`.premium-txn[data-txn-id="${txnId}"]`);
            
            // OPTIMISTIC UPDATE: Remove from UI immediately
            const idx = window.allTxns.findIndex(t => t.id === txnId);
            let deletedItem = null;
            if (idx > -1) {
                deletedItem = { ...window.allTxns[idx] };
                window.allTxns.splice(idx, 1);
            }

            const removeAndRender = () => {
                renderHistory(window.allTxns);
                updateBalanceToThisMonth(window.allTxns);
            };

            // Trigger Thanos animation then render
            if (txnEl) {
                window.runThanosSnap(txnEl, removeAndRender);
            } else {
                removeAndRender();
            }

            // CREATE UNDO SNACKBAR (max 3 stacked)
            createUndoSnackbar(txnId, accId, col, deletedItem);
        };

        // COMMIT DELETE: Actually write to Firestore
        async function commitDelete(txnId, accId, col) {
            try {
                if (!auth.currentUser) return;
                const uid = auth.currentUser.uid;
                await setDoc(doc(db, "users", uid, col, txnId), { deleted: true }, { merge: true });
                
                const cacheKey = `wallet_cache_${uid}_${accId}`;
                localStorage.setItem(cacheKey, JSON.stringify({
                    txns: window.allTxns,
                    timestamp: Date.now()
                }));
            } catch (error) { 
                log("Error deleting: " + error.message, "error");
                showToast('Delete failed');
            }
        }

        // --- CUSTOMIZATION MODALS ---
        const CATEGORIES = [
            { id: 'Online shopping', icon: 'shopping_bag', label: 'Online Shopping', cls: 'cat-online' },
            { id: 'Shopping', icon: 'shopping_cart', label: 'Shopping', cls: 'cat-shopping' },
            { id: 'Vehicle', icon: 'local_gas_station', label: 'Vehicle', cls: 'cat-vehicle' },
            { id: 'Food & Drinks', icon: 'restaurant', label: 'Food & Drinks', cls: 'cat-food' },
            { id: 'Service', icon: 'settings_cell', label: 'Service', cls: 'cat-service-magenta' },
            { id: 'Trade Copier', icon: 'hub', label: 'Trade Copier', cls: 'cat-aqua' },
            { id: 'Trading Expenses', icon: 'insights', label: 'Trading Expenses', cls: 'cat-trading' },
            { id: 'Life & Entertainment', icon: 'confirmation_number', label: 'Life & Ent.', cls: 'cat-life' },
            { id: 'Financial Expenses', icon: 'payments', label: 'Financial Expenses', cls: 'cat-financial' },
            { id: 'Credit Card Payment', icon: 'credit_card', label: 'Credit Card', cls: 'cat-credit-card' },
            { id: 'Transportation', icon: 'directions_bus', label: 'Transportation', cls: 'cat-vehicle' },
            { id: 'Travel', icon: 'flight', label: 'Travel', cls: 'cat-aqua' },
            { id: 'Education', icon: 'school', label: 'Education', cls: 'cat-education' },
            { id: 'Sport', icon: 'fitness_center', label: 'Sport', cls: 'cat-life' },
            { id: 'Savings', icon: 'account_balance', label: 'Savings', cls: 'cat-investments' },
            { id: 'Income', icon: 'savings', label: 'Income', cls: 'cat-income' }
        ];

        // Function to update main wallet balance (Total All-Time)
        function updateMainWalletBalance(allTxns) {
            let incomeTotal = 0;
            let expenseTotal = 0;
            
            allTxns.forEach(t => {
                if (t.excluded || t.refund || t.deleted) return;
                const mapped = getMerchantDisplay(t.merchant, t);
                const amt = t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0);
                const cat = mapped.category;
                
                if (cat === 'Income') {
                    incomeTotal += amt;
                } else {
                    expenseTotal += amt;
                }
            });
            
            const balanceEl = document.getElementById(`${window.currentAccount}-balance`);
            if (balanceEl) {
                const balance = incomeTotal - expenseTotal;
                balanceEl.innerText = `PHP ${balance.toLocaleString(undefined, {minimumFractionDigits:2})}`;
            }
        }

        // Populate Transaction History Category Filter
        const populateTxnFilter = () => {
            const filter = document.getElementById('txn-cat-filter');
            if (!filter) return;
            
            // Keep "All Items"
            const allOption = filter.options[0];
            filter.innerHTML = '';
            filter.appendChild(allOption);
            
            CATEGORIES.forEach(cat => {
                const opt = document.createElement('option');
                opt.value = cat.label; // We match against the label in filterTxnList
                opt.innerText = cat.label;
                filter.appendChild(opt);
            });
        };
        populateTxnFilter();

        // =============================================
        // NAVIGATION HANDLING: Back Button, Modal, & Double-Tap to Exit
        // =============================================
        
        // Track current navigation state
        window.currentPage = 'home';
        window.modalOpen = false;
        window.lastBackPressTime = 0;

        // Helper: Push history state when opening a modal
        window.pushModalState = (modalName) => {
            window.modalOpen = true;
            history.pushState({ modal: modalName }, '', '');
        };

        window.replaceModalState = (modalName) => {
            window.modalOpen = true;
            history.replaceState({ modal: modalName }, '', '');
        };

        window.closeModals = (fromPopState = false) => {
            const wasModalOpen = window.modalOpen;
            const overlays = document.querySelectorAll('.modal-overlay.show, .dialog-overlay.show');
            
            if (overlays.length > 0) {
                overlays.forEach(m => {
                    m.classList.add('closing');
                    if (window.NavState) window.NavState.popModalState(m.id);
                });
                
                // Allow animation to finish before removing show and cleaning up
                setTimeout(() => {
                    overlays.forEach(m => {
                        m.classList.remove('show');
                        m.classList.remove('closing');
                        m.style.display = 'none'; // Ensure hidden
                    });
                    cleanupModalState(wasModalOpen, fromPopState);
                }, 300); // Sync with 0.3s CSS animations
            } else {
                cleanupModalState(wasModalOpen, fromPopState);
            }
        };

        function cleanupModalState(wasModalOpen, fromPopState) {
            currentTxnId = null;
            window.modalOpen = false;
            
            // Remove blur effect from background elements
            document.querySelector('.mobile-wrapper')?.classList.remove('blur-active');
            document.querySelector('.fab')?.classList.remove('blur-active');
            document.querySelector('.bottom-nav')?.classList.remove('blur-active');

            // Restore scroll
            const wrapper = document.querySelector('.mobile-wrapper');
            if (wrapper) {
                wrapper.style.overflow = 'auto';
            }
            document.body.style.overflow = '';
            document.body.style.position = '';
            document.body.style.width = '';
            
            // Also close iOS menu if open
            if (window.closeIOSMenu) closeIOSMenu();
            
            // Pop history state if not from popstate event
            if (wasModalOpen && !fromPopState) {
                history.back();
            }
        }

        // POPSTATE HANDLER: Handle back button press
        window.addEventListener('popstate', (e) => {
            // Check if a modal is open
            const openModal = document.querySelector('.modal-overlay.show, .dialog-overlay.show');
            const iosMenu = document.getElementById('ios-menu')?.classList.contains('show');
            
            if (openModal || iosMenu) {
                // Close modal/menu instead of navigating back
                // Since popstate already removed the pushed state, we just handle the UI
                if (iosMenu && window.closeIOSMenu) closeIOSMenu(true);
                if (openModal) closeModals(true);
                return;
            }
            
            // If on a sub-page (Accounts, Calendar, Profile), return to home
            if (window.currentPage !== 'home') {
                // Navigate to home page
                if (window.showPage) {
                    showPage('home');
                }
                window.currentPage = 'home';
                
                // Push state back to prevent actual navigation
                history.pushState(null, '', '');
                return;
            }
            
            // On home with no modals: Double-tap to exit
            const now = Date.now();
            if (now - window.lastBackPressTime < 2000) {
                // Double-tap: Allow exit (don't prevent default)
                // For PWA, we need to close the window
                window.close();
            } else {
                // First tap: Show toast and prevent exit
                window.lastBackPressTime = now;
                if (window.showToast) showToast('Tap back again to exit');
                
                // Push state back to prevent actual navigation
                history.pushState(null, '', '');
            }
        });

        // Initialize history state
        history.replaceState(null, '', '');

        // Close on outside click
        window.onclick = (e) => {
            if (e.target.classList.contains('modal-overlay')) {
                closeModals();
            }
        };

        window.openCategoryModal = (id, merchant, currentCatId) => {
            currentTxnId = id;
            const grid = document.getElementById('cat-grid');
            grid.innerHTML = CATEGORIES.map(cat => `
                <div class="cat-option ${currentCatId === cat.id ? 'active' : ''}" onclick="window.saveCategory('${cat.id}')">
                    <i class="material-icons ${cat.cls}" style="padding: 10px; border-radius: 12px;">${cat.icon}</i>
                    <span>${cat.label}</span>
                </div>
            `).join('');
            document.getElementById('cat-modal').classList.add('show');
            document.querySelector('.mobile-wrapper')?.classList.add('blur-active');
            document.querySelector('.fab')?.classList.add('blur-active');
            document.querySelector('.bottom-nav')?.classList.add('blur-active');
            if (window.pushModalState) pushModalState('change-cat');
        };

        window.saveCategory = async (catId) => {
            if (auth.currentUser?.isAnonymous) {
                if (confirm('Your data is in "Local Mode". Sign in with Google to sync category changes to the cloud?')) {
                    handleAuthClick();
                    return;
                }
            }
            if (!currentTxnId) return;
            // CAPTURE LOCAL COPIES BEFORE closeModals() clears them
            const txnId = currentTxnId;

            // OPTIMISTIC UPDATE
            const idx = window.allTxns.findIndex(t => t.id === txnId);
            const originalCat = idx > -1 ? window.allTxns[idx].manualCategory : null;
            if (idx > -1) {
                window.allTxns[idx].manualCategory = catId;
                renderHistory(window.allTxns);
                updateBalanceToThisMonth(window.allTxns);
                if (window.detectSubscriptions) detectSubscriptions();
                if (window.drawCashFlowChart) drawCashFlowChart();
            }
            closeModals(); // Close immediately

            try {
                if (!auth.currentUser) return;
                const uid = auth.currentUser.uid;
                const col = getCollectionName(window.currentAccount);
                await updateDoc(doc(db, "users", uid, col, txnId), { manualCategory: catId });
                showToast('Category updated');
            } catch (error) { 
                log("Error saving category: " + error.message, "error");
                showToast('Update failed');
                 // Revert
                 if (idx > -1) {
                    window.allTxns[idx].manualCategory = originalCat;
                    renderHistory(window.allTxns);
                }
            }
        };

        window.openNoteModal = (id, merchant, note) => {
            currentTxnId = id;
            const input = document.getElementById('note-text');
            const counter = document.getElementById('note-counter');
            input.value = note || '';
            counter.innerText = `${input.value.length}/30`;
            
            input.oninput = () => {
                counter.innerText = `${input.value.length}/30`;
            };

            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveNote();
                }
            };
            
            const noteModal = document.getElementById('note-modal');
            if (noteModal) {
                noteModal.style.display = 'flex'; // Reset inline style
                noteModal.classList.add('show');
            }
            window.modalOpen = true;
            document.querySelector('.mobile-wrapper')?.classList.add('blur-active');
            document.querySelector('.fab')?.classList.add('blur-active');
            document.querySelector('.bottom-nav')?.classList.add('blur-active');
        };

        // Enforce Title Case Helper
        function toTitleCase(str) {
            return str.replace(/\w\S*/g, function(txt){
                return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
            });
        }

        document.getElementById('save-note-btn').onclick = async () => {
             if (auth.currentUser?.isAnonymous) {
                if (confirm('Your data is in "Local Mode". Sign in with Google to sync your notes to the cloud?')) {
                    handleAuthClick();
                    return;
                }
            }
            if (!currentTxnId) return;
            // CAPTURE LOCAL COPIES BEFORE closeModals() clears them
            const txnId = currentTxnId;
            const col = getCollectionName(window.currentAccount);
            let note = document.getElementById('note-text').value.trim();

             // OPTIMISTIC UPDATE
            const idx = window.allTxns.findIndex(t => t.id === txnId);
            const originalNote = idx > -1 ? window.allTxns[idx].note : null;
            if (idx > -1) {
                window.allTxns[idx].note = note;
                renderHistory(window.allTxns);
            }
            closeModals();

            try {
                if (!auth.currentUser) return;
                const uid = auth.currentUser.uid;
                await updateDoc(doc(db, "users", uid, col, txnId), { note: note });
                showToast('Note saved');
            } catch (error) { 
                log("Error saving note: " + error.message, "error"); 
                showToast('Save failed');
                 // Revert
                 if (idx > -1) {
                    window.allTxns[idx].note = originalNote;
                    renderHistory(window.allTxns);
                }
            }
        };

        window.openPriceModal = (id, currentAmt) => {
            currentTxnId = id;
            const modal = document.getElementById('price-modal');
            const input = document.getElementById('price-input');
            input.value = currentAmt;
            modal.classList.add('show');
            document.querySelector('.mobile-wrapper')?.classList.add('blur-active');
            document.querySelector('.fab')?.classList.add('blur-active');
            document.querySelector('.bottom-nav')?.classList.add('blur-active');
            if (window.pushModalState) pushModalState('edit-price');
            setTimeout(() => input.focus(), 100);

            input.onkeydown = (e) => {
                if (e.key === 'Enter') savePrice();
            };
        };

        const savePrice = async () => {
            if (auth.currentUser?.isAnonymous) {
                if (confirm('Your data is in "Local Mode". Sign in with Google to sync prices to the cloud?')) {
                    handleAuthClick();
                    return;
                }
            }
            if (!currentTxnId) return;
            // CAPTURE LOCAL COPIES BEFORE closeModals() clears them
            const txnId = currentTxnId;
            const col = getCollectionName(window.currentAccount);
            
            const val = document.getElementById('price-input').value;
            const amt = parseFloat(val);
            const isValid = !isNaN(amt) && val.trim() !== "";
            
            // OPTIMISTIC UPDATE
            const idx = window.allTxns.findIndex(t => t.id === txnId);
            const originalAmt = idx > -1 ? window.allTxns[idx].manualAmount : undefined;
            if (idx > -1) {
                if (isValid) {
                     window.allTxns[idx].manualAmount = amt;
                } else {
                     delete window.allTxns[idx].manualAmount;
                }
                renderHistory(window.allTxns);
                updateBalanceToThisMonth(window.allTxns);
                if (window.drawCashFlowChart) drawCashFlowChart();
            }
            closeModals();

            try {
                if (!auth.currentUser) return;
                const uid = auth.currentUser.uid;
                const docRef = doc(db, "users", uid, col, txnId);
                if (!isValid) {
                    await updateDoc(docRef, { manualAmount: deleteField() });
                } else {
                    await updateDoc(docRef, { manualAmount: amt });
                }
                showToast('Price updated');
            } catch (error) { 
                log("Error saving price: " + error.message, "error"); 
                showToast('Update failed');
                // Revert
                 if (idx > -1) {
                    if (originalAmt === undefined) delete window.allTxns[idx].manualAmount;
                    else window.allTxns[idx].manualAmount = originalAmt;
                    renderHistory(window.allTxns);
                }
            }
        };
        window.savePrice = savePrice;

        /* See listener above for save-note-btn, replaced to include title casing */

        function showToast(msg) {
            const toast = document.getElementById('toast-box');
            document.getElementById('toast-msg').innerText = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        function displayCategoryName(id) {
            const cat = CATEGORIES.find(c => c.id === id);
            return cat ? cat.label : id;
        }

        // MERCHANT MAPPING & CATEGORIZATION
        function getMerchantDisplay(name = '', t = {}) {
            let raw = name.toUpperCase();
            
            // 1. GENERAL CLEANUP (Remove PHL, Locations, messy suffixes)
            let cleaned = name
                .replace(/\s+PHL$/i, '')
                .replace(/\s+CEBU\s+CITY\s+PHL$/i, '')
                .replace(/\s+CEBU\s+CITY$/i, '')
                .replace(/\s+DUBAI\s+ARE$/i, '')
                .replace(/\s+LONDON\s+GBR$/i, '')
                .replace(/\s+PH\s+PHL$/i, '')
                .replace(/\s+PH$/i, '')
                .trim();
            
            // 2. PATTERN REPLACEMENT
            if (cleaned.toUpperCase().includes('GADC') || cleaned.toUpperCase().includes('MCDONALDS') || cleaned.toUpperCase().includes('MCDO')) {
                let u = cleaned.toUpperCase();
                if (u.includes('SOUTHCBU') || u.includes('325CLN')) {
                    cleaned = 'MCDONALDS SOUTH CEBU';
                } else {
                    // Standardize prefix
                    cleaned = cleaned.replace(/(GADC|MCDONALDS|MCDO)/i, 'MCDONALDS').trim();
                    // Strip alphanumeric codes like 325CLNS... but keep what's after if it looks like a name
                    cleaned = cleaned.replace(/MCDONALDS\s+\d+[A-Z]*/i, 'MCDONALDS').trim();
                }
            }
            
            if (cleaned.toUpperCase().includes('JOLLIBEE')) {
                cleaned = cleaned.replace(/JB\d+\s+\w+/i, '').trim();
            }

            if (cleaned.toUpperCase().includes('RIBSHACK')) {
                 cleaned = cleaned.replace(/PH\d+/i, '').trim();
            }

            if (cleaned.toUpperCase().includes('SHOPEE')) {
                cleaned = 'SHOPEE PH';
            }

            if (cleaned.toUpperCase().includes('TRADERSCONNECT')) {
                cleaned = 'TRADERS CONNECT';
            }

            if (cleaned.toUpperCase().includes('TIKTOK SHOP')) {
                cleaned = 'TIKTOK SHOP';
            }

            if (cleaned.toUpperCase().includes('SPOTIFY')) {
                cleaned = 'SPOTIFY';
            }

            let display = { name: cleaned, category: 'Financial expenses', icon: 'payments', catClass: 'cat-financial' };

            // 3. MANUAL OVERRIDE (USER CHOICE)
            if (t.manualCategory) {
                const userCat = CATEGORIES.find(c => c.id === t.manualCategory);
                if (userCat) {
                    display.category = userCat.id;
                    display.icon = userCat.icon;
                    // Find catClass
                    const catMap = {
                        'Online shopping': 'cat-online',
                        'Shopping': 'cat-shopping',
                        'Vehicle': 'cat-vehicle',
                        'Trade Copier': 'cat-aqua',
                        'Trading Expenses': 'cat-trading',
                        'Service': 'cat-service-magenta',
                        'Food & Drinks': 'cat-food',
                        'Life & Entertainment': 'cat-life',
                        'Financial Expenses': 'cat-financial',
                        'Credit Card Payment': 'cat-credit-card',
                        'Transportation': 'cat-vehicle',
                        'Travel': 'cat-aqua',
                        'Education': 'cat-education', /* Blue */
                        'Sport': 'cat-life',
                        'Income': 'cat-income'
                    };
                    display.catClass = userCat.cls || catMap[userCat.id] || 'cat-financial';
                    return display;
                }
            }

            // 4. EXACT OVERRIDES
            const mapping = {
                'MR DIY BGCC BOGO': 'MR DIY BOGO',
                'MR DIY ZBOG BOGO': 'MR DIY BOGO',
                'TEC FUEL SAN REMIGIO': 'TECFUEL SAN REMIGIO',
                'J AND L SHOPPING BOGO': 'J AND L MALL BOGO',
                'TECFUEL BOGO CEBU': 'TECFUEL BOGO',
                'KKV SM J Mall Cebu': 'KKV SM J MALL CEBU',
                'SM STORE-CEBU': 'SM STORE - CEBU CITY',
                'GLOBE-BILLSPAY PH': 'GLOBE / GOMO LOAD',
                'SHELL FILLWISE BOGO CEBU': 'SHELL BOGO CEBU',
                'GLOBE WEBLOADING EC PH': 'GLOBE / GOMO LOAD',
                'WATSONS HISOLER BLDG B': 'WATSONS HISOLER BLDG BOGO',
                'SUPER METRO S/M-BOGO': 'SUPER METRO BOGO',
                'SM SUPERMARKET SM SRP CEBU': 'SM SUPERMARKET SRP',
                'OCTAGON AYALA CENTRAL CEBU': 'OCTAGON AYALA CENTRAL CEBU',
                'STARBUCKS 540 CENTRAL CEBU CITY': 'STARBUCKS 540 CENTRAL CEBU CITY',
                'ICE SKATING SM SRP CEB': 'ICE SKATING SM SRP CEBU',
                'TAP SURE LEVERAGE FUND': 'TAP SURE LEVERAGE FUND',
                'MRCRMT': 'MRCRMT',
                'TRADERSCONNECT.COM': 'TRADERS CONNECT',
                'TRADERSCONNECT': 'TRADERS CONNECT',
                'TRADERSCONNECT.COM': 'TRADERS CONNECT'
            };

            const finalRaw = cleaned.toUpperCase();
            if (mapping[cleaned]) display.name = mapping[cleaned];
            else if (mapping[finalRaw]) display.name = mapping[finalRaw];

            // 5. CATEGORY DETECTION
            const lowerRaw = finalRaw.toLowerCase();
            const noteLower = (t.note || '').toLowerCase();

            if (finalRaw === 'INCOME' || finalRaw.includes('SALARY') || finalRaw.includes('DIVIDEND') || finalRaw.includes('REFUND SOURCE')) {
                display.category = 'Income';
                display.icon = 'savings';
                display.catClass = 'cat-income';
            } else {
                // Feature 2: Keyword-based Smart Categorization
                const keywordMap = [
                    { cat: 'Online shopping', key: ['shopee', 'tiktok', 'lazada', 'shein', 'temu', 'shopify', 'grabfood', 'foodpanda', 'amazon', 'ebay'] },
                    { cat: 'Shopping', key: ['mall', 'supermet', 'gaisano', 'mr diy', 'watsons', 'sm store', 'sm superm', 'robinsons', 'kkv', 'miniso', 'unitop', 'h&m', 'uniqlo'] },
                    { cat: 'Vehicle', key: ['tecfuel', 'tec fuel', 'shell', 'petron', 'seaoil', 'ptt', 'caltex', 'cleanfuel', 'fuel', 'gas', 'toyota', 'honda', 'mitsub', 'car wash', 'autoshop'] },
                    { cat: 'Food & Drinks', key: ['jollibee', 'mcdo', 'mcdonald', 'starbucks', 'chowking', 'kfc', 'mang inasal', 'greenwich', 'ribshack', 'coffee', 'resto', 'cafe', 'tea', 'bakery', 'j.co', 'dunkin', 'boba', 'pizza'] },
                    { cat: 'Service', key: ['globe', 'smart', 'pldt', 'tm', 'gomo', 'netflix', 'spotify', 'youtube', 'disney', 'prime', 'apple', 'icloud', 'google', 'subscription', 'bill', 'insurance', 'philhealth', 'sss', 'pag-ibig', 'veco', 'mcwd'] },
                    { cat: 'Transportation', key: ['grab car', 'grab ride', 'taxi', 'move it', 'joyride', 'angkas', 'jeep', 'bus', 'ferry', 'pier', 'airport', 'airline'] },
                    { cat: 'Education', key: ['school', 'university', 'tuition', 'book', 'udemy', 'coursera', 'skillshare', 'training'] },
                    { cat: 'Life & Entertainment', key: ['cinema', 'movie', 'game', 'playstation', 'xbox', 'steam', 'valve', 'riot', 'epic', 'skating', 'zoo', 'park', 'concert', 'spotify', 'netflix'] }
                ];

                for (const map of keywordMap) {
                    if (map.key.some(k => lowerRaw.includes(k) || noteLower.includes(k))) {
                        const findCat = CATEGORIES.find(c => c.id === map.cat);
                        if (findCat) {
                            display.category = findCat.id;
                            display.icon = findCat.icon;
                            display.catClass = findCat.cls || 'cat-financial';
                            display.autoSuggested = true; 
                            break;
                        }
                    }
                }

                if (finalRaw.includes('TRADERSCONNECT') || finalRaw.includes('TRADERS CONNECT')) {
                    display.category = 'Trade Copier';
                    display.icon = 'hub';
                    display.catClass = 'cat-aqua';
                } else if (finalRaw.includes('EQUITY EDGE') || finalRaw.includes('ANALYTICS') || finalRaw.includes('TRADING') || finalRaw.includes('LEVERAGE FUND') || finalRaw.includes('MRCRMT')) {
                    display.category = 'Trading Expenses';
                    display.icon = 'insights';
                    display.catClass = 'cat-trading';
                } else {
                    // Default fallback if no keyword matched
                    if (display.category === 'Financial expenses' || !display.category) {
                        display.category = 'Financial expenses';
                        display.catClass = 'cat-financial';
                    }
                }
            }

            return display;
        }

        function log(msg, type = 'info') {
            const container = document.getElementById('log-container');
            if (!container) return;
            const div = document.createElement('div');
            div.className = `log-entry ${type === 'error' ? 'log-error' : ''}`;
            div.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        // --- MANUAL TRANSACTION LOGIC (INTEGRATED) ---
        let selectedManualCatId = 'Financial Expenses'; 
        let manualTxnType = 'expense';

        window.setTxnType = (type) => {
            manualTxnType = type;
            const btnExp = document.getElementById('btn-expense');
            const btnInc = document.getElementById('btn-income');
            
            if (type === 'expense') {
                if (btnExp) {
                    btnExp.style.background = '#ef4444'; 
                    btnExp.style.color = '#fff';
                    btnExp.style.boxShadow = '0 4px 10px rgba(239, 68, 68, 0.3)';
                }
                
                if (btnInc) {
                    btnInc.style.background = 'transparent';
                    btnInc.style.color = '#64748b';
                    btnInc.style.boxShadow = 'none';
                }
                
                // Show category section for expenses
                const catSection = document.getElementById('category-section');
                if (catSection) catSection.style.display = 'block';
                if (!window.editingTxnId) selectedManualCatId = 'Financial Expenses';
            } else {
                if (btnInc) {
                    btnInc.style.background = '#10b981';
                    btnInc.style.color = '#fff';
                    btnInc.style.boxShadow = '0 4px 10px rgba(16, 185, 129, 0.3)';
                }
                
                if (btnExp) {
                    btnExp.style.background = 'transparent';
                    btnExp.style.color = '#64748b';
                    btnExp.style.boxShadow = 'none';
                }
                
                // Hide category section for income (only one category)
                const catSection = document.getElementById('category-section');
                if (catSection) catSection.style.display = 'none';
                selectedManualCatId = 'Income';
            }
            if (typeof renderManualCategories === 'function') {
                renderManualCategories();
            }
        };

        window.updateManualAccountUI = (val) => {
            const box = document.getElementById('manual-account-icon-box');
            if (val === 'atome') {
                box.style.background = '#1a1a1a';
                box.style.color = '#fff';
            } else if (val === 'bpi') {
                box.style.background = '#931B1B';
                box.style.color = '#fff';
            } else {
                box.style.background = '#f8fafc';
                box.style.color = '#64748b';
            }
        };

        window.updateManualExcludeUI = (isExcluded) => {
            const box = document.getElementById('manual-exclude-icon-box');
            const icon = document.getElementById('manual-exclude-icon');
            const statusText = document.getElementById('manual-exclude-text');
            const toggle = document.getElementById('manual-exclude-toggle');

            if (isExcluded) {
                box.style.background = '#fef2f2';
                box.style.color = '#ef4444';
                icon.innerText = 'cancel';
                statusText.innerText = 'Excluded from Calculations';
                toggle.checked = true;
            } else {
                box.style.background = '#f0fdf4';
                box.style.color = '#16a34a';
                icon.innerText = 'check_circle';
                statusText.innerText = 'Included in Calculations';
                toggle.checked = false;
            }
        };

        window.toggleManualTxnExclusion = () => {
            const toggle = document.getElementById('manual-exclude-toggle');
            const newState = !toggle.checked;
            window.updateManualExcludeUI(newState);
        };

        window.openManualTxnModal = () => {
            const fab = document.querySelector('.fab');
            if (fab) {
                fab.classList.add('clicked');
                setTimeout(() => fab.classList.remove('clicked'), 300);
            }
            window.editingTxnId = null; // Clear edit mode
            document.getElementById('manual-amt').value = '';
            document.getElementById('manual-merchant').value = '';
            document.getElementById('manual-note').value = '';
            window.updateManualExcludeUI(false); // Reset to included
            
            // Dynamic Account Population
            const select = document.getElementById('manual-account');
            const accounts = window.walletAccounts || [];
            select.innerHTML = accounts.map(acc => `<option value="${acc.id}">${acc.name}</option>`).join('');

            // Default Account from current active
            const activeAcc = window.currentAccount || (accounts.length > 0 ? accounts[0].id : 'atome');
            select.value = activeAcc;
            updateManualAccountUI(activeAcc);
            
            // Default Category
            selectedManualCatId = 'Financial Expenses';
            setTxnType('expense');
            
            // Set Date Input to Today
            const d = formatLocalDate(new Date());
            document.getElementById('manual-date').value = d;
            
            // Enable Button
            const btn = document.getElementById('done-btn');
            if (btn) {
                btn.style.pointerEvents = 'auto';
                btn.style.opacity = '1';
                btn.innerText = 'Done';
            }
            
            // Update modal title
            const titleEl = document.getElementById('modal-title');
            if (titleEl) titleEl.innerText = 'New Transaction';

            if (typeof renderManualCategories === 'function') {
                renderManualCategories();
            }
            
            const modal = document.getElementById('manual-txn-modal');
            if (modal) {
                modal.style.display = 'flex'; // Reset inline style from closeModals
                modal.classList.add('show');
            }
            window.modalOpen = true;
            
            // Push history state for back button handling
            if (window.NavState) window.NavState.pushModalState('manual-txn', () => window.closeModals());
            
            // Remove global blur to fix blurry modal content issues
            // document.querySelector('.mobile-wrapper')?.classList.add('blur-active');
            
            setTimeout(() => document.getElementById('manual-amt').focus(), 300);
            
            // Add Enter key to save transaction
            const handleEnterKey = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (window.saveManualTxn) saveManualTxn();
                }
            };
            
            // Add listeners to form inputs
            ['manual-amt', 'manual-merchant', 'manual-note'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.removeEventListener('keydown', handleEnterKey);
                    el.addEventListener('keydown', handleEnterKey);
                }
            });
        };

        window.openEditModal = (txnId, merchant, amount, category, note) => {
            window.editingTxnId = txnId; // Set edit mode
            window.originalAccount = window.currentAccount || (txnId.startsWith('bpi_') ? 'bpi' : 'atome'); 
            
            // Find the transaction to get all its data
            const txn = (window.allTxns || []).find(t => t.id === txnId);
            const dateValue = txn ? txn.date : new Date();
            
            // Populate fields
            document.getElementById('manual-amt').value = amount;
            document.getElementById('manual-merchant').value = merchant;
            document.getElementById('manual-note').value = note || '';
            window.updateManualExcludeUI(txn ? txn.excluded === true : false);
            
            // Dynamic Account Population
            const select = document.getElementById('manual-account');
            const accounts = window.walletAccounts || [];
            if (accounts.length > 0) {
                select.innerHTML = accounts.map(acc => `<option value="${acc.id}">${acc.name}</option>`).join('');
            }

            // Set to account that holds this txn
            const activeAcc = window.originalAccount || window.currentAccount || 'atome';
            if (select.querySelector(`option[value="${activeAcc}"]`)) {
                select.value = activeAcc;
            }
            updateManualAccountUI(activeAcc);
            
            // Set date
            const d = formatLocalDate(new Date(dateValue));
            document.getElementById('manual-date').value = d;
            
            // Set category
            selectedManualCatId = (txn && txn.manualCategory) ? txn.manualCategory : category;
            
            // Determine type based on category
            if (selectedManualCatId === 'Income' || category === 'Income') {
                setTxnType('income');
            } else {
                setTxnType('expense');
            }
            
            // Enable Button
            const btn = document.getElementById('done-btn');
            if (btn) {
                btn.style.pointerEvents = 'auto';
                btn.style.opacity = '1';
                btn.innerText = 'Done';
            }
            
            // Update modal title
            const titleEl = document.getElementById('modal-title');
            if (titleEl) titleEl.innerText = 'Edit Transaction';

            renderManualCategories();
            const modal = document.getElementById('manual-txn-modal');
            if (modal) {
                modal.style.display = 'flex'; // Reset inline style from closeModals
                modal.classList.add('show');
            }
            window.modalOpen = true;
            
            // Push history state if not already handled by replaceModalState
            if (!window.modalOpen) {
                if (window.NavState) window.NavState.pushModalState('edit-txn', () => window.closeModals());
            }
            
            // Removed global blurring to match manual modal fix
            
            setTimeout(() => document.getElementById('manual-amt').focus(), 100);
            
            // ... (handleEnterKey logic remains the same)
            
            // Add Enter key to save transaction
            const handleEnterKey = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (window.saveManualTxn) saveManualTxn();
                }
            };
            
            ['manual-amt', 'manual-merchant', 'manual-note'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.removeEventListener('keydown', handleEnterKey);
                    el.addEventListener('keydown', handleEnterKey);
                }
            });
        };

        window.renderManualCategories = () => {
            const list = document.getElementById('manual-cat-list');
            // Filter out Income category when in expense mode
            const categoriesToShow = manualTxnType === 'expense' 
                ? CATEGORIES.filter(cat => cat.id !== 'Income')
                : CATEGORIES.filter(cat => cat.id === 'Income');
            
            list.innerHTML = categoriesToShow.map(cat => {
                const isSelected = cat.id === selectedManualCatId;
                let bgStyle = '#f1f5f9';
                let colorStyle = '#64748b';
                
                if (isSelected) {
                     if (cat.cls.includes('food')) { bgStyle = '#fefce8'; colorStyle = '#ca8a04'; } // Yellow
                     else if (cat.cls.includes('online')) { bgStyle = '#fff7ed'; colorStyle = '#ea580c'; } // Orange
                     else if (cat.cls.includes('shopping')) { bgStyle = '#f0f9ff'; colorStyle = '#0284c7'; } // Blue
                     else if (cat.cls.includes('vehicle')) { bgStyle = '#f5f3ff'; colorStyle = '#8b5cf6'; }
                     else if (cat.cls.includes('cat-aqua')) { bgStyle = '#ecfeff'; colorStyle = '#0891b2'; } // Dark Aqua
                     else if (cat.cls.includes('Service') || cat.cls.includes('magenta')) { bgStyle = '#fdf4ff'; colorStyle = '#d946ef'; } // Magenta
                     else if (cat.cls.includes('cat-education')) { bgStyle = '#eff6ff'; colorStyle = '#1d4ed8'; } // Dark Blue
                     else if (cat.cls.includes('cat-investments')) { bgStyle = '#dcfce7'; colorStyle = '#15803d'; } // Saturated Green
                     else if (cat.label.includes('Financial') || cat.label.includes('Trading')) { bgStyle = '#fef2f2'; colorStyle = '#ef4444'; } // Red
                     else { bgStyle = '#f0fdf4'; colorStyle = '#10b981'; } 
                }

                return `
                <div class="manual-cat-item ${isSelected ? 'selected' : ''}" onclick="selectManualCategory('${cat.id}')">
                    <div class="manual-cat-circle" style="background: ${bgStyle}; color: ${colorStyle};">
                        <i class="material-icons">${cat.icon}</i>
                    </div>
                    <span style="font-size: 11px; font-weight: 600; color: #1e293b; text-align: center;">${cat.label}</span>
                </div>
                `;
            }).join('');
        };

        window.selectManualCategory = (id) => {
            selectedManualCatId = id;
            renderManualCategories();
        };

        window.saveManualTxn = async () => {
            if (auth.currentUser?.isAnonymous) {
                if (confirm('Your data is in "Local Mode". Sign in with Google to permanently save this to the cloud?')) {
                    handleAuthClick();
                    return;
                }
            }
            const btn = document.getElementById('done-btn');
            const amtVal = document.getElementById('manual-amt').value;
            const selectedAccount = document.getElementById('manual-account').value;
            
            if (!amtVal || parseFloat(amtVal) <= 0) {
                showToast('Enter valid amount');
                return;
            }
            
            // Disable button
            btn.style.pointerEvents = 'none';
            btn.style.opacity = '0.5';
            
            let note = document.getElementById('manual-note').value.trim();
            // Enforce Title Case
            if (note) {
                note = note.replace(/\w\S*/g, (txt) => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
            }

            const dateVal = document.getElementById('manual-date').value;
            const dateObj = dateVal ? new Date(dateVal) : new Date();
            
            const cat = CATEGORIES.find(c => c.id === selectedManualCatId);
            
            const merchantName = document.getElementById('manual-merchant').value.trim();
            
            try {
                if (!auth.currentUser) return;
                const uid = auth.currentUser.uid;
                
                // Show loader on button
                btn.style.pointerEvents = 'none';
                btn.style.opacity = '0.7';
                btn.innerHTML = '<i class="material-icons spin" style="font-size:16px;">sync</i>';

                const updateData = {
                    date: formatLocalDate(dateObj),
                    amount: parseFloat(amtVal),
                    manualAmount: parseFloat(amtVal),
                    merchant: merchantName || (cat ? cat.label : 'Transaction'),
                    note: note || '',
                    manualCategory: selectedManualCatId,
                    category: selectedManualCatId,
                    type: manualTxnType,
                    excluded: document.getElementById('manual-exclude-toggle').checked
                };

                // Use the selected account in the modal
                const col = getCollectionName(selectedAccount);

                if (window.editingTxnId) {
                    const origAcc = window.originalAccount || (window.editingTxnId.startsWith('bpi_') ? 'bpi' : 'atome');
                    const originalCol = getCollectionName(origAcc);
                    
                    if (selectedAccount !== origAcc) {
                        // MOVE TRANSACTION: Delete from old, Add to new
                        if (!navigator.onLine) {
                            // Fire-and-forget ‚Äî Firestore IndexedDB will queue it
                            deleteDoc(doc(db, "users", uid, originalCol, window.editingTxnId));
                            setDoc(doc(db, "users", uid, col, window.editingTxnId), {
                                ...updateData,
                                createdAt: serverTimestamp()
                            });
                            addToOfflineQueue('edit', merchantName || (cat ? cat.label : 'Transaction'));
                        } else {
                            await deleteDoc(doc(db, "users", uid, originalCol, window.editingTxnId));
                            await setDoc(doc(db, "users", uid, col, window.editingTxnId), {
                                ...updateData,
                                createdAt: serverTimestamp()
                            });
                            showToast('Transaction moved & updated');
                        }
                    } else {
                        // Regular UPDATE
                        if (!navigator.onLine) {
                            updateDoc(doc(db, "users", uid, col, window.editingTxnId), updateData);
                            addToOfflineQueue('edit', merchantName || (cat ? cat.label : 'Transaction'));
                        } else {
                            await updateDoc(doc(db, "users", uid, col, window.editingTxnId), updateData);
                            showToast('Transaction updated');
                        }
                    }
                } else {
                    // NEW TRANSACTION
                    if (!navigator.onLine) {
                        addDoc(collection(db, "users", uid, col), {
                            ...updateData,
                            createdAt: serverTimestamp()
                        });
                        addToOfflineQueue('add', merchantName || (cat ? cat.label : 'Transaction'));
                    } else {
                        await addDoc(collection(db, "users", uid, col), {
                            ...updateData,
                            createdAt: serverTimestamp()
                        });
                        showToast('Transaction saved');
                    }
                }
                
                closeModals();
            } catch (e) {
                console.error(e);
                showToast('Error saving');
            } finally {
                // Restore button
                btn.style.pointerEvents = 'auto';
                btn.style.opacity = '1';
                btn.innerHTML = 'Done';
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê OFFLINE QUEUE SYSTEM ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        window.offlineQueue = JSON.parse(localStorage.getItem('offlineQueue') || '[]');

        function addToOfflineQueue(type, merchant) {
            const entry = { type, merchant, timestamp: Date.now() };
            window.offlineQueue.push(entry);
            localStorage.setItem('offlineQueue', JSON.stringify(window.offlineQueue));
            updateOfflineQueueCard();
            showOfflineSnackbar(type, merchant);
        }

        function updateOfflineQueueCard() {
            const card = document.getElementById('offline-queue-card');
            const countEl = document.getElementById('offline-queue-count');
            const titleEl = document.getElementById('offline-queue-title');
            const subEl = document.getElementById('offline-queue-sub');
            const iconEl = document.getElementById('offline-queue-icon-i');
            const count = window.offlineQueue.length;

            if (count === 0) {
                card.classList.add('hiding');
                setTimeout(() => {
                    card.classList.remove('show', 'hiding', 'uploading');
                }, 300);
                return;
            }

            countEl.textContent = count;
            card.classList.remove('hiding');
            card.classList.add('show');

            if (navigator.onLine) {
                card.classList.add('uploading');
                iconEl.textContent = 'cloud_upload';
                titleEl.textContent = 'Uploading...';
                subEl.textContent = `Syncing ${count} pending change${count > 1 ? 's' : ''}`;
            } else {
                card.classList.remove('uploading');
                iconEl.textContent = 'cloud_off';
                titleEl.textContent = 'Waiting for connection';
                subEl.textContent = `${count} pending change${count > 1 ? 's' : ''} saved locally`;
            }

            // Render individual items
            const listEl = document.getElementById('offline-queue-list');
            listEl.innerHTML = window.offlineQueue.map(item => {
                const badge = item.type === 'edit' 
                    ? '<span class="oq-badge oq-badge-edit">Edited</span>'
                    : '<span class="oq-badge oq-badge-add">Added</span>';
                return `<div class="oq-item">${badge}<span class="oq-merchant">${item.merchant}</span></div>`;
            }).join('');
        }

        function showOfflineSnackbar(type, merchant) {
            const snackbar = document.getElementById('offline-snackbar');
            const textEl = document.getElementById('offline-snackbar-text');
            const label = type === 'edit' ? 'Edited' : 'Added';
            textEl.textContent = `${label}: ${merchant}`;
            snackbar.classList.add('show');
            clearTimeout(window._offlineSnackTimer);
            window._offlineSnackTimer = setTimeout(() => {
                snackbar.classList.remove('show');
            }, 3000);
        }

        // Listen for connectivity changes
        window.addEventListener('online', () => {
            if (window.offlineQueue.length > 0) {
                updateOfflineQueueCard(); // Shows uploading state
                // Firestore auto-syncs queued writes ‚Äî we just clear the visual queue after a delay
                setTimeout(() => {
                    window.offlineQueue = [];
                    localStorage.removeItem('offlineQueue');
                    updateOfflineQueueCard(); // Hides card
                    showToast('All changes synced!');
                }, 3000);
            }
        });

        window.addEventListener('offline', () => {
            if (window.offlineQueue.length > 0) {
                updateOfflineQueueCard();
            }
        });

        // Restore card on page load if there are pending items
        if (window.offlineQueue.length > 0) {
            updateOfflineQueueCard();
        }

        // NEW: TRANSACTION FILTERS & LOGO TOGGLE
        let showLogos = true;
        
        window.toggleLogos = () => {
            showLogos = !showLogos;
            const icon = document.getElementById('logo-toggle-icon');
            const wrapper = document.querySelector('.logo-toggle-wrapper');
            
            if (showLogos) {
                icon.innerText = 'visibility';
                icon.style.color = '#0284c7';
                wrapper.style.background = '#e0f2fe';
                document.querySelectorAll('.brand-badge').forEach(b => b.style.display = 'flex');
            } else {
                icon.innerText = 'visibility_off';
                icon.style.color = '#94a3b8';
                wrapper.style.background = '#f1f5f9';
                document.querySelectorAll('.brand-badge').forEach(b => b.style.display = 'none');
            }
        };

        window.filterTxnList = () => {
            const catSelection = document.getElementById('txn-cat-filter').value;
            const keyword = (document.getElementById('txn-search')?.value || '').toLowerCase().trim();
            const cleanKeyword = keyword.replace(/,/g, '');
            
            const accordions = document.querySelectorAll('.month-accordion');
            
            accordions.forEach(acc => {
                const txns = acc.querySelectorAll('.premium-txn');
                let visibleCount = 0;
                let filteredTotal = 0;
                
                txns.forEach(t => {
                    const itemCatId = t.dataset.category || '';
                    const itemCatLabel = displayCategoryName(itemCatId);
                    const merchantName = (t.dataset.merchant || '').toLowerCase();
                    const note = (t.dataset.note || '').toLowerCase();
                    const amount = (t.dataset.amount || '').toString();
                    const cleanAmount = amount.replace(/,/g, '');
                    
                    const matchCat = (catSelection === 'all') || 
                                   (itemCatId.toLowerCase() === catSelection.toLowerCase()) || 
                                   (itemCatLabel.toLowerCase() === catSelection.toLowerCase());

                    const matchKeyword = !keyword || 
                                       merchantName.includes(keyword) || 
                                       note.includes(keyword) || 
                                       amount.includes(keyword) || 
                                       (cleanKeyword.length > 0 && cleanAmount.includes(cleanKeyword));

                    if (matchCat && matchKeyword) {
                        t.style.display = 'flex';
                        visibleCount++;
                        
                        // Calculate total for header
                        const isExcluded = t.classList.contains('txn-excluded') || t.dataset.excluded === 'true';
                        const isRefund = t.dataset.refund === 'true';
                        const isReimbursed = t.dataset.reimbursed === 'true';
                        
                        if (!isExcluded && !isRefund && !isReimbursed) {
                             const amt = parseFloat(t.dataset.amount) || 0;
                             const isIncome = (itemCatId === 'Income' || itemCatLabel === 'Income');
                             
                             if (catSelection === 'all') {
                                 // Default: Total = Sum of all non-income expenses
                                 if (!isIncome) filteredTotal += amt;
                             } else {
                                 // Specific filter: Sum everything that matched (Income or Expense)
                                 filteredTotal += amt;
                             }
                        }
                    } else {
                        t.style.display = 'none';
                    }
                });

                // Update Header Total for this month
                const totalEl = acc.querySelector('.month-total');
                if (totalEl) {
                    const isHidden = localStorage.getItem('balance_hidden') === 'true';
                    totalEl.dataset.raw = `‚Ç±${filteredTotal.toLocaleString(undefined, {minimumFractionDigits:2})}`;
                    totalEl.innerText = isHidden ? '******' : totalEl.dataset.raw;
                }

                // Auto-expand if search results found (only for specific searches >= 3 chars)
                const content = acc.querySelector('.month-content');
                const header = acc.querySelector('.month-header');
                const month = header.querySelector('.month-title').innerText;
                
                if (keyword.length >= 3 && visibleCount > 0) {
                    content.classList.remove('collapsed');
                    header.classList.remove('collapsed');
                } else if (keyword.length === 0) {
                    // Restore state from localStorage or default when search is cleared
                    const savedState = localStorage.getItem(`accordion_${month}`);
                    const index = Array.from(accordions).indexOf(acc);
                    const shouldBeCollapsed = savedState === 'collapsed' || (savedState === null && index !== 0);
                    
                    if (shouldBeCollapsed) {
                        content.classList.add('collapsed');
                        header.classList.add('collapsed');
                    } else {
                        content.classList.remove('collapsed');
                        header.classList.remove('collapsed');
                    }
                }

                // Hide the whole accordion if no visible items
                acc.style.display = visibleCount > 0 ? 'block' : 'none';
            });

            // Update Trends Chart to reflect category filter selection
            if (typeof window.refreshTrendChart === 'function') window.refreshTrendChart();
        };

        window.handleSearchInput = () => {
            const val = document.getElementById('txn-search').value;
            const clearBtn = document.getElementById('search-clear-btn');
            if (clearBtn) {
                if (val.length > 0) clearBtn.classList.add('active');
                else clearBtn.classList.remove('active');
            }
            filterTxnList();
        };

        window.clearSearch = () => {
            const input = document.getElementById('txn-search');
            input.value = '';
            document.getElementById('search-clear-btn').classList.remove('active');
            filterTxnList();
            input.focus();
        };

        // SMART BUDGETING LOGIC
        window.promptSetBudget = () => {
            const currentLimit = localStorage.getItem(`budget_${window.currentAccount}`) || '0';
            showAppDialog({
                title: 'Set Monthly Budget',
                message: 'Enter your maximum monthly spending goal (PHP).',
                input: true,
                value: currentLimit,
                callback: (limit) => {
                    if (limit !== null && limit !== false && !isNaN(limit)) {
                        localStorage.setItem(`budget_${window.currentAccount}`, limit);
                        updateBudgetUI();
                        showToast('Monthly budget updated!');
                    }
                }
            });
        };

        window.updateBudgetUI = () => {
            const limit = parseFloat(localStorage.getItem(`budget_${window.currentAccount}`)) || 0;
            const limitEl = document.getElementById('budget-limit');
            const spentEl = document.getElementById('budget-spent');
            const fillEl = document.getElementById('budget-fill');
            const card = document.getElementById('budget-card-section');

            if (!limit || limit <= 0) {
                if (card) card.style.display = 'none';
                return;
            }
            if (card) card.style.display = 'block';

            // Calculate spent this month
            let totalSpent = 0;
            if (window.allTxns) {
                const now = new Date();
                const currentMonth = now.getMonth();
                const currentYear = now.getFullYear();

                window.allTxns.forEach(t => {
                    const d = new Date(t.date);
                    if (d.getMonth() === currentMonth && d.getFullYear() === currentYear) {
                        const mapped = getMerchantDisplay(t.merchant, t);
                        // Only count non-income, non-refunded, non-excluded expenses
                        if (!t.excluded && !t.refund && mapped.category !== 'Income') {
                            const amt = t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0);
                            totalSpent += Math.abs(amt);
                        }
                    }
                });
            }

            const percent = Math.min((totalSpent / limit) * 100, 100);
            
            // UI Updates
            limitEl.innerText = `‚Ç±${limit.toLocaleString()} limit`;
            spentEl.innerText = `‚Ç±${totalSpent.toLocaleString(undefined, {minimumFractionDigits:2})} spent`;
            fillEl.style.width = `${percent}%`;

            // Color logic
            if (percent >= 100) {
                fillEl.style.background = '#ef4444'; // Red
                spentEl.style.color = '#ef4444';
            } else if (percent >= 80) {
                fillEl.style.background = '#f59e0b'; // Amber
                spentEl.style.color = '#f59e0b';
            } else {
                fillEl.style.background = '#10b981'; // Green
                spentEl.style.color = '#64748b';
            }

            // Alerts (Throttle to prevent spam)
            const lastAlert = sessionStorage.getItem(`budget_alert_${window.currentAccount}`);
            if (percent >= 100 && lastAlert !== '100') {
                showToast('‚ö†Ô∏è Budget limit reached!', 5000);
                sessionStorage.setItem(`budget_alert_${window.currentAccount}`, '100');
            } else if (percent >= 80 && lastAlert !== '80' && lastAlert !== '100') {
                showToast('üí° 80% of budget reached.', 4000);
                sessionStorage.setItem(`budget_alert_${window.currentAccount}`, '80');
            }
        };

        // PRIVACY LOCK LOGIC
        let pinInputBuffer = "";
        window.handlePinInput = (val) => {
            if (val === 'back') {
                pinInputBuffer = pinInputBuffer.slice(0, -1);
            } else if (pinInputBuffer.length < 4) {
                pinInputBuffer += val;
            }
            updatePinDots();
            if (pinInputBuffer.length === 4) {
                setTimeout(checkPin, 200);
            }
        };

        const updatePinDots = () => {
            const dots = document.querySelectorAll('#privacy-lock .pin-dot');
            dots.forEach((dot, idx) => {
                if (idx < pinInputBuffer.length) dot.classList.add('active');
                else dot.classList.remove('active');
            });
        };

        const checkPin = () => {
            const storedPin = localStorage.getItem('wallet_privacy_pin');
            if (pinInputBuffer === storedPin) {
                document.getElementById('privacy-lock').style.display = 'none';
                sessionStorage.setItem('wallet_unlocked', 'true');
                showToast('Wallet Unlocked');
            } else {
                showToast('Incorrect PIN', 2000);
                pinInputBuffer = "";
                updatePinDots();
                const dotsWrap = document.getElementById('pin-dots');
                dotsWrap.style.animation = 'shake 0.3s';
                setTimeout(() => dotsWrap.style.animation = '', 300);
            }
        };

        window.promptSetPin = () => {
            const currentPin = localStorage.getItem('wallet_privacy_pin');
            if (currentPin) {
                showAppDialog({
                    title: 'Verify Identity',
                    message: 'Enter current PIN to change security settings.',
                    input: true,
                    callback: (oldInput) => {
                        if (oldInput !== currentPin) return showToast("Wrong PIN. Access denied.");
                        requestNewPin();
                    }
                });
            } else {
                requestNewPin();
            }

            function requestNewPin() {
                showAppDialog({
                    title: 'New Privacy PIN',
                    message: 'Enter new 4-digit PIN (Numbers only) or leave empty to disable.',
                    input: true,
                    callback: (newPin) => {
                        if (newPin && newPin.length === 4 && !isNaN(newPin)) {
                            localStorage.setItem('wallet_privacy_pin', newPin);
                            showToast("PIN set successfully!");
                        } else if (newPin === "" || newPin === null) {
                            localStorage.removeItem('wallet_privacy_pin');
                            showToast("PIN Security Disabled");
                        } else if (newPin !== false) {
                            showToast("Invalid PIN format.");
                        }
                    }
                });
            }
        };

        window.initPrivacyLock = () => {
            const pin = localStorage.getItem('wallet_privacy_pin');
            const isUnlocked = sessionStorage.getItem('wallet_unlocked') === 'true';
            if (pin && !isUnlocked) {
                document.getElementById('privacy-lock').style.display = 'flex';
                if (window.PublicKeyCredential) {
                    document.getElementById('bio-btn').style.display = 'flex';
                }
            }
        };

        window.tryBiometricUnlock = async () => {
            // Simplified biometric check - in a real app, this would use WebAuthn credentials
            const confirmed = await showAppDialog({
                title: 'Biometric Unlock',
                message: 'Authenticate using FaceID / Fingerprint?',
                confirm: true
            });
            if (confirmed) {
                document.getElementById('privacy-lock').style.display = 'none';
                sessionStorage.setItem('wallet_unlocked', 'true');
                showToast('Authenticated via Biometrics');
            }
        };

        // ANALYTICS LOGIC (BAR CHART)
        window.drawCashFlowChart = () => {
            const container = document.getElementById('cashflow-bars');
            if (!container || !window.allTxns) return;

            // Get last 6 months
            const months = [];
            for (let i = 5; i >= 0; i--) {
                const d = new Date();
                d.setDate(1); // Avoid month skipping near end of month
                d.setMonth(d.getMonth() - i);
                months.push({
                    name: d.toLocaleDateString('en-US', { month: 'short' }),
                    month: d.getMonth(),
                    year: d.getFullYear(),
                    income: 0,
                    expense: 0
                });
            }

            // Aggregate data
            window.allTxns.forEach(t => {
                const d = new Date(t.date);
                const mIdx = months.findIndex(m => m.month === d.getMonth() && m.year === d.getFullYear());
                if (mIdx > -1) {
                    const mapped = getMerchantDisplay(t.merchant, t);
                    const amt = Math.abs(t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0));
                    if (!t.excluded && !t.refund && !t.reimbursed) {
                        if (mapped.category === 'Income') months[mIdx].income += amt;
                        else months[mIdx].expense += amt;
                    }
                }
            });

            // Find max for scaling
            const maxVal = Math.max(...months.map(m => Math.max(m.income, m.expense)), 1000);
            
            // Render Bars
            let html = '';
            months.forEach(m => {
                const incH = (m.income / maxVal) * 80;
                const expH = (m.expense / maxVal) * 80;
                html += `
                    <div class="bar-group">
                        <div class="bars-pair">
                            <div class="bar bar-income" style="height: ${incH}px;" title="Income: ‚Ç±${m.income.toLocaleString()}"></div>
                            <div class="bar bar-expense" style="height: ${expH}px;" title="Expense: ‚Ç±${m.expense.toLocaleString()}"></div>
                        </div>
                        <div class="bar-label">${m.name}</div>
                    </div>
                `;
            });
            container.innerHTML = html;

            // Savings Rate for current month
            const current = months[months.length - 1];
            const rate = current.income > 0 ? ((current.income - current.expense) / current.income) * 100 : 0;
            const rateEl = document.getElementById('savings-rate-val');
            if (rateEl) {
                rateEl.innerText = `${Math.max(0, rate).toFixed(1)}%`;
                const chip = rateEl.closest('.savings-chip');
                const isDark = document.body.classList.contains('dark-mode');
                if (chip) chip.style.background = rate > 0 ? (isDark ? 'rgba(16, 185, 129, 0.2)' : '#dcfce7') : (isDark ? 'rgba(239, 68, 68, 0.2)' : '#fee2e2');
                if (chip) chip.style.color = rate > 0 ? (isDark ? '#34d399' : '#166534') : (isDark ? '#f87171' : '#991b1b');
            }
        };

        // SUBSCRIPTION DETECTION LOGIC
        // SUBSCRIPTION DETECTION LOGIC (WITH AVERAGES)
        window.detectSubscriptions = () => {
            const container = document.getElementById('subscription-list');
            const section = document.getElementById('subscription-section');
            if (!container || !window.allTxns) return;

            // Context: Current month for comparison
            const now = new Date(); 
            const targetMonth = now.getMonth();
            const targetYear = now.getFullYear();

            // Group by Merchant + Month
            const merchantData = {};
            window.allTxns.forEach(t => {
                const mapped = getMerchantDisplay(t.merchant, t);
                if (t.excluded || t.refund || t.reimbursed || mapped.category === 'Income') return;
                
                const amt = Math.abs(t.manualAmount !== undefined ? t.manualAmount : (t.amount || 0));
                if (amt < 50) return;

                let merchantKey = mapped.name.toLowerCase();
                let displayName = mapped.name;

                // Combine Tecfuel entries (San Remigio, Bogo, etc.)
                const noteLower = (t.note || '').toLowerCase();
                if (merchantKey.includes('tecfuel') || merchantKey.includes('tec fuel') || 
                    noteLower.includes('tecfuel') || noteLower.includes('tec fuel')) {
                    merchantKey = 'tecfuel';
                    displayName = 'TECFUEL';
                }

                const d = (t.date && t.date.seconds) ? new Date(t.date.seconds * 1000) : new Date(t.date);
                const monthKey = `${d.getMonth()}-${d.getFullYear()}`;

                if (!merchantData[merchantKey]) {
                    // LOGO MAPPING: Assign logos based on merchant name
                    let iconPath = mapped.logo || 'receipt_long';
                    const mLower = merchantKey.toLowerCase();
                    
                    if (mLower.includes('tecfuel') || mLower.includes('tec fuel')) iconPath = 'logos/tecfuel.png';
                    else if (mLower.includes('spotify')) iconPath = 'logos/spotify.png';
                    else if (mLower.includes('shopee')) iconPath = 'logos/shopee.png';
                    else if (mLower.includes('traders') || mLower.includes('tradersconnect')) iconPath = 'logos/tradersconnect.png';
                    else if (mLower.includes('mr diy') || mLower.includes('mrdiy')) iconPath = 'logos/mrdiy.png';
                    else if (mLower.includes('jollibee')) iconPath = 'logos/jollibee.png';
                    else if (mLower.includes('mcdo') || mLower.includes('mcdonald')) iconPath = 'logos/mcdo.png';
                    else if (mLower.includes('shell')) iconPath = 'logos/shell.png';
                    else if (mLower.includes('petron')) iconPath = 'logos/petron.png';
                    else if (mLower.includes('seaoil')) iconPath = 'logos/seaoil.png';
                    else if (mLower.includes('lazada')) iconPath = 'logos/lazada.jpg';
                    else if (mLower.includes('globe') || mLower.includes('gomo')) iconPath = 'logos/globe.png';
                    else if (mLower.includes('tiktok')) iconPath = 'logos/tiktokshop.png';
                    else if (mLower.includes('watsons')) iconPath = 'logos/watsons.png';
                    else if (mLower.includes('sm ') || mLower === 'sm' || mLower.includes('sm store')) iconPath = 'logos/sm.png';
                    else if (mLower.includes('7-11') || mLower.includes('7 11') || mLower.includes('7/11') || mLower.includes('711')) iconPath = 'logos/711.png';
                    else if (mLower.includes('metro') || mLower.includes('super metro')) iconPath = 'logos/supermetro.png';
                    else if (mLower.includes('ayala')) iconPath = 'logos/ayala.png';
                    else if (mLower.includes('j and l') || mLower.includes('j&l')) iconPath = 'logos/jandlmall.png';

                    merchantData[merchantKey] = {
                        name: displayName,
                        icon: iconPath,
                        monthlySpend: {},
                        countMonths: 0,
                        currentMonthSpend: 0,
                        averageSpend: 0
                    };
                }

                if (!merchantData[merchantKey].monthlySpend[monthKey]) {
                    merchantData[merchantKey].monthlySpend[monthKey] = 0;
                }
                merchantData[merchantKey].monthlySpend[monthKey] += amt;
            });

            const subs = [];
            Object.values(merchantData).forEach(m => {
                const monthKeys = Object.keys(m.monthlySpend);
                if (monthKeys.length < 1) return;

                // Sort month keys chronologically: "M-YYYY"
                const sortedKeys = monthKeys.sort((a,b) => {
                    const [ma, ya] = a.split('-').map(Number);
                    const [mb, yb] = b.split('-').map(Number);
                    return ya === yb ? ma - mb : ya - yb;
                });

                // Check for 4 consecutive months
                let maxConsecutive = 0;
                let currentConsecutive = 0;
                let lastMonthIndex = -1;

                sortedKeys.forEach(k => {
                    const [mon, yr] = k.split('-').map(Number);
                    const monthIndex = yr * 12 + mon;
                    if (lastMonthIndex === -1 || monthIndex === lastMonthIndex + 1) {
                        currentConsecutive++;
                    } else {
                        currentConsecutive = 1;
                    }
                    lastMonthIndex = monthIndex;
                    if (currentConsecutive > maxConsecutive) maxConsecutive = currentConsecutive;
                });

                const mName = m.name.toLowerCase();
                
                // WHITELIST: Important recurring merchants that should always appear if present in last 4 months
                const isWhitelisted = mName.includes('spotify') || 
                                      mName.includes('traders connect') ||
                                      mName.includes('mr diy') || mName.includes('mrdiy') ||
                                      mName.includes('tecfuel') || mName.includes('tec fuel') ||
                                      mName.includes('jollibee') ||
                                      mName.includes('shell') ||
                                      mName.includes('petron') ||
                                      mName.includes('globe') || mName.includes('gomo');
                
                // NEW LOGIC: Check if present in at least 2 of the last 4 months (allows gaps)
                const last4Months = [];
                for (let i = 0; i < 4; i++) {
                    const d = new Date(targetYear, targetMonth - i, 1);
                    last4Months.push(`${d.getMonth()}-${d.getFullYear()}`);
                }
                const presentInLast4 = last4Months.filter(k => m.monthlySpend[k]).length;
                
                // Whitelisted merchants need 2+ months in last 4, others need 4 consecutive
                if (isWhitelisted) {
                    if (presentInLast4 < 2) return;
                } else if (maxConsecutive < 4) return;

                const currentKey = `${targetMonth}-${targetYear}`;
                m.currentMonthSpend = m.monthlySpend[currentKey] || 0;

                let historicalSum = 0;
                let historicalCount = 0;
                monthKeys.forEach(k => {
                    if (k !== currentKey) {
                        historicalSum += m.monthlySpend[k];
                        historicalCount++;
                    }
                });

                // If we have history, use average. If only current (whitelisted), use current.
                m.averageSpend = historicalCount > 0 ? (historicalSum / historicalCount) : m.currentMonthSpend;
                subs.push(m);
            });

            if (subs.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            let totalCurrent = 0;
            let totalAvg = 0;

            container.innerHTML = subs.sort((a,b) => b.currentMonthSpend - a.currentMonthSpend).map(g => {
                totalCurrent += g.currentMonthSpend;
                totalAvg += g.averageSpend;
                const perc = g.averageSpend > 0 ? (g.currentMonthSpend / g.averageSpend) * 100 : 0;
                const statusColor = g.currentMonthSpend > g.averageSpend ? '#ef4444' : '#10b981';
                const barColor = g.currentMonthSpend > g.averageSpend ? '#ef4444' : '#3b82f6';

                return `
                <div class="subscription-item">
                    <div class="sub-main-row">
                        <div class="sub-icon">
                            ${g.icon.includes('logos/') || /\.(png|jpg|jpeg|svg|gif)$/i.test(g.icon) ? `<img src="${g.icon}" style="width:20px; border-radius:5px;">` : `<i class="material-icons">${g.icon}</i>`}
                        </div>
                        <div class="sub-info">
                            <div class="sub-name">${g.name}</div>
                            <div class="sub-meta">Avg: ‚Ç±${g.averageSpend.toLocaleString(undefined, {maximumFractionDigits:0})} / mo</div>
                        </div>
                        <div class="sub-stats">
                            <div class="sub-current-vs-avg" style="font-weight: 800; font-size: 11px;">
                                <span style="color: ${statusColor};">‚Ç±${g.currentMonthSpend.toLocaleString(undefined, {maximumFractionDigits:0})}</span>
                                <span style="color: #cbd5e1; margin: 0 2px;">/</span>
                                <span style="color: #94a3b8;">‚Ç±${g.averageSpend.toLocaleString(undefined, {maximumFractionDigits:0})}</span>
                            </div>
                        </div>
                    </div>
                    <div class="sub-item-progress-bg">
                        <div class="sub-item-progress-fill" style="width: ${Math.min(100, perc)}%; background: ${barColor};"></div>
                    </div>
                </div>
                `;
            }).join('');

            // Update UI Labels for Total
            const limit = parseFloat(localStorage.getItem('wallet_sub_limit') || 5000);
            document.getElementById('sub-count-badge').innerText = subs.length;
            document.getElementById('sub-total-label').innerText = `‚Ç±${totalCurrent.toLocaleString(undefined, {minimumFractionDigits:2})} spent`;
            document.getElementById('sub-limit-label').innerText = `Target: ‚Ç±${limit.toLocaleString(undefined, {maximumFractionDigits:0})}`;
            
            const totalPerc = limit > 0 ? (totalCurrent / limit) * 100 : 0;
            const fill = document.getElementById('sub-limit-fill');
            fill.style.width = Math.min(100, totalPerc) + '%';
            
            // Premium color for main bar
            fill.style.background = totalPerc >= 100 ? '#ef4444' : '#000'; // Black theme or Red if over

            // Ensure divider exists after progress bar
            let divider = document.getElementById('sub-main-divider');
            if (!divider) {
                divider = document.createElement('div');
                divider.id = 'sub-main-divider';
                divider.style = "height: 1px; background: #f1f5f9; margin: 15px 0 5px; width: 100%;";
                document.querySelector('.sub-limit-bar').after(divider);
            }
        };

        window.updateSubAmount = (name, val) => {
            const num = parseFloat(val);
            if (isNaN(num)) return;
            showToast(`Target updated for ${name}`);
            detectSubscriptions();
        };

        window.promptSetSubLimit = () => {
            showAppDialog({
                title: 'Set Target Spend',
                message: 'Adjust the total spend limit for recurring items.',
                input: true,
                value: localStorage.getItem('wallet_sub_limit') || '5000',
                callback: (val) => {
                    if (val) {
                        localStorage.setItem('wallet_sub_limit', val);
                        detectSubscriptions();
                        showToast('Target updated');
                    }
                }
            });
        };

        // NEW: Independent Trend Chart Logic
        window.refreshTrendChart = () => {
            if (!window.allTxns) return;
            drawTrendChart(window.allTxns);
        };

        // Override injectBrandLogos to respect visibility
        const originalInject = injectBrandLogos;
        injectBrandLogos = () => {
            const txns = document.querySelectorAll('.premium-txn');
            txns.forEach(txn => {
                const merchantEl = txn.querySelector('.txn-merch');
                if (!merchantEl) return;
                const merchantName = merchantEl.textContent.toUpperCase();
                const iconBox = txn.querySelector('.icon-box');
                if (!iconBox || iconBox.querySelector('.brand-badge')) return;
                
                let logo = null;
                if (merchantName.includes('JOLLIBEE')) logo = 'logos/jollibee.png';
                else if (merchantName.includes('MCDO') || merchantName.includes('MCDONALDS')) logo = 'logos/mcdo.png';
                else if (merchantName.includes('SHELL')) logo = 'logos/shell.png';
                else if (merchantName.includes('SHOPEE')) logo = 'logos/shopee.png';
                else if (merchantName.includes('LAZADA')) logo = 'logos/lazada.jpg';
                else if (merchantName.includes('GLOBE') || merchantName.includes('GOMO')) logo = 'logos/globe.png';
                else if (merchantName.includes('SM ') || merchantName.includes('SM STORE') || merchantName.includes('SM SUPERMARKET')) logo = 'logos/sm.png';
                else if (merchantName.includes('SPOTIFY')) logo = 'logos/spotify.png';
                else if (merchantName.includes('TIKTOK')) logo = 'logos/tiktokshop.png';
                else if (merchantName.includes('TECFUEL') || merchantName.includes('TEC FUEL')) logo = 'logos/tecfuel.png';
                else if (merchantName.includes('TRADERS')) logo = 'logos/tradersconnect.png';
                else if (merchantName.includes('AYALA')) logo = 'logos/ayala.png';
                else if (merchantName.includes('JNL') || merchantName.includes('JL')) logo = 'logos/jandlmall.png';
                else if (merchantName.includes('J AND L') || merchantName.includes('JNL')) logo = 'logos/jandlmall.png';
                else if (merchantName.includes('MR DIY')) logo = 'logos/mrdiy.png';
                else if (merchantName.includes('WATSONS')) logo = 'logos/watsons.png';

                if (logo) {
                    const badge = document.createElement('div');
                    badge.className = 'brand-badge';
                    badge.innerHTML = `<img src="${logo}" alt="brand">`;
                    badge.style.display = showLogos ? 'flex' : 'none';
                    iconBox.appendChild(badge);
                }
            });
        };
    </script>
    
    <!-- CATEGORY MODAL -->
    <div id="cat-modal" class="modal-overlay">
        <div class="custom-modal">
            <div class="modal-header">Change Category</div>
            <p style="color: #64748b; font-size: 13px;">Select a new category for this transaction.</p>
            <div class="modal-body">
                <div id="cat-grid" class="cat-grid">
                    <!-- Categories injected here -->
                </div>
            </div>
            <div class="modal-actions" style="margin-top: 8px; justify-content: center;">
                <!-- Selection closes modal automatically -->
            </div>
        </div>
    </div>

    <!-- NOTE MODAL -->
    <div id="note-modal" class="modal-overlay">
        <div class="custom-modal">
            <div class="modal-header">Add Note</div>
            <p style="color: #64748b; font-size: 13px;">Personalized note for this transaction.</p>
            <div class="modal-body">
                <div style="position: relative;">
                    <textarea id="note-text" class="note-input" maxlength="30" placeholder="Enter note here..."></textarea>
                    <div id="note-counter" style="position: absolute; right: 8px; bottom: 8px; font-size: 10px; color: #94a3b8; font-weight: 600;">0/30</div>
                </div>
            </div>
            <div class="modal-actions" style="margin-top: 8px; align-items: center;">
                <button class="mui-btn mui-btn--raised mui-btn--primary" id="save-note-btn" style="width: 100%; border-radius: 10px; font-weight: 700; letter-spacing: 0.5px; padding: 0 24px; height: 42px; background-color: #2196F3;">SAVE NOTE</button>
            </div>
        </div>
    </div>

    <!-- PRICE MODAL -->
    <div id="price-modal" class="modal-overlay">
        <div class="custom-modal">
            <div class="modal-header">Change Price</div>
            <p style="color: #64748b; font-size: 13px;">Update the transaction amount manually.</p>
            <div class="modal-body">
                <div style="position: relative;">
                    <input type="number" id="price-input" class="note-input" style="min-height: auto; font-size: 18px; font-weight: 700; text-align: center;" placeholder="0.00" step="0.01">
                </div>
            </div>
            <div class="modal-actions" style="margin-top: 12px; align-items: center;">
                <button class="mui-btn mui-btn--raised mui-btn--primary" onclick="savePrice()" style="width: 100%; border-radius: 10px; font-weight: 700; letter-spacing: 0.5px; padding: 0 24px; height: 42px; background-color: #2196F3;">SAVE PRICE</button>
            </div>
        </div>
    </div>

    <!-- AUTH TROUBLESHOOTER MODAL -->
    <div id="auth-trouble-modal" class="modal-overlay">
        <div class="custom-modal" style="border-top: 5px solid #ef4444;">
            <div class="modal-header" style="display:flex; align-items:center; gap:8px; color:#ef4444;">
                <i class="material-icons">warning</i> 
                <span>Login Error</span>
            </div>
            <div style="font-size: 14px; color: #1e293b; margin-bottom: 15px; font-weight: 600;">
                The request returned: <code id="auth-error-code" style="color:#ef4444; background:#fee2e2; padding:2px 4px; border-radius:4px;">auth/invalid-action...</code>
            </div>
            <div style="background: #f8fafc; border-radius: 12px; padding: 15px; border: 1px solid #e2e8f0; margin-bottom: 20px;">
                <p style="font-size: 13px; font-weight: 700; color: #475569; margin: 0 0 10px 0;">Troubleshoot checklist:</p>
                <ul style="font-size: 12.5px; color: #64748b; margin: 0; padding-left: 20px; line-height: 1.6;">
                    <li><strong>Check URL:</strong> Ensure you are using <code style="font-weight:bold;">127.0.0.1:5500</code> (Not localhost if unauthorized).</li>
                    <li><strong>Authorized Domains:</strong> Add <code style="font-weight:bold;">127.0.0.1</code> to Firebase Console > Authentication > Settings.</li>
                    <li><strong>API Restrictions:</strong> Ensure your API key in Google Cloud Console allows this domain.</li>
                </ul>
            </div>
            <div class="modal-actions">
                <button class="mui-btn mui-btn--raised" onclick="closeModals()" style="border-radius:10px; font-weight:700; background:#f1f5f9; color:#475569;">CLOSE</button>
                <button class="mui-btn mui-btn--raised mui-btn--primary" onclick="window.location.reload()" style="border-radius:10px; font-weight:700;">RELOAD APP</button>
            </div>
        </div>
    </div>

    <!-- DELETE CONFIRMATION MODAL -->
    <div id="delete-modal" class="modal-overlay">
        <div class="custom-modal" style="text-align: center;">
            <div class="modal-header" style="color: #ef4444; justify-content: center; margin-bottom: 8px;">Delete Transaction?</div>
            <p style="color: #64748b; font-size: 13px; margin: 0 0 24px 0;">You can undo this within 7 seconds.</p>
            <div class="modal-actions" style="justify-content: center; gap: 16px;">
                <div class="cancel-link" onclick="closeModals()">CANCEL</div>
                <button class="mui-btn mui-btn--raised" onclick="confirmDelete()" style="border-radius: 12px; font-weight: 700; background: #ef4444; color: white; box-shadow: 0 4px 10px rgba(239, 68, 68, 0.3);">DELETE</button>
            </div>
        </div>
    </div>
 
    <!-- UNDO DELETE SNACKBAR STACK -->
    <div id="undo-stack" class="undo-stack"></div>

    <!-- PREMIUM OBLIGATION MODAL -->
    <div id="obligation-modal" class="dialog-overlay">
        <div class="dialog-card">
            <div id="ob-modal-title" class="dialog-title">New Obligation</div>
            <div class="dialog-msg">Enter a title and amount for this fixed obligation.</div>
            
            <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px;">
                <div style="font-size: 10px; font-weight: 800; color: #94a3b8; text-transform: uppercase; margin-bottom: -10px;">Title</div>
                <input type="text" id="ob-input-title" class="dialog-input" style="margin-bottom: 0;" placeholder="e.g. Rent, Bills">
                
                <div style="font-size: 10px; font-weight: 800; color: #94a3b8; text-transform: uppercase; margin-bottom: -10px;">Amount (PHP)</div>
                <input type="number" id="ob-input-amount" class="dialog-input" style="margin-bottom: 0;" placeholder="0.00">
            </div>

            <div class="dialog-actions">
                <button onclick="closeObligationModal()" class="dialog-btn dialog-btn--cancel">Cancel</button>
                <button id="ob-save-btn" class="dialog-btn dialog-btn--primary">SAVE</button>
            </div>
        </div>
    </div>

    <!-- UNIFIED APP DIALOG MODAL -->
    <div id="app-dialog" class="dialog-overlay">
        <div class="dialog-card">
            <div id="dialog-title" class="dialog-title">Alert</div>
            <div id="dialog-msg" class="dialog-msg">Something happened.</div>
            <div id="dialog-input-container" style="display: none;">
                <input type="text" id="dialog-input" class="dialog-input">
            </div>
            <div class="dialog-actions">
                <button id="dialog-cancel-btn" class="dialog-btn dialog-btn--cancel" style="display: none;">Cancel</button>
                <button id="dialog-ok-btn" class="dialog-btn dialog-btn--primary">OK</button>
            </div>
        </div>
    </div>

    <!-- iOS STYLE LONG PRESS ELEMENTS -->
    <div class="blur-overlay" id="blur-overlay" onclick="closeIOSMenu()"></div>
    
    <div class="ios-action-menu" id="ios-menu">
        <div class="ios-action-item" id="ios-action-edit">
            <i class="material-icons">edit</i>
            <span>Edit Transaction</span>
        </div>
        <div class="ios-action-item" id="ios-action-exclude">
            <i class="material-icons">block</i>
            <span>Exclude</span>
        </div>
        <div class="ios-action-item warning" id="ios-action-refund">
            <i class="material-icons">undo</i>
            <span>Unmark Refund</span>
        </div>
        <div class="ios-action-item danger" id="ios-action-delete">
            <i class="material-icons">delete</i>
            <span>Delete</span>
        </div>
    </div>

    <!-- DUPLICATE TRANSACTION MODAL -->
    <div id="duplicate-modal" class="modal-overlay" style="align-items: flex-end; justify-content: center; backdrop-filter: blur(4px); background: rgba(0,0,0,0.4);">
        <div class="custom-modal" id="duplicate-modal-content" style="width: 100%; max-width: 100%; border-radius: 24px 24px 0 0; padding: 24px; box-shadow: 0 -10px 40px rgba(0,0,0,0.1); position: relative; animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1);">
            <div class="modal-header" style="font-weight: 800; font-size: 18px; color: #1e293b;">Duplicate Transaction</div>
            <p style="color: #64748b; font-size: 13px; margin: 8px 0 16px;">Select which accounts to duplicate this transaction into.</p>
            <div class="modal-body">
                <div id="duplicate-account-list" style="display: flex; flex-direction: column; gap: 12px;">
                    <!-- Account checkboxes will be injected here -->
                </div>
            </div>
            <div class="modal-actions" style="margin-top: 24px; justify-content: space-between; align-items: center;">
                <div class="cancel-link" onclick="closeModals()" style="padding-left: 0;">CANCEL</div>
                <button class="mui-btn mui-btn--raised mui-btn--primary" onclick="confirmDuplicate()" style="border-radius: 12px; font-weight: 700; background-color: #2196F3; height: 44px; padding: 0 32px;">DUPLICATE</button>
            </div>
        </div>
    </div>

    <!-- MANUAL TRANSACTION MODAL -->
    <div id="manual-txn-modal" class="modal-overlay" style="align-items: flex-end; justify-content: center; backdrop-filter: blur(4px); background: rgba(0,0,0,0.4);">
        <div class="custom-modal" id="manual-modal-content" style="width: 100%; max-width: 100%; border-radius: 24px 24px 0 0; padding: 0; box-shadow: 0 -10px 40px rgba(0,0,0,0.1); height: 96vh; overflow-y: auto; position: relative; animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1); touch-action: pan-y;">
            
            <!-- Swipe Handle Area (includes title) -->
            <div id="modal-drag-handle" style="width: 100%; padding: max(45px, env(safe-area-inset-top)) 0 8px 0; background: white; border-radius: 24px 24px 0 0; position: sticky; top: 0; z-index: 100; cursor: grab; border-bottom: 1px solid #f1f5f9;">
                <div style="display: flex; justify-content: center; margin-bottom: 12px;">
                    <div style="width: 40px; height: 4px; background: #cbd5e1; border-radius: 2px;"></div>
                </div>
                <div style="padding: 0 20px 16px 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <i class="material-icons" onclick="closeModals()" style="color: #64748b; font-size: 28px; cursor: pointer;">close</i>
                        <div id="modal-title" style="font-weight: 800; font-size: 18px; color: #1e293b;">New Transaction</div>
                        <div id="done-btn" style="font-weight: 800; font-size: 16px; color: #10b981; cursor: pointer; text-transform: uppercase;" onclick="saveManualTxn()">Done</div>
                    </div>
                </div>
            </div>
            
            <div style="padding: 0 20px 20px 20px;">
            <!-- Toggler -->
            <div style="display: flex; background: #f1f5f9; padding: 4px; border-radius: 12px; margin-bottom: 30px;">
                <div id="btn-expense" onclick="setTxnType('expense')" style="flex: 1; padding: 8px; text-align: center; background: #ef4444; color: #fff; font-weight: 700; border-radius: 8px; font-size: 13px; box-shadow: 0 4px 10px rgba(239, 68, 68, 0.3); transition: all 0.2s; cursor: pointer;">Expense</div>
                <div id="btn-income" onclick="setTxnType('income')" style="flex: 1; padding: 8px; text-align: center; color: #64748b; font-weight: 600; font-size: 13px; border-radius: 8px; transition: all 0.2s; cursor: pointer;">Income</div>
            </div>

            <!-- Amount Input -->
            <!-- Amount Input -->
            <div style="text-align: center; margin-bottom: 20px;">
                <div style="font-size: 12px; color: #94a3b8; font-weight: 700; letter-spacing: 1px; margin-bottom: 8px;">AMOUNT</div>
                <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                    <span style="font-size: 24px; font-weight: 700; color: #cbd5e1;">PHP</span>
                    <input type="number" id="manual-amt" placeholder="0.00" style="font-size: 48px; font-weight: 800; color: #1e293b; border: none; outline: none; width: 220px; text-align: center; background: transparent;" step="0.01">
                </div>
            </div>

            <!-- Category Section -->
            <div id="category-section" style="margin-bottom: 0;">
                <div style="font-size: 11px; color: #94a3b8; font-weight: 700; letter-spacing: 1px; margin-bottom: 12px; padding-left: 4px;">CATEGORY</div>
                <div id="manual-cat-list" style="display: flex; overflow-x: auto; gap: 20px; padding: 4px 4px 20px 4px; scroll-behavior: smooth; -webkit-overflow-scrolling: touch;">
                    <!-- Categories injected by JS -->
                </div>
            </div>

            <!-- Details List -->
            <div style="display: flex; flex-direction: column; gap: 12px; margin-top: 10px;">
                
                <!-- Account Selection Row -->
                <div style="display: flex; align-items: center; background: #fff; border: 1px solid #e2e8f0; padding: 12px 16px; border-radius: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.02);">
                    <div id="manual-account-icon-box" style="width: 40px; height: 40px; border-radius: 12px; background: #1a1a1a; display: flex; align-items: center; justify-content: center; margin-right: 14px; color: #fff; transition: all 0.3s ease;">
                        <i class="material-icons" style="font-size: 20px;">account_balance_wallet</i>
                    </div>
                    <div style="flex: 1;">
                        <div style="font-size: 9px; color: #94a3b8; font-weight: 700; text-transform: uppercase; margin-bottom: 2px;">Account</div>
                        <select id="manual-account" onchange="updateManualAccountUI(this.value)" style="width: 100%; border: none; outline: none; font-size: 14px; font-weight: 700; color: #1e293b; background: transparent; padding: 0; appearance: none; -webkit-appearance: none; cursor: pointer;">
                            <option value="atome">Atome Account</option>
                            <option value="bpi">BPI Account</option>
                        </select>
                    </div>
                    <i class="material-icons" style="color: #cbd5e1; font-size: 20px;">unfold_more</i>
                </div>

                <!-- Date Row -->
                <div style="display: flex; align-items: center; background: #fff; border: 1px solid #e2e8f0; padding: 12px 16px; border-radius: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.02); cursor: pointer;" onclick="document.getElementById('manual-date').showPicker()">
                    <div style="width: 40px; height: 40px; border-radius: 12px; background: #f0f9ff; display: flex; align-items: center; justify-content: center; margin-right: 14px; color: #0284c7;">
                        <i class="material-icons" style="font-size: 20px;">calendar_today</i>
                    </div>
                    <div style="flex: 1;">
                        <div style="font-size: 9px; color: #94a3b8; font-weight: 700; text-transform: uppercase; margin-bottom: 2px;">Date</div>
                        <input type="date" id="manual-date" style="border: none; outline: none; font-size: 14px; font-weight: 700; color: #1e293b; font-family: inherit; background: transparent; cursor: pointer; text-align: left; width: 100%; padding: 0;">
                    </div>
                </div>

                <!-- Merchant Name Row -->
                <div style="display: flex; align-items: center; background: #fff; border: 1px solid #e2e8f0; padding: 12px 16px; border-radius: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.02);">
                    <div style="width: 40px; height: 40px; border-radius: 12px; background: #fefce8; display: flex; align-items: center; justify-content: center; margin-right: 14px; color: #ca8a04;">
                        <i class="material-icons" style="font-size: 20px;">store</i>
                    </div>
                    <div style="flex: 1;">
                        <div style="font-size: 9px; color: #94a3b8; font-weight: 700; text-transform: uppercase; margin-bottom: 2px;">Merchant Name</div>
                        <input type="text" id="manual-merchant" maxlength="50" placeholder="Enter merchant name..." style="width: 100%; border: none; outline: none; font-size: 14px; font-weight: 600; color: #1e293b; background: transparent; padding: 0;">
                    </div>
                </div>

                <!-- Notes Row -->
                <div style="display: flex; align-items: center; background: #fff; border: 1px solid #e2e8f0; padding: 12px 16px; border-radius: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.02);">
                    <div style="width: 40px; height: 40px; border-radius: 12px; background: #f8fafc; display: flex; align-items: center; justify-content: center; margin-right: 14px; color: #64748b;">
                        <i class="material-icons" style="font-size: 20px;">notes</i>
                    </div>
                    <div style="flex: 1;">
                        <div style="font-size: 9px; color: #94a3b8; font-weight: 700; text-transform: uppercase; margin-bottom: 2px;">Notes</div>
                        <input type="text" id="manual-note" maxlength="30" placeholder="Add notes..." style="width: 100%; border: none; outline: none; font-size: 14px; font-weight: 600; color: #1e293b; background: transparent; padding: 0;">
                    </div>
                </div>

                <!-- Include/Exclude Toggle Row -->
                <div style="display: flex; align-items: center; background: #fff; border: 1px solid #e2e8f0; padding: 12px 16px; border-radius: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.02); cursor: pointer;" onclick="toggleManualTxnExclusion()">
                    <div id="manual-exclude-icon-box" style="width: 40px; height: 40px; border-radius: 12px; background: #f0fdf4; display: flex; align-items: center; justify-content: center; margin-right: 14px; color: #16a34a; transition: all 0.3s ease;">
                        <i id="manual-exclude-icon" class="material-icons" style="font-size: 20px;">check_circle</i>
                    </div>
                    <div style="flex: 1;">
                        <div style="font-size: 9px; color: #94a3b8; font-weight: 700; text-transform: uppercase; margin-bottom: 2px;">Budget Status</div>
                        <div id="manual-exclude-text" style="font-size: 14px; font-weight: 700; color: #1e293b;">Included in Calculations</div>
                    </div>
                    <div class="toggle-switch">
                        <input type="checkbox" id="manual-exclude-toggle" style="display: none;">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
            </div>

            </div>
        </div>
    </div>
    
    <style>
        @keyframes slideUp { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        /* Hide scrollbar for category list */
        #manual-cat-list::-webkit-scrollbar { display: none; }
        #manual-cat-list { -ms-overflow-style: none; scrollbar-width: none; }
        
        .manual-cat-item { display: flex; flex-direction: column; align-items: center; gap: 6px; min-width: 56px; cursor: pointer; opacity: 0.5; transition: all 0.2s; }
        .manual-cat-item.selected { opacity: 1; transform: scale(1.05); }
        .manual-cat-circle { width: 48px; height: 48px; border-radius: 16px; display: flex; align-items: center; justify-content: center; font-size: 20px; transition: all 0.2s; border: 2px solid transparent; }
        .manual-cat-item.selected .manual-cat-circle { box-shadow: 0 8px 16px rgba(0,0,0,0.05); }
        .manual-cat-item span { font-size: 10px !important; }
        /* AUTH FEEDBACK */
        .banner-pill-btn:active, .mui-btn:active { transform: scale(0.96); opacity: 0.8; transition: transform 0.1s, opacity 0.1s; }

        /* TOGGLE SWITCH STYLES */
        .toggle-switch {
            width: 44px;
            height: 24px;
            position: relative;
        }
        .toggle-slider {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #e2e8f0;
            border-radius: 34px;
            transition: .3s;
            cursor: pointer;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: .3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #manual-exclude-toggle:checked + .toggle-slider {
            background-color: #ef4444;
        }
        #manual-exclude-toggle:checked + .toggle-slider:before {
            transform: translateX(20px);
        }
    </style>

    <script>
        // Swipe-to-close functionality for manual transaction modal
        document.addEventListener('DOMContentLoaded', () => {
            const dragHandle = document.getElementById('modal-drag-handle');
            const modalContent = document.getElementById('manual-modal-content');
            let startY = 0;
            let currentY = 0;
            let isDragging = false;

            dragHandle.addEventListener('touchstart', (e) => {
                startY = e.touches[0].clientY;
                isDragging = true;
                dragHandle.style.cursor = 'grabbing';
            });

            dragHandle.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                currentY = e.touches[0].clientY;
                const diff = currentY - startY;
                
                // Only allow downward swipe
                if (diff > 0) {
                    modalContent.style.transform = `translateY(${diff}px)`;
                    modalContent.style.transition = 'none';
                }
            });

            dragHandle.addEventListener('touchend', (e) => {
                if (!isDragging) return;
                isDragging = false;
                dragHandle.style.cursor = 'grab';
                
                const diff = currentY - startY;
                
                // If swiped down more than 100px, close the modal
                if (diff > 100) {
                    modalContent.style.transition = 'transform 0.3s ease-out';
                    modalContent.style.transform = 'translateY(100%)';
                    setTimeout(() => {
                        closeModals();
                        modalContent.style.transform = '';
                        modalContent.style.transition = '';
                    }, 300);
                } else {
                    // Snap back
                    modalContent.style.transition = 'transform 0.2s ease-out';
                    modalContent.style.transform = '';
                    setTimeout(() => {
                        modalContent.style.transition = '';
                    }, 200);
                }
            });
        });
    </script>



    <!-- TOAST BOX -->
    <div id="toast-box" class="toast-container">
        <i class="material-icons">check_circle</i>
        <span id="toast-msg">Updated</span>
    </div>

    <!-- OFFLINE SNACKBAR -->
    <div id="offline-snackbar" class="offline-snackbar">
        <i class="material-icons">cloud_off</i>
        <span id="offline-snackbar-text">Saved offline</span>
    </div>

    <!-- LOGIN SUCCESS MODAL -->
    <div id="login-modal" class="login-modal-overlay">
        <div class="login-modal-card">
            <div class="login-modal-checkmark">
                <svg viewBox="0 0 52 52" width="52" height="52">
                    <circle class="login-check-circle" cx="26" cy="26" r="24" fill="none" stroke="#10b981" stroke-width="3"/>
                    <path class="login-check-path" fill="none" stroke="#10b981" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round" d="M14 27l7.8 7.8L38 17"/>
                </svg>
            </div>

            <div class="login-modal-title">Welcome!</div>
            <div class="login-modal-message" id="login-modal-msg">You're signed in to SmartWallet</div>
            <div class="login-modal-close-hint">Tap anywhere to continue</div>
        </div>
    </div>

    <script>
        // --- PREVENT PINCH-TO-ZOOM ---
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        });

        // --- LOGIN MODAL LOGIC ---
        window.showLoginModal = function() {
            const modal = document.getElementById('login-modal');
            if (!modal) return;
            
            // Personalize with user info
            const userName = localStorage.getItem('user_name') || 'there';
            const userPic = localStorage.getItem('user_pic');
            const msgEl = document.getElementById('login-modal-msg');
            const avatarEl = document.getElementById('login-modal-avatar');
            const titleEl = modal.querySelector('.login-modal-title');
            
            if (titleEl) titleEl.textContent = `Welcome, ${userName}!`;
            if (msgEl) msgEl.textContent = "You're signed in to SmartWallet";
            if (avatarEl && userPic) {
                avatarEl.innerHTML = `<img src="${userPic}" alt="" style="width:100%;height:100%;border-radius:50%;object-fit:cover;">`;
                avatarEl.style.display = 'block';
            }
            
            // Show modal
            modal.classList.add('show');
            
            // Dismiss on tap anywhere
            const dismissModal = () => {
                modal.classList.remove('show');
                modal.removeEventListener('click', dismissModal);
            };
            
            // Add click listener to dismiss
            setTimeout(() => {
                modal.addEventListener('click', dismissModal);
            }, 300); // Small delay to prevent immediate dismissal
        };
    </script>
    <script src="https://accounts.google.com/gsi/client" onload="gisLoaded()" async defer></script>
    <script>
        // Shrink Header on Scroll
        const header = document.getElementById('header');
        // If the workspace is simulated in a mobile-wrapper with overflow
        const scrollContainer = document.querySelector('.mobile-wrapper');
        
        const handleScroll = (container) => {
            if (container.scrollTop > 50) {
                header.classList.add('shrunk');
            } else {
                header.classList.remove('shrunk');
            }
        };

        if (scrollContainer) {
            scrollContainer.addEventListener('scroll', () => handleScroll(scrollContainer));
        }
        window.addEventListener('scroll', () => handleScroll(window.document.documentElement));
    </script>
    
    <script>
        // BIOMETRIC AUTHENTICATION (WebAuthn)
        const biometricOverlay = document.getElementById('biometricOverlay');
        const biometricTitle = document.getElementById('biometricTitle');
        const biometricSubtitle = document.getElementById('biometricSubtitle');
        const biometricBtn = document.getElementById('biometricBtn');
        const biometricSkip = document.getElementById('biometricSkip');
        const biometricError = document.getElementById('biometricError');
        
        // Check if WebAuthn is available
        const isBiometricSupported = () => {
            return window.PublicKeyCredential && 
                   PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable;
        };
        
        // Check if user is logged in
        const isUserLoggedIn = () => {
            return localStorage.getItem('g_access_token') || localStorage.getItem('user_name');
        };
        
        // Check if biometric is already set up
        const isBiometricSetUp = () => {
            return localStorage.getItem('biometric_credential_id') !== null;
        };
        
        // Generate random bytes for challenge
        const generateChallenge = () => {
            const arr = new Uint8Array(32);
            crypto.getRandomValues(arr);
            return arr;
        };
        
        // Convert ArrayBuffer to Base64
        const bufferToBase64 = (buffer) => {
            return btoa(String.fromCharCode(...new Uint8Array(buffer)));
        };
        
        // Convert Base64 to ArrayBuffer
        const base64ToBuffer = (base64) => {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        };
        
        // Show biometric overlay
        const showBiometricOverlay = (mode = 'verify') => {
            const disableBtn = document.getElementById('biometricDisable');
            if (mode === 'setup') {
                biometricTitle.innerText = 'Secure Your Wallet';
                biometricSubtitle.innerText = 'Enable biometric login for faster, more secure access to your accounts.';
                biometricBtn.innerHTML = '<i class="material-icons" style="vertical-align: middle; margin-right: 8px;">fingerprint</i> Set Up Now';
                biometricSkip.style.display = 'block';
                if (disableBtn) disableBtn.style.display = 'none';
            } else {
                biometricTitle.innerText = 'Unlock Wallet';
                biometricSubtitle.innerText = 'Please verify your identity to continue';
                biometricBtn.innerHTML = '<i class="material-icons" style="vertical-align: middle; margin-right: 8px;">fingerprint</i> Authenticate';
                biometricSkip.style.display = 'none';
                if (disableBtn) disableBtn.style.display = 'block';
            }
            biometricError.classList.remove('show');
            biometricOverlay.classList.remove('hiding'); // Ensure doors are closed
            biometricOverlay.classList.add('show');
        };
        
        // Hide biometric overlay with fun animation
        const hideBiometricOverlay = async () => {
            const icon = document.querySelector('.biometric-icon');
            
            // Step 1: Success State (Premium Glow, NO Emerald Checkmark)
            icon.classList.add('success');
            if (navigator.vibrate) navigator.vibrate(15);
            
            // Step 2: Push Down Reveal (Faster)
            setTimeout(() => {
                biometricOverlay.classList.add('hiding');
                
                // Final Cleanup
                setTimeout(() => {
                    biometricOverlay.classList.remove('show', 'hiding');
                    icon.classList.remove('success');
                }, 400); // Faster cleanup
            }, 300); // Faster trigger
        };
        
        
        // Skip biometric setup
        const skipBiometric = () => {
            localStorage.setItem('biometric_skipped', 'true');
            hideBiometricOverlay();
        };
        
        // Register biometric credential
        const registerBiometric = async () => {
            try {
                const userName = localStorage.getItem('user_name') || 'User';
                const userEmail = localStorage.getItem('user_email') || 'user@smartwallet.app';
                
                const credential = await navigator.credentials.create({
                    publicKey: {
                        challenge: generateChallenge(),
                        rp: {
                            name: "SmartWallet",
                            id: window.location.hostname
                        },
                        user: {
                            id: new TextEncoder().encode(userEmail),
                            name: userEmail,
                            displayName: userName
                        },
                        pubKeyCredParams: [
                            { type: "public-key", alg: -7 },  // ES256
                            { type: "public-key", alg: -257 } // RS256
                        ],
                        authenticatorSelection: {
                            authenticatorAttachment: "platform",
                            userVerification: "required",
                            residentKey: "preferred"
                        },
                        timeout: 60000
                    }
                });
                
                // Store credential ID
                const credentialId = bufferToBase64(credential.rawId);
                localStorage.setItem('biometric_credential_id', credentialId);
                localStorage.removeItem('biometric_skipped');
                
                console.log('‚úÖ Biometric registered successfully');
                if (navigator.vibrate) navigator.vibrate(20);
                
                // Clear any pre-existing errors
                biometricError.classList.remove('show');
                
                hideBiometricOverlay();
                
                // Refresh status icon
                if (typeof window.updateBiometricStatus === 'function') window.updateBiometricStatus();
                
                // Show success toast
                showToast('Biometric login enabled!');
                return true;
            } catch (err) {
                console.error('‚ùå Biometric registration failed:', err);
                // Only show error if it's not a cancellation
                if (err.name !== 'NotAllowedError' && err.name !== 'AbortError') {
                    biometricError.textContent = 'Setup failed. Please try again.';
                    biometricError.classList.add('show');
                }
                return false;
            }
        };
        
        // Verify biometric credential
        const verifyBiometric = async () => {
            try {
                const credentialId = localStorage.getItem('biometric_credential_id');
                if (!credentialId) {
                    hideBiometricOverlay();
                    return true;
                }
                
                const credential = await navigator.credentials.get({
                    publicKey: {
                        challenge: generateChallenge(),
                        allowCredentials: [{
                            type: "public-key",
                            id: base64ToBuffer(credentialId),
                            transports: ["internal"]
                        }],
                        userVerification: "required",
                        timeout: 60000
                    }
                });
                
                console.log('‚úÖ Biometric verified successfully');
                if (navigator.vibrate) navigator.vibrate(10);
                
                // Set session validity (10 minutes)
                const now = Date.now();
                localStorage.setItem('biometric_verified_at', now);
                sessionStorage.setItem('biometric_authenticated', 'true');
                
                // Ensure error is hidden
                biometricError.classList.remove('show');
                
                hideBiometricOverlay();
                return true;
            } catch (err) {
                console.error('‚ùå Biometric verification failed:', err);
                if (err.name !== 'NotAllowedError') {
                    biometricError.textContent = 'Verification failed. Please try again.';
                    biometricError.classList.add('show');
                }
                return false;
            }
        };
        
        // Main trigger function
        const triggerBiometricAuth = async () => {
            biometricError.classList.remove('show');
            biometricBtn.disabled = true;
            biometricBtn.innerHTML = '<i class="material-icons spin" style="vertical-align: middle;">sync</i> Waiting...';
            
            let success;
            if (isBiometricSetUp()) {
                success = await verifyBiometric();
            } else {
                success = await registerBiometric();
            }
            
            biometricBtn.disabled = false;
            if (!success) {
                biometricBtn.innerHTML = '<i class="material-icons" style="vertical-align: middle; margin-right: 8px;">fingerprint</i> Try Again';
            }
        };
        
        // Initialize biometric on app load
        const initBiometric = async () => {
            // Only proceed if user is logged in
            if (!isUserLoggedIn()) {
                console.log('üîê Biometric: User not logged in, skipping');
                return;
            }
            
            // Check if biometrics are supported
            if (!isBiometricSupported()) {
                console.log('üîê Biometric: Not supported on this device');
                return;
            }

            // SESSION TIMEOUT CHECK (10 Minutes)
            // sessionStorage is per tab, localStorage persists app closure
            const lastVerified = localStorage.getItem('biometric_verified_at');
            const now = Date.now();
            const tenMinutes = 10 * 60 * 1000;
            
            // If we are navigating between pages in the same session, don't re-prompt
            if (sessionStorage.getItem('biometric_authenticated') === 'true') {
                console.log('üîê Biometric: Already authenticated in this session');
                return;
            }
            
            // If less than 10 minutes since last verification, auto-approve session
            if (lastVerified && (now - lastVerified < tenMinutes)) {
                console.log('üîê Biometric: Valid session (within 10 mins)');
                sessionStorage.setItem('biometric_authenticated', 'true');
                return;
            }
            
            try {
                const available = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
                if (!available) {
                    console.log('üîê Biometric: Platform authenticator not available');
                    return;
                }
                
                // If biometric is set up, prompt for verification
                if (isBiometricSetUp()) {
                    console.log('üîê Biometric: Prompting for verification');
                    showBiometricOverlay('verify');
                    // Auto-trigger verification (reduced timeout for speed)
                    setTimeout(() => triggerBiometricAuth(), 100);
                } 
                // New users will NOT be prompted to setup automatically anymore.
                // They can enable it manually from the profile dropdown.
            } catch (err) {
                console.error('üîê Biometric init error:', err);
            }
        };
        
        // Update indicator in settings
        window.updateBiometricStatus = () => {
            const dot = document.getElementById('biometric-status-dot');
            if (dot) {
                if (isBiometricSetUp()) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            }
        };

        // Handle profile dropdown click
        window.toggleBiometricSetting = () => {
            if (!isBiometricSupported()) {
                showToast('Biometrics not supported on this device');
                return;
            }
            if (isBiometricSetUp()) {
                showAppDialog({
                    title: 'Disable Biometric?',
                    message: 'Are you sure you want to disable biometric login? You will need to setup again if you change your mind.',
                    confirm: true,
                    callback: (ok) => {
                        if (ok) {
                            localStorage.removeItem('biometric_credential_id');
                            window.updateBiometricStatus();
                            showToast('Biometric login disabled');
                        }
                    }
                });
            } else {
                showBiometricOverlay('setup');
            }
        };

        // Run on page load (DOMContentLoaded for faster speed)
        document.addEventListener('DOMContentLoaded', () => {
            initBiometric();
        });
    </script>
    
    <!-- REMOVED: Duplicate auto-sync on window load (triggerAdaptiveSync already handles this) -->
    
    <script>
        // MODERN MATERIAL DESIGN PULL-TO-REFRESH
        (function() {
            const spinner = document.getElementById('ptrSpinner');
            const circle = spinner ? spinner.querySelector('.ptr-circle') : null;
            const mobileWrapper = document.querySelector('.mobile-wrapper') || document.body;
            let startY = 0;
            let pulling = false;
            let isRefreshing = false;
            const pullThreshold = 100; // Distance needed to trigger refresh
            const maxPull = 140; // Maximum pull distance
            
            if (!spinner || !circle) return;
            
            mobileWrapper.addEventListener('touchstart', (e) => {
                if (isRefreshing) return;
                if (mobileWrapper.scrollTop <= 0) {
                    startY = e.touches[0].clientY;
                    pulling = true;
                }
            }, { passive: true });
            
            mobileWrapper.addEventListener('touchmove', (e) => {
                if (!pulling || isRefreshing || mobileWrapper.scrollTop > 0) return;
                
                const currentY = e.touches[0].clientY;
                const pullDistance = Math.max(0, currentY - startY);
                
                if (pullDistance > 10) {
                    e.preventDefault();
                    
                    // Calculate progress with resistance (diminishing returns)
                    const resistance = 0.5;
                    const resistedPull = Math.min(pullDistance * resistance, maxPull);
                    const progress = Math.min(pullDistance / pullThreshold, 1);
                    
                    // Show spinner dropping down
                    spinner.classList.add('visible');
                    spinner.style.transform = `translateY(${resistedPull - 60}px) scale(${0.6 + progress * 0.4}) rotate(${pullDistance * 2}deg)`;
                    
                    // Animate the SVG circle stroke
                    const dashOffset = 60 - (progress * 45); // Fill from 0 to ~75%
                    circle.style.strokeDashoffset = dashOffset;
                    circle.style.transform = `rotate(${pullDistance * 3}deg)`;
                }
            }, { passive: false });
            
            mobileWrapper.addEventListener('touchend', () => {
                if (!pulling || isRefreshing) return;
                pulling = false;
                
                const currentTransform = spinner.style.transform;
                const yMatch = currentTransform.match(/translateY\(([^p]+)px\)/);
                const currentY = yMatch ? parseFloat(yMatch[1]) : -80;
                
                if (currentY > 30) {
                    // Trigger refresh!
                    isRefreshing = true;
                    
                    // Haptic feedback
                    if (navigator.vibrate) navigator.vibrate([10, 30, 10]);
                    
                    // Animate to refreshing state
                    spinner.classList.add('refreshing');
                    circle.style.strokeDashoffset = '';
                    circle.style.transform = '';
                    
                    // Trigger sync
                    const currentAcc = window.currentAccount || localStorage.getItem('wallet_current_account');
                    console.log('üîÑ Pull-to-refresh: Syncing', currentAcc);
                    
                    if ((currentAcc === 'atome' || currentAcc === 'bpi') && typeof handleScan === 'function') {
                        handleScan(50, true);
                    } else if (typeof refreshUIForAccount === 'function') {
                        refreshUIForAccount(currentAcc);
                    }
                    
                    // Hide after delay
                    setTimeout(() => {
                        spinner.classList.remove('refreshing', 'visible');
                        spinner.style.transform = '';
                        circle.style.strokeDashoffset = '60';
                        isRefreshing = false;
                    }, 1800);
                } else {
                    // Cancel - spring back
                    spinner.classList.remove('visible');
                    spinner.style.transform = '';
                    circle.style.strokeDashoffset = '60';
                    circle.style.transform = '';
                }
            });
        })();
    </script>
    
    <!-- Navigation State Management -->
    <script src="nav-state.js"></script>
    <script>
        // Initialize NavState for index.html after DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            if (window.NavState) {
                window.NavState.quickInit('index.html', () => {
                    // Refresh callback - handled by pull-to-refresh above
                    const currentAcc = window.currentAccount || localStorage.getItem('wallet_current_account');
                    console.log('üîÑ NavState refresh triggered for', currentAcc);
                    
                    if ((currentAcc === 'atome' || currentAcc === 'bpi') && typeof handleScan === 'function') {
                        handleScan(50, true);
                    } else if (typeof refreshUIForAccount === 'function') {
                        refreshUIForAccount(currentAcc);
                    }
                });
            }
        });
    </script>
</body>
</html>